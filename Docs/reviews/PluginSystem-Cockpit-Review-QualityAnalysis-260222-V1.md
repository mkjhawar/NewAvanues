# PluginSystem + Cockpit — Quality Analysis Review
**Date:** 260222
**Reviewer:** Code Reviewer Agent
**Branch:** VoiceOS-1M-SpeechEngine
**Scope:** `Modules/PluginSystem/` (173 .kt files) + `Modules/Cockpit/` (47 .kt files)
**Focus:** Plugin lifecycle correctness, dependency resolution, multi-window session management, window lifecycle edge cases

---

## Summary

PluginSystem has a foundational architectural conflict: `PluginLoader` and `PluginClassLoader` are built around DEX bytecode loading (`DexClassLoader`) while the stated plugin format is `.avp` text files. This must be resolved before the plugin system can be considered functional. Beyond that, there are two critical security gaps — permission state is never persisted (survives only until app restart), and `DependencyResolver.buildDependencyGraph()` throws exceptions for version conflicts instead of returning typed failure values, bypassing the caller's error handling path. The Cockpit module is architecturally sound with a correct KMP ViewModel pattern and clean layout engine, but both repository implementations are nearly identical (DRY violation) and `CockpitSession.workflowSteps` is never populated from the database during load, silently losing the field on every app restart.

---

## Module 1: PluginSystem

**Files reviewed:** PluginLoader.kt, PluginRegistry.kt, PluginManifest.kt, DependencyResolver.kt, PluginSandbox.kt, PermissionStorage.kt, TransactionManager.kt, PluginStateStorage.kt, PermissionEscalationDetector.kt, CompositePluginDiscovery.kt, GrpcPluginEventBus.kt, BasePlugin.kt, UniversalPlugin.kt, PluginClassLoader.kt (androidMain), AndroidPluginHost.kt (androidMain), PluginHandlerBridge.kt (androidMain), PluginSystemSetup.android.kt (androidMain)

### Issues

| Severity | File:Line | Issue | Suggestion |
|----------|-----------|-------|------------|
| Critical | `core/PluginLoader.kt:229` + `platform/PluginClassLoader.kt:14-37` | `PluginLoader.loadPlugin()` calls `classLoader.loadClass(manifest.entrypoint, libraryPath)` which uses Android `DexClassLoader` requiring compiled DEX bytecode. The project states `.avp` text file format for plugins. These are incompatible — DEX classloading cannot load text/script files. Either the `.avp` format needs a compile step (`.avp` → DEX), or `PluginClassLoader` needs a script-based execution path. The docstring at `PluginLoader.kt:41` even references `plugin.jar` in its usage example, confirming the mismatch. | Clarify the plugin execution model. If `.avp` files are interpreted (scripts), replace `DexClassLoader` with a KMP-native interpreter (e.g., a bundled Lua/JS engine or a custom bytecode VM). If `.avp` files are compiled, document and implement the compile step. This is a blocker before the plugin system is functional. |
| Critical | `security/PluginSandbox.kt:362` + `security/PermissionStorage.kt` (expect class) | `DefaultPluginSandbox` stores all granted permissions in `private val permissions = mutableMapOf<String, MutableSet<PluginPermission>>()` entirely in memory. The `PermissionStorage` expect/actual class (designed for AES256-GCM encrypted persistence) is defined but never called from `DefaultPluginSandbox`. Result: every app restart resets all plugin permissions. Any plugin permission grant by the user is silently lost. | Wire `PermissionStorage` into `DefaultPluginSandbox`. On `grantPermission()`, write through to `PermissionStorage`. On construction, load persisted permissions. On `revokePermission/revokeAllPermissions()`, delete from storage. |
| High | `dependencies/DependencyResolver.kt:82-96` | `buildDependencyGraph()` throws `IllegalStateException` for two conditions: (1) invalid version constraint format (L82-85), (2) version not satisfying constraint (L92-96). The caller `resolveDependencies()` at L42 calls this without try/catch, expecting the `ResolutionResult.Failure` sealed type to carry all errors. The `IllegalStateException` propagates past `resolveDependencies()` uncaught and will crash the plugin loading coroutine. `ResolutionResult.Failure` already exists as the correct return type. | Convert both `throw IllegalStateException(...)` in `buildDependencyGraph()` to return `ResolutionResult.Failure(...)` by making `buildDependencyGraph()` return `ResolutionResult` and early-returning on failure. |
| High | `integration/PluginSystemSetup.android.kt:312` | `AndroidCommandDispatcher.dispatch()` creates a `QuantizedCommand` with `actionType = CommandActionType.CLICK` hardcoded regardless of the actual command intent. This will misroute any command that is not a click — e.g., scroll, navigation, text input. Every non-click plugin command will be dispatched as a CLICK action. | Parse or infer the `CommandActionType` from the command string/context. At minimum, accept it as a parameter to `dispatch()`. A static lookup table of command-to-action-type mappings would be appropriate until full NLU integration. |
| High | `core/PluginRegistry.kt:445,449` | `addToIndex()` calls `PluginSource.valueOf(info.manifest.source.uppercase())` and `DeveloperVerificationLevel.valueOf(info.manifest.verificationLevel.uppercase())`. `PluginManifest.source` and `verificationLevel` are both `String` fields (not typed enums) so any invalid value in a plugin's manifest throws `IllegalArgumentException` inside `addToIndex()`, which is called inside a mutex lock. The exception propagates and crashes `register()`. | Guard both calls with `runCatching` or use `PluginSource.entries.firstOrNull { it.name == source.uppercase() } ?: PluginSource.UNKNOWN`. Also change `PluginManifest.source` and `verificationLevel` to their respective enum types, enforcing validity at parse time. |
| High | `androidMain/platform/PluginClassLoader.kt:14-37` | `DexClassLoader` writes optimized DEX output to `File(pluginPath).parentFile?.absolutePath + "/dex_opt/"`. This writes outside the plugin's own sandbox directory into the parent directory of wherever `pluginPath` is located. On Android 10+, this path may not be writable and also bypasses any sandbox isolation the namespace system attempts to provide. | Use the app's internal cache directory (`context.codeCacheDir`) for optimized DEX output, not the plugin parent directory. Pass the cache directory as a constructor parameter. |
| Medium | `discovery/CompositePluginDiscovery.kt:82,237,240` | `lastDiscoveryResult` (L82) is a plain `var` with no mutex protection. `discoverWithDetails()` writes to it at L237 after releasing `mutex`. Concurrent calls to `discoverWithDetails()` + `getLastResult()` (if it exists) or any other reader will see a data race. Additionally, `discoveryListeners` at L87 is a plain `mutableListOf` mutated by `addDiscoveryListener()`/`removeDiscoveryListener()` with no mutex, while `discoverWithDetails()` iterates it at L240 without holding the mutex — `ConcurrentModificationException` risk. | Protect `lastDiscoveryResult` with `@Volatile` or move its write inside the mutex. Protect `discoveryListeners` with a `CopyOnWriteArrayList` or synchronize `add/remove` and take a snapshot copy before iteration in `discoverWithDetails()`. |
| Medium | `hotreload/PluginStateStorage.kt:397-406` | `buildMetadataJson()` at L400 writes `"pluginId": "${metadata.pluginId}"` without JSON-escaping the plugin ID. A plugin ID containing `"` (double quote) or `\` (backslash) will produce malformed JSON. The subsequent `parseMetadataJson()` regex at L430 will fail to extract the ID from the corrupted JSON, silently falling back to `defaultPluginId`. | Replace the hand-rolled JSON builder with `kotlinx.serialization` on `StateMetadata`. Alternatively, if dependency is unavailable, use `metadata.pluginId.replace("\\", "\\\\").replace("\"", "\\\"")` in the template. |
| Medium | `hotreload/PluginStateStorage.kt:429-431` | `extractJsonString()` regex `[^"]+` at L430 does not handle escaped quotes within the value. Any JSON string containing an escaped `\"` will be truncated at the backslash. This compounds the serialization issue above. | As above — use `kotlinx.serialization` for this. The hand-rolled parser is inherently fragile and should not be used for structured metadata. |
| Medium | `transactions/TransactionManager.kt:169-171` | `MAX_BACKUP_SIZE_MB = 500L` limit is only logged as a warning but the backup proceeds regardless. An oversized backup (~500 MB filesystem snapshot) could fill the device's storage. The warning says "exceeds maximum recommended size" but does not enforce the limit. | Either enforce the limit by returning a failure from `createCheckpoint()` when the backup would exceed the threshold, or at minimum surface this as a `CheckpointResult.Warning` that callers can inspect. |
| Medium | `sdk/BasePlugin.kt:162` | `activate()` checks `state !in setOf(PluginState.STOPPED, PluginState.ERROR, PluginState.INITIALIZING)`. This allows activation from `INITIALIZING` state (unusual — activation during initialization is a lifecycle race). It also does NOT allow activation from `PluginState.FAILED` state, but FAILED is not listed as an invalid state — this is a logic inversion. The intent appears to be: allow activation only from STOPPED/ERROR/INITIALIZING. But the guard prevents activation from STOPPED and ERROR, which are the states most likely to legitimately re-activate. Verify the intended lifecycle transitions. | Review and explicitly document the allowed state transitions. A typical plugin lifecycle allows activation from STOPPED, PAUSED, or ERROR (after recovery). INITIALIZING → ACTIVE is valid as a direct transition. FAILED may need a reset step before activation. Express this as a positive allowlist: `if (state !in setOf(STOPPED, PAUSED, ERROR, INITIALIZING)) return`. |
| Medium | `androidMain/android/AndroidPluginHost.kt:123` | Default `scope = CoroutineScope(SupervisorJob() + Dispatchers.Main)` — `Dispatchers.Main` is not available in all environments (desktop JVM tests, non-Android platforms). If this class is ever instantiated outside Android (e.g., in unit tests), it will throw at construction time. | Default to `Dispatchers.Default`, which is safe on all platforms. The `AndroidPluginHost` is Android-specific, but test code running on JVM often doesn't have a `Main` dispatcher unless explicitly provided via `Dispatchers.setMain()`. |
| Medium | `security/PermissionEscalationDetector.kt:213` | `manifestPermissions: MutableMap<String, List<String>>` is accepted as a constructor parameter. The caller retains a reference to the same `MutableMap` and can mutate it externally after construction, bypassing `PermissionEscalationDetector`'s internal `synchronized(lock)` protection. This is a classic defensive copy omission. | Change constructor to accept `Map<String, List<String>>` (immutable interface) and immediately copy: `this.manifestPermissions = HashMap(manifestPermissions)`. |
| Low | `core/PluginLoader.kt:41` | KDoc usage example uses `libraryPath = "…/plugin.jar"`. If the plugin format is `.avp`, this is misleading documentation. | Update usage example to match actual plugin format. |
| Low | `core/PluginManifest.kt` | `source: String` and `verificationLevel: String` are stringly-typed fields where enum types already exist (`PluginSource`, `DeveloperVerificationLevel`). Invalid manifest values are only caught at index time (and crash). | Change field types to their enums with `@SerialName`-annotated `@Serializable` enum variants for YAML deserialization. |
| Low | `transactions/TransactionManager.kt` | `cleanupStaleCheckpoints()` removes in-memory checkpoint entries but does not delete backup directories created by `captureFilesystemSnapshot()`. If the app crashes between checkpoint creation and cleanup, orphaned backup directories accumulate on disk indefinitely. | Add filesystem cleanup: iterate `checkpointDir` on startup and remove any backup subdirectory not referenced by an active in-memory checkpoint. |

### Positive Observations

- `DependencyResolver` DFS cycle detection (L112-150) is correct: it maintains a recursion stack separate from the visited set, correctly identifies the cycle path, and includes it in `ResolutionResult.Failure`. This is the right algorithm.
- `GrpcPluginEventBus` uses `kotlinx.coroutines.sync.Mutex` (not Java `synchronized`) throughout — correct for coroutine contexts.
- `PluginRegistry` uses `kotlinx.coroutines.sync.Mutex` throughout — correct.
- `CompositePluginDiscovery.discoverWithDetails()` uses `coroutineScope { async { ... }.awaitAll() }` for parallel discovery with proper structured concurrency — correct pattern.
- `PluginHandlerBridge` metrics via `MutableStateFlow` and the plugin-first routing with configurable confidence threshold are solid design choices.
- `BasePlugin.shutdown()` setting state to `STOPPED` even when `onShutdown()` throws is intentional and correct — a plugin that fails to shut down cleanly should still be considered stopped to allow cleanup.
- `AndroidPluginHost.onActivityPaused/Resumed` correctly scopes pause/resume to ACTIVE/PAUSED states respectively, preventing double-pause or resume-from-wrong-state.

---

## Module 2: Cockpit

**Files reviewed:** CockpitViewModel.kt, CockpitSession.kt, CockpitFrame.kt, FrameContent.kt, LayoutEngine.kt, FrameWindow.kt, ContentRenderer.kt, CommandBar.kt, WorkflowSidebar.kt, MinimizedTaskbar.kt, FreeformCanvas.kt, ICockpitRepository.kt, AndroidCockpitRepository.kt, DesktopCockpitRepository.kt, all remaining Cockpit .kt files

### Issues

| Severity | File:Line | Issue | Suggestion |
|----------|-----------|-------|------------|
| High | `androidMain/repository/AndroidCockpitRepository.kt` + `desktopMain/repository/DesktopCockpitRepository.kt` | Both repository implementations are ~360 lines and nearly identical — only the KDoc file header differs. All SQLDelight query logic, `deserializeContent()`, `parseLayoutMode()`, `parseLinkTrigger()`, `parseLinkAction()`, `SessionExport`, `importSession()`, `exportSession()` are byte-for-byte duplicated. Any bug fix to one must be manually mirrored to the other, and they will inevitably diverge. | Extract a `BaseCockpitRepository(database: VoiceOSDatabase)` abstract class in `commonMain` (or `jvmMain` since both targets are JVM-based) containing all shared logic. Both `AndroidCockpitRepository` and `DesktopCockpitRepository` become thin subclasses with only driver construction differing. |
| High | `commonMain/model/CockpitSession.kt` + both repository implementations | `CockpitSession` has a `workflowSteps: List<WorkflowStep>` field. Neither `getSessions()` nor `getSession()` in either repository implementation queries `cockpitWorkflowStepQueries` — they only map the session row columns. The `CockpitViewModel.loadSession()` calls `repository.getSession(sessionId)` to restore a session; the returned session always has `workflowSteps = emptyList()`. After every app restart, all workflow step assignments are lost from `CockpitSession`. | Either: (a) remove `workflowSteps` from `CockpitSession` and load workflow steps separately via `getWorkflowSteps(sessionId)` (exposing a separate `workflowSteps: StateFlow<List<WorkflowStep>>` in the ViewModel), or (b) populate it in `getSession()`/`getSessions()` by joining with `cockpitWorkflowStepQueries.getBySession()`. Option (a) is preferred as it avoids loading potentially large step lists on every session fetch. |
| High | `desktopMain/repository/DesktopCockpitRepository.kt:304-313` | `importSession()` generates new frame IDs using `"${now.toEpochMilliseconds()}_${(0..99999).random()}"` in a loop over all source frames — all frames share the same `now.toEpochMilliseconds()` timestamp (captured once before the loop). With only `(0..99999)` = 100,000 possible values for the random suffix, importing a session with many frames has a non-trivial ID collision probability (birthday paradox: ~50% collision chance around 316 frames). The same issue exists in `AndroidCockpitRepository.kt:305-313`. | Use `CockpitViewModel.generateId()` pattern: `Clock.System.now().toEpochMilliseconds().toString(36) + "_" + Random.nextLong(0, Long.MAX_VALUE).toString(36)`. With a full 64-bit random, collision probability is negligible. Or use `java.util.UUID.randomUUID()` on JVM targets. |
| High | `commonMain/viewmodel/CockpitViewModel.kt:60-61,169-177,145` | `nextZOrder: Int` is a plain `var` (not `AtomicInteger`, not protected by `Mutex`). `addFrame()` (L139: `zOrder = nextZOrder++`) and `selectFrame()` (L172: `state.copy(zOrder = nextZOrder++)`) both run inside separate `scope.launch` blocks on `Dispatchers.Default`. If two `addFrame()` or `selectFrame()` calls fire concurrently, both can read the same `nextZOrder` value, resulting in two frames sharing a Z-order. Additionally, `_frames.value = currentFrames + frame` (L145) uses a snapshot `currentFrames` captured before the launch — concurrent `addFrame()` calls will lose frames. | Replace `nextZOrder` with `AtomicInteger`. For `_frames` mutations, use a single-threaded `Dispatchers.Default.limitedParallelism(1)` dispatcher for the ViewModel scope, or serialize frame mutations through a `Mutex`. |
| Medium | `androidMain/repository/AndroidCockpitRepository.kt:286,321-323` | `importSession()` catches all exceptions and returns `null` with no error message logged or surfaced. A malformed JSON import, a DB write failure, or a schema mismatch all produce the same silent `null` result. The caller (`CockpitViewModel`, if it calls import) has no way to distinguish "malformed data" from "DB write failed" from "session already exists". | Return a `Result<CockpitSession>` or a sealed `ImportResult` with specific failure subtypes. At minimum, log the exception with the error message before returning `null`. |
| Medium | `commonMain/viewmodel/CockpitViewModel.kt:98-111` | `createSession()` is a `suspend fun` and calls `repository.saveSession()` + `repository.getSessions()` directly, yet it is called from `initialize()` inside `scope.launch` (L72) and from `deleteSession()` (L307) also inside `scope.launch`. This is correct in those call sites. However, `createSession()` is `public suspend fun` — external callers could call it from any context. The docstring says "Suspends until persisted" but does not warn callers about the `Dispatchers.Default` context. | Either make `createSession()` `private` (it is only called internally) or `internal`, or add `withContext(Dispatchers.IO)` inside the repository calls. |
| Medium | `commonMain/viewmodel/CockpitViewModel.kt:317-329` | `deleteSession()` calls `loadSession(remaining.first().id)` at L305 which itself calls `scope.launch`. This launches a child coroutine from within another `scope.launch` block (the `deleteSession` coroutine). If the outer `deleteSession` coroutine is cancelled (e.g., `dispose()` is called during deletion), the inner `loadSession` coroutine may still run against a cancelled scope. `SupervisorJob` on the scope means the inner launch will likely succeed, but this nested launch pattern creates implicit ordering dependencies that are not documented. | Inline `loadSession()` as a direct `suspend` call rather than launching a new coroutine. Since `deleteSession()` is already inside `scope.launch`, it can call `loadSession()` directly as a suspend function: change `loadSession(sessionId)` from calling `scope.launch { ... }` to being a `private suspend fun loadSessionInternal(sessionId: String)` and have the `public fun loadSession()` launch it in scope. |
| Low | `commonMain/viewmodel/CockpitViewModel.kt:361-365` | `generateId()` is not cryptographically random and uses only millisecond precision for the timestamp prefix. In automated test environments where `Clock.System.now()` may be mocked or where many IDs are generated in a tight loop, the timestamp component provides zero entropy. The `Random.nextLong(0, Long.MAX_VALUE)` component provides ~63 bits of entropy which is sufficient for uniqueness, but the function does not guarantee global uniqueness across devices. | Document that this ID is device-local and not globally unique. For cross-device export/import scenarios (where IDs from different devices may be merged), consider UUID generation: `java.util.UUID.randomUUID().toString()` on JVM targets via `expect/actual`. |
| Low | `commonMain/ui/FrameWindow.kt` — `TrafficDot` interactive elements | `TrafficDot` at L317-373 accepts `contentDescription: String` and passes it to the inner `Icon` composable at L366. However, the 24dp `Box` that is the actual clickable target at L333-352 does NOT have `semantics { contentDescription = ... }` or `Role.Button` on the `Modifier`. Screen readers will either miss the click target or read the inner icon's description from an inaccessible position. Previously confirmed by MEMORY.md as having AVID — this review finds it incomplete. | Add `.semantics { contentDescription = contentDescription; role = Role.Button }` to the outer 24dp `Box` modifier at L333. Remove the `contentDescription` from the inner `Icon` (it becomes redundant decoration). |
| Low | `commonMain/ui/LayoutEngine.kt` | `FullscreenLayout` (L635 approx.) shows only one frame at a time. If the user has maximized a frame that is not the currently `selectedFrameId`, the layout shows a different frame than the selected one. The current implementation shows `frames.firstOrNull { it.state.isMaximized } ?: frames.firstOrNull()` (or similar). This can leave the selected frame hidden with no user indication. | When switching to FULLSCREEN layout, explicitly call `viewModel.selectFrame(maximizedFrameId)` so the selected frame matches what is visible. Or show the currently selected frame in fullscreen mode, ignoring the `isMaximized` flag. |

### Positive Observations

- `CockpitViewModel` correctly uses `SupervisorJob + Dispatchers.Default` as a KMP-safe scope (not `Dispatchers.Main` which is unavailable on Desktop), consistent with the pattern used in the broader codebase.
- Auto-save debounce implementation (L317-323) is correct: `autoSaveJob?.cancel()` followed by `delay(AUTO_SAVE_DEBOUNCE_MS)` properly resets the timer on every change. No double-save or missed-save issues.
- `LayoutEngine` `when` block covering all 13 layout modes exhaustively is correct.
- `contentTypeIcon()` at `FrameWindow.kt:395-413` covers all 17 `FrameContent` subtypes — no missing branches.
- `DesktopCockpitRepository.deserializeContent()` has a correct fallback for all 17 content types when JSON deserialization fails, preventing crashes on schema migration.
- `CockpitFrame.isSpatiallyLocked` as a computed property (derived from `spatialPosition`) is cleaner than persisting a redundant boolean field.
- `FrameWindow` title bar correctly uses `AvanueTheme.colors.*` throughout with no `MaterialTheme.colorScheme.*` references — compliant with theme rules.

---

## Cross-Module Issues

| Severity | Files | Issue | Suggestion |
|----------|-------|-------|------------|
| Medium | `PluginSystem/*` + `Cockpit/*` | Neither module has any unit test files in their respective `src/*/test/` directories (none discovered during file scan). The PluginSystem in particular has complex stateful behavior (dependency resolution, permission management, transaction rollback) that is difficult to validate without tests. | Add unit tests for: `DependencyResolver` (cycle detection, version constraint validation), `DefaultPluginSandbox` (permission grant/revoke/check), `TransactionManager` (rollback scenarios), `CockpitViewModel` (auto-save debounce, frame add/remove/select), and `DesktopCockpitRepository` (import/export round-trip). |

---

## Findings Summary

| Module | Critical | High | Medium | Low | Total |
|--------|----------|------|--------|-----|-------|
| PluginSystem | 2 | 4 | 5 | 3 | 14 |
| Cockpit | 0 | 4 | 4 | 2 | 10 |
| Cross-module | 0 | 0 | 1 | 0 | 1 |
| **Total** | **2** | **8** | **10** | **5** | **25** |

---

## Priority Fix Order

1. **[CRITICAL] PluginClassLoader / PluginLoader architecture mismatch** — Resolve whether `.avp` plugins require a compile step or need a script-based execution path. This is a blocker for all plugin functionality.
2. **[CRITICAL] Permission persistence gap** — Wire `PermissionStorage` into `DefaultPluginSandbox` so granted permissions survive app restarts.
3. **[HIGH] DependencyResolver throws instead of returns failure** — Convert `IllegalStateException` throws to `ResolutionResult.Failure` returns.
4. **[HIGH] AndroidCommandDispatcher hardcodes CLICK** — Pass or infer `CommandActionType` in the dispatcher.
5. **[HIGH] PluginRegistry.addToIndex() crashes on invalid manifest strings** — Guard `valueOf()` calls.
6. **[HIGH] Cockpit DRY violation** — Extract `BaseCockpitRepository` before both implementations diverge further.
7. **[HIGH] CockpitSession.workflowSteps never restored** — Load workflow steps in `loadSession()` or decouple from session model.
8. **[HIGH] importSession() ID collision risk** — Use full 64-bit random for frame IDs in import loops.
9. **[HIGH] CockpitViewModel.nextZOrder + _frames concurrent mutation** — Add `AtomicInteger` + serialized coroutine context.
