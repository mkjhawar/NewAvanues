# VoiceOSCore-Fix-VOSDistributionAndDispatch-260211-V1

## Summary

Combined implementation of two critical workstreams:

1. **VOS Distribution System (Phase A)**: Split monolithic .VOS files into domain-specific .app.vos + .web.vos, create VOS file registry, build export/import infrastructure
2. **Static Command Dispatch Gap**: Create 7 new IHandler implementations to route 91/107 VOS-defined voice commands that were previously silently failing

## Problem Statement

### Distribution Problem

- **Monolithic file structure**: 107 voice commands shipped as single .VOS file per locale (5 files total)
- **No sharing mechanism**: Web-scraped commands cannot be synchronized between devices or re-distributed
- **Version control gap**: No way to track VOS file provenance, version, content hash, or generation date
- **Unmaintainable mixing**: App commands (translatable, locale-specific) mixed with web/gesture commands (universal, device-independent)
- **No deduplication**: Duplicate command definitions across files cannot be detected or merged

### Dispatch Gap Problem

- **Defined but unimplemented**: VOS seed files defined 107 commands across 11 categories
- **Handler shortage**: Only 4 handlers existed: AndroidGestureHandler, SystemHandler, AppHandler, AndroidCursorHandler
- **Coverage gap**: Only ~16 commands (NAVIGATION, APP_LAUNCH, GAZE) had working handler dispatch
- **Silent failures**: 91 commands (MEDIA, DEVICE/SYSTEM, TEXT, INPUT, APP_CONTROL, ACCESSIBILITY, VOICE_CONTROL) returned HandlerResult.notHandled() when invoked, giving users no visual feedback that the command was not available

**Impact**: Users speak supported voice commands, see no action, report "voice not working" to support

## Solution Overview

### Wave 1: VOS Split + Registry Infrastructure

**Goal**: Enable multi-file distribution, track provenance, support export/import

#### 1.1 File Split Strategy
```
Before (Monolithic):
  en-US.VOS (107 commands, 45 KB)
  es-ES.VOS
  fr-FR.VOS
  de-DE.VOS
  hi-IN.VOS

After (Domain-Specific):
  en-US.app.vos (62 commands: nav, media, sys, voice, app, acc, text, input, appctl)
  en-US.web.vos (45 commands: browser, gesture)
  es-ES.app.vos + es-ES.web.vos
  ... (same for fr-FR, de-DE, hi-IN)
```

**Rationale**:
- `.app.vos`: Ship with app, user-facing, frequently localized
- `.web.vos`: Universal (same in all locales), synced from cloud, generated by scraper
- **Localization**: Only translate `.app.vos` descriptions/phrases; `.web.vos` reused across locales
- **Distribution**: `.app.vos` in APK; `.web.vos` synced via HTTP from cloud (Phase B)

#### 1.2 Version Bump: 2.0 → 2.1
```json
{
  "version": "2.1",
  "domain": "app",  // NEW: "app" or "web"
  "locale": "en-US",
  "commands": [ ... ]
}
```

#### 1.3 CommandLoader Extensions
```kotlin
fun CommandLoader.loadAppCommands(context: Context, locale: String): List<VoiceCommandEntity>
fun CommandLoader.loadWebCommands(context: Context, locale: String): List<VoiceCommandEntity>
fun CommandLoader.loadAllCommands(context: Context, locale: String): List<VoiceCommandEntity>
  // Loads both, merges by ID, deduplicates
```

#### 1.4 VOS File Registry Database Table
```sql
CREATE TABLE vos_file_registry (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  file_name TEXT NOT NULL,
  domain TEXT NOT NULL,  -- "app" or "web"
  locale TEXT NOT NULL,
  version TEXT NOT NULL,
  content_hash TEXT NOT NULL UNIQUE,  -- SHA-256
  file_size INTEGER NOT NULL,
  command_count INTEGER NOT NULL,
  source TEXT,  -- "builtin", "cloud", "user_export", "import"
  generated_at TEXT NOT NULL,  -- ISO 8601
  synced_at TEXT,
  last_accessed_at TEXT,
  is_active BOOLEAN DEFAULT 1,
  metadata TEXT,  -- JSON extras
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_vos_file_domain_locale ON vos_file_registry(domain, locale);
CREATE INDEX idx_vos_file_content_hash ON vos_file_registry(content_hash);
```

**Named Queries** (16 total):
- `selectAll()`, `selectById()`, `selectByFileNameAndLocale()`
- `selectByDomain()`, `selectByDomainAndLocale()`, `selectByLocale()`
- `selectActiveByLocale()`, `selectByContentHash()`, `selectBySource()`
- `insertVosFile()`, `updateIsActive()`, `updateSyncedAt()`, `updateLastAccessedAt()`
- `deleteByContentHash()`, `deleteByFileNameAndLocale()`, `countByLocale()`

#### 1.5 Repository Interface
```kotlin
interface IVosFileRegistryRepository {
  suspend fun getAll(): List<VosFileRegistryDTO>
  suspend fun getById(id: Long): VosFileRegistryDTO?
  suspend fun getByFileNameAndLocale(fileName: String, locale: String): VosFileRegistryDTO?
  suspend fun getByDomain(domain: String): List<VosFileRegistryDTO>
  suspend fun getByDomainAndLocale(domain: String, locale: String): List<VosFileRegistryDTO>
  suspend fun getByLocale(locale: String): List<VosFileRegistryDTO>
  suspend fun getActiveByLocale(locale: String): List<VosFileRegistryDTO>
  suspend fun getByContentHash(hash: String): VosFileRegistryDTO?
  suspend fun getBySource(source: String): List<VosFileRegistryDTO>
  suspend fun insert(dto: VosFileRegistryDTO): Long
  suspend fun updateIsActive(id: Long, isActive: Boolean)
  suspend fun updateSyncedAt(id: Long, timestamp: String)
  suspend fun updateLastAccessedAt(id: Long, timestamp: String)
  suspend fun deleteByContentHash(hash: String)
  suspend fun deleteByFileNameAndLocale(fileName: String, locale: String)
  suspend fun countByLocale(locale: String): Long
}
```

#### 1.6 SQLDelight Implementation
```kotlin
class SQLDelightVosFileRegistryRepository(
  private val databaseQueries: VosFileRegistryQueries
) : IVosFileRegistryRepository {
  // Implements all 15 methods, uses databaseQueries for SQL execution
}
```

#### 1.7 DTO Data Class
```kotlin
@Serializable
data class VosFileRegistryDTO(
  val id: Long? = null,
  val fileName: String,
  val domain: String,  // "app" or "web"
  val locale: String,
  val version: String,
  val contentHash: String,
  val fileSize: Long,
  val commandCount: Int,
  val source: String,  // "builtin", "cloud", "user_export", "import"
  val generatedAt: String,  // ISO 8601
  val syncedAt: String? = null,
  val lastAccessedAt: String? = null,
  val isActive: Boolean = true,
  val metadata: String? = null,
  val createdAt: String? = null,
  val updatedAt: String? = null
)

// Mapping extension
fun VosFileRegistry.toDTO(): VosFileRegistryDTO = VosFileRegistryDTO(...)
fun VosFileRegistryDTO.toEntity(): VosFileRegistry = VosFileRegistry(...)
```

### Wave 2: 7 New IHandler Implementations

**Goal**: Route 91/107 previously unhandled commands to working implementations

#### 2.1 Handler Architecture
```
IHandler (Base Interface)
  ├── AndroidGestureHandler (existing)
  ├── SystemHandler (existing)
  ├── AppHandler (existing)
  ├── AndroidCursorHandler (existing)
  ├── MediaHandler (NEW)
  ├── ScreenHandler (NEW)
  ├── TextHandler (NEW)
  ├── InputHandler (NEW)
  ├── AppControlHandler (NEW)
  ├── ReadingHandler (NEW)
  └── VoiceControlHandler (NEW)
```

#### 2.2 MediaHandler
**Category**: MEDIA (7 commands)
**Commands**: play, pause, next track, previous track, volume up, volume down, mute

**Implementation**:
```kotlin
class MediaHandler(context: Context) : BaseHandler {
  private val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager

  override fun canHandle(category: ActionCategory): Boolean =
    category == ActionCategory.MEDIA

  override suspend fun handle(command: StaticCommand): HandlerResult {
    return when (command.id) {
      "play" -> dispatchMediaKey(KeyEvent.KEYCODE_MEDIA_PLAY)
      "pause" -> dispatchMediaKey(KeyEvent.KEYCODE_MEDIA_PAUSE)
      "next_track" -> dispatchMediaKey(KeyEvent.KEYCODE_MEDIA_NEXT)
      "previous_track" -> dispatchMediaKey(KeyEvent.KEYCODE_MEDIA_PREVIOUS)
      "volume_up" -> {
        audioManager.adjustVolume(AudioManager.ADJUST_RAISE, AudioManager.FLAG_SHOW_UI)
        HandlerResult.handled()
      }
      "volume_down" -> {
        audioManager.adjustVolume(AudioManager.ADJUST_LOWER, AudioManager.FLAG_SHOW_UI)
        HandlerResult.handled()
      }
      "mute" -> {
        audioManager.adjustVolume(AudioManager.ADJUST_MUTE, AudioManager.FLAG_SHOW_UI)
        HandlerResult.handled()
      }
      else -> HandlerResult.notHandled()
    }
  }

  private fun dispatchMediaKey(keyCode: Int): HandlerResult {
    val event = KeyEvent(KeyEvent.ACTION_DOWN, keyCode)
    (context.getSystemService(Context.AUDIO_SERVICE) as AudioManager)
      .dispatchMediaKeyEvent(event)
    return HandlerResult.handled()
  }
}
```

**Technology**: AudioManager + KeyEvent dispatch

#### 2.3 ScreenHandler
**Category**: DEVICE (11 commands)
**Commands**: brightness up, brightness down, toggle wifi, toggle bluetooth, screenshot, flashlight on/off, rotate screen, open settings, show notifications, emergency call

**Implementation**:
```kotlin
class ScreenHandler(context: Context) : BaseHandler {
  private val settingsResolver = context.contentResolver

  override fun canHandle(category: ActionCategory): Boolean =
    category == ActionCategory.DEVICE

  override suspend fun handle(command: StaticCommand): HandlerResult {
    return try {
      when (command.id) {
        "brightness_up" -> adjustBrightness(increase = true)
        "brightness_down" -> adjustBrightness(increase = false)
        "toggle_wifi" -> toggleSetting(Settings.Global.WIFI_ON)
        "toggle_bluetooth" -> toggleBluetooth()
        "screenshot" -> takeScreenshot()
        "flashlight_on" -> toggleFlashlight(true)
        "flashlight_off" -> toggleFlashlight(false)
        "rotate_screen" -> rotateScreen()
        "open_settings" -> openSettings()
        "show_notifications" -> expandNotificationPanel()
        "emergency_call" -> initiateEmergencyCall()
        else -> HandlerResult.notHandled()
      }
    } catch (e: Exception) {
      HandlerResult.error(e.message ?: "Screen action failed")
    }
  }

  // Implementation details for each action
}
```

**Technology**: Settings.System + PowerManager + SecurityException handling

#### 2.4 TextHandler
**Category**: INPUT (5 commands)
**Commands**: select all, copy, paste, cut, delete

**Implementation**:
```kotlin
class TextHandler(
  private val accessibilityNodeInfoProvider: AccessibilityNodeInfoProvider
) : BaseHandler {

  override fun canHandle(category: ActionCategory): Boolean =
    category == ActionCategory.INPUT

  override suspend fun handle(command: StaticCommand): HandlerResult {
    val focusedNode = accessibilityNodeInfoProvider.getFocusedNode()
      ?: return HandlerResult.error("No focused text field")

    if (!focusedNode.isEditable) {
      return HandlerResult.error("Focused element is not editable")
    }

    return when (command.id) {
      "select_all" -> performAction(focusedNode, AccessibilityNodeInfo.ACTION_SELECT_ALL)
      "copy" -> performAction(focusedNode, AccessibilityNodeInfo.ACTION_COPY)
      "paste" -> performAction(focusedNode, AccessibilityNodeInfo.ACTION_PASTE)
      "cut" -> performAction(focusedNode, AccessibilityNodeInfo.ACTION_CUT)
      "delete" -> performAction(focusedNode, AccessibilityNodeInfo.ACTION_CLEAR_SELECTION)
      else -> HandlerResult.notHandled()
    }
  }

  private fun performAction(node: AccessibilityNodeInfo, action: Int): HandlerResult =
    if (node.performAction(action)) HandlerResult.handled()
    else HandlerResult.error("Action not supported")
}
```

**Technology**: AccessibilityNodeInfo + editable state checking

#### 2.5 InputHandler
**Category**: INPUT (1 command)
**Commands**: show keyboard, hide keyboard

**Implementation**:
```kotlin
class InputHandler(private val context: Context) : BaseHandler {

  override fun canHandle(category: ActionCategory): Boolean =
    category == ActionCategory.INPUT

  override suspend fun handle(command: StaticCommand): HandlerResult {
    val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager

    return when (command.id) {
      "show_keyboard" -> {
        imm.showSoftInput(null, InputMethodManager.SHOW_IMPLICIT)
        HandlerResult.handled()
      }
      "hide_keyboard" -> {
        imm.hideSoftInputFromWindow(null, 0)
        HandlerResult.handled()
      }
      else -> HandlerResult.notHandled()
    }
  }
}
```

**Technology**: InputMethodManager

#### 2.6 AppControlHandler
**Category**: APP_CONTROL (2 commands)
**Commands**: close app, exit, quit

**Implementation**:
```kotlin
class AppControlHandler : BaseHandler {

  override fun canHandle(category: ActionCategory): Boolean =
    category == ActionCategory.APP_CONTROL

  override suspend fun handle(command: StaticCommand): HandlerResult {
    return when (command.id) {
      "close_app", "exit", "quit" -> {
        AccessibilityService.globalAction(AccessibilityService.GLOBAL_ACTION_BACK)
        HandlerResult.handled()
      }
      else -> HandlerResult.notHandled()
    }
  }
}
```

**Technology**: AccessibilityService.globalAction()

#### 2.7 ReadingHandler
**Category**: ACCESSIBILITY (2 commands)
**Commands**: read screen, stop reading

**Implementation**:
```kotlin
class ReadingHandler(
  private val context: Context,
  private val accessibilityTreeProvider: AccessibilityTreeProvider
) : BaseHandler {

  private val textToSpeech: TextToSpeech = TextToSpeech(context) { }

  override fun canHandle(category: ActionCategory): Boolean =
    category == ActionCategory.ACCESSIBILITY

  override suspend fun handle(command: StaticCommand): HandlerResult {
    return when (command.id) {
      "read_screen" -> {
        val screenText = accessibilityTreeProvider.extractScreenText()
        if (screenText.isNotEmpty()) {
          textToSpeech.speak(screenText, TextToSpeech.QUEUE_FLUSH, null)
          HandlerResult.handled()
        } else {
          HandlerResult.error("No text found on screen")
        }
      }
      "stop_reading" -> {
        textToSpeech.stop()
        HandlerResult.handled()
      }
      else -> HandlerResult.notHandled()
    }
  }
}
```

**Technology**: TextToSpeech + AccessibilityNodeInfo tree traversal

#### 2.8 VoiceControlHandler
**Category**: VOICE_CONTROL (6 commands)
**Commands**: mute voice, wake voice, enable voice, disable voice, dictation, help

**Implementation**:
```kotlin
class VoiceControlHandler : BaseHandler {

  companion object {
    // Static registry for callbacks
    private val voiceControlCallbacks = mutableMapOf<String, VoiceControlCallback>()

    fun registerCallback(key: String, callback: VoiceControlCallback) {
      voiceControlCallbacks[key] = callback
    }

    fun unregisterCallback(key: String) {
      voiceControlCallbacks.remove(key)
    }
  }

  override fun canHandle(category: ActionCategory): Boolean =
    category == ActionCategory.VOICE_CONTROL

  override suspend fun handle(command: StaticCommand): HandlerResult {
    return when (command.id) {
      "mute_voice" -> invokeCallback("onMuteVoice")
      "wake_voice" -> invokeCallback("onWakeVoice")
      "enable_voice" -> invokeCallback("onEnableVoice")
      "disable_voice" -> invokeCallback("onDisableVoice")
      "dictation" -> invokeCallback("onDictationStart")
      "help" -> invokeCallback("onHelpRequested")
      else -> HandlerResult.notHandled()
    }
  }

  private suspend fun invokeCallback(callbackKey: String): HandlerResult {
    val callback = voiceControlCallbacks[callbackKey]
      ?: return HandlerResult.error("Callback not registered: $callbackKey")

    return try {
      callback.invoke()
      HandlerResult.handled()
    } catch (e: Exception) {
      HandlerResult.error("Callback failed: ${e.message}")
    }
  }
}

fun interface VoiceControlCallback {
  suspend fun invoke(): Unit
}
```

**Technology**: Static callback registry pattern (wired by AccessibilityService)

#### 2.9 Handler Registration
Update AndroidHandlerFactory or equivalent:
```kotlin
class AndroidHandlerFactory(context: Context) {
  fun createHandlers(): List<IHandler> = listOf(
    // Existing
    AndroidGestureHandler(context),
    SystemHandler(),
    AppHandler(),
    AndroidCursorHandler(),
    // NEW (Phase 2)
    MediaHandler(context),
    ScreenHandler(context),
    TextHandler(accessibilityNodeInfoProvider),
    InputHandler(context),
    AppControlHandler(),
    ReadingHandler(context, accessibilityTreeProvider),
    VoiceControlHandler()
  )
}
```

### Wave 3: Export/Import Infrastructure

#### 3.1 VosFileExporter
**Purpose**: Serialize VoiceCommandEntity list to VOS v2.1 JSON, register in database

```kotlin
class VosFileExporter(
  private val voiceCommandDao: IVoiceCommandDAO,
  private val vosFileRegistry: IVosFileRegistryRepository
) {

  suspend fun exportCommands(
    locale: String,
    domain: String,  // "app" or "web"
    commands: List<VoiceCommandEntity>
  ): File {
    val fileName = "$locale.$domain.vos"
    val outputFile = File(
      Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS),
      fileName
    )

    val vosJson = mapOf(
      "version" to "2.1",
      "domain" to domain,
      "locale" to locale,
      "generatedAt" to Instant.now().toString(),
      "commands" to commands.map { it.toVosFormat() },
      "category_map" to buildCategoryMap(),
      "action_map" to buildActionMap(),
      "meta_map" to buildMetaMap()
    )

    val jsonString = Json.encodeToString(vosJson)
    outputFile.writeText(jsonString)

    // Register in database
    val contentHash = SHA256.digest(jsonString.toByteArray())
      .toHexString()

    vosFileRegistry.insert(VosFileRegistryDTO(
      fileName = fileName,
      domain = domain,
      locale = locale,
      version = "2.1",
      contentHash = contentHash,
      fileSize = outputFile.length(),
      commandCount = commands.size,
      source = "user_export",
      generatedAt = Instant.now().toString()
    ))

    return outputFile
  }

  private fun buildCategoryMap(): Map<String, Int> = mapOf(
    "NAVIGATION" to 0,
    "MEDIA" to 1,
    "DEVICE" to 2,
    // ... etc
  )

  private fun buildActionMap(): Map<String, Int> = mapOf(
    "navigate_forward" to 0,
    "navigate_back" to 1,
    // ... etc
  )
}
```

#### 3.2 VosFileImporter
**Purpose**: Parse VOS file, deduplicate by content hash, batch-insert into database

```kotlin
class VosFileImporter(
  private val voiceCommandDao: IVoiceCommandDAO,
  private val vosFileRegistry: IVosFileRegistryRepository
) {

  suspend fun importCommands(vosFile: File, locale: String): Result {
    val jsonString = vosFile.readText()
    val contentHash = SHA256.digest(jsonString.toByteArray())
      .toHexString()

    // Check for duplicates
    val existing = vosFileRegistry.getByContentHash(contentHash)
    if (existing != null) {
      return Result.Duplicate("File already imported (hash: $contentHash)")
    }

    val vosData = Json.decodeFromString<VosFileData>(jsonString)

    // Validate version
    if (!vosData.version.startsWith("2.")) {
      return Result.Unsupported("VOS version ${vosData.version} not supported")
    }

    // Parse commands
    val commands = vosData.commands
      .map { it.toVoiceCommandEntity(locale) }
      .toList()

    // Batch insert
    val result = voiceCommandDao.batchInsert(commands)

    // Register in database
    vosFileRegistry.insert(VosFileRegistryDTO(
      fileName = vosFile.name,
      domain = vosData.domain,
      locale = locale,
      version = vosData.version,
      contentHash = contentHash,
      fileSize = vosFile.length(),
      commandCount = commands.size,
      source = "import",
      generatedAt = vosData.generatedAt
    ))

    return Result.Success(commands.size)
  }

  sealed class Result {
    data class Success(val commandCount: Int) : Result()
    data class Duplicate(val message: String) : Result()
    data class Unsupported(val message: String) : Result()
  }
}
```

## Files Created

| File | Location | Description |
|------|----------|-------------|
| VosFileRegistry.sq | Database/src/commonMain/sqldelight/ | SQLDelight table + 16 named queries |
| VosFileRegistryDTO.kt | Database/src/commonMain/kotlin/.../dto/ | DTO + mapping extensions |
| IVosFileRegistryRepository.kt | Database/src/commonMain/kotlin/.../repositories/ | Repository interface |
| SQLDelightVosFileRegistryRepository.kt | Database/src/androidMain/kotlin/.../repositories/ | SQLDelight impl |
| MediaHandler.kt | VoiceOSCore/src/androidMain/kotlin/.../handler/ | Media playback handler |
| ScreenHandler.kt | VoiceOSCore/src/androidMain/kotlin/.../handler/ | Device hardware handler |
| TextHandler.kt | VoiceOSCore/src/androidMain/kotlin/.../handler/ | Text editing handler |
| InputHandler.kt | VoiceOSCore/src/androidMain/kotlin/.../handler/ | Keyboard handler |
| AppControlHandler.kt | VoiceOSCore/src/androidMain/kotlin/.../handler/ | App close/exit handler |
| ReadingHandler.kt | VoiceOSCore/src/androidMain/kotlin/.../handler/ | TTS screen reader |
| VoiceControlHandler.kt | VoiceOSCore/src/androidMain/kotlin/.../handler/ | Voice service control |
| VosFileExporter.kt | VoiceOSCore/src/commonMain/kotlin/.../export/ | VOS file export util |
| VosFileImporter.kt | VoiceOSCore/src/commonMain/kotlin/.../export/ | VOS file import util |
| en-US.app.vos | apps/avanues/src/main/assets/localization/commands/ | App commands (62) |
| en-US.web.vos | apps/avanues/src/main/assets/localization/commands/ | Web commands (45) |
| es-ES.app.vos | apps/avanues/src/main/assets/localization/commands/ | App commands (62) |
| es-ES.web.vos | apps/avanues/src/main/assets/localization/commands/ | Web commands (45) |
| fr-FR.app.vos | apps/avanues/src/main/assets/localization/commands/ | App commands (62) |
| fr-FR.web.vos | apps/avanues/src/main/assets/localization/commands/ | Web commands (45) |
| de-DE.app.vos | apps/avanues/src/main/assets/localization/commands/ | App commands (62) |
| de-DE.web.vos | apps/avanues/src/main/assets/localization/commands/ | Web commands (45) |
| hi-IN.app.vos | apps/avanues/src/main/assets/localization/commands/ | App commands (62) |
| hi-IN.web.vos | apps/avanues/src/main/assets/localization/commands/ | Web commands (45) |

## Files Modified

| File | Change | Impact |
|------|--------|--------|
| CommandLoader.kt | Added `loadAppCommands()`, `loadWebCommands()`, `loadAllCommands()` extension functions | Supports dual-file loading |
| StaticCommand.kt | Added `id: String` field | Enables handler routing by ID |
| StaticCommandRegistry.kt | Updated initialization to set `id` on each command | Populates ID field from database |
| CommandManager.kt | Updated `populateStaticRegistryFromDb()` to extract/set `id` field | Wires ID through command pipeline |
| VoiceOSDatabaseManager.kt | Added `val vosFileRegistry: IVosFileRegistryRepository` lazy property | Exposes registry for import/export |
| AndroidHandlerFactory.kt (or VoiceOSCoreAndroidFactory.kt) | Registered 7 new handlers in `createHandlers()` list | Adds 91 handled commands |

## Files Deleted

| File | Reason |
|------|--------|
| en-US.VOS | Replaced by split en-US.app.vos + en-US.web.vos |
| es-ES.VOS | Replaced by split es-ES.app.vos + es-ES.web.vos |
| fr-FR.VOS | Replaced by split fr-FR.app.vos + fr-FR.web.vos |
| de-DE.VOS | Replaced by split de-DE.app.vos + de-DE.web.vos |
| hi-IN.VOS | Replaced by split hi-IN.app.vos + hi-IN.web.vos |

## Testing Checklist

### Unit Tests
- [ ] MediaHandler: play/pause, volume up/down, mute (mock AudioManager)
- [ ] ScreenHandler: brightness, wifi, bluetooth (mock Settings.System)
- [ ] TextHandler: select/copy/paste on editable node (mock AccessibilityNodeInfo)
- [ ] InputHandler: show/hide keyboard (mock InputMethodManager)
- [ ] AppControlHandler: close app (mock AccessibilityService.globalAction)
- [ ] ReadingHandler: read screen text (mock TextToSpeech, tree provider)
- [ ] VoiceControlHandler: callback invocation (mock static registry)
- [ ] VosFileExporter: JSON serialization, file write, registry insert
- [ ] VosFileImporter: JSON parsing, dedup check, batch insert

### Integration Tests
- [ ] CommandLoader: Load app + web commands separately, then merged
- [ ] StaticCommandRegistry: Initialize from DB with `id` field set
- [ ] AndroidHandlerFactory: All 11 handlers instantiate without error
- [ ] HandlerDispatcher: Route command by category → correct handler
- [ ] Full pipeline: Speak command → CommandManager → StaticCommandRegistry.lookup(id) → handler.handle() → result

### Manual Tests
- [ ] Voice input: "play music" → MediaHandler.play dispatches KEYCODE_MEDIA_PLAY
- [ ] Voice input: "brightness up" → ScreenHandler.adjustBrightness() → Settings.System update
- [ ] Voice input: "copy" on text field → TextHandler.performAction(ACTION_COPY)
- [ ] Voice input: "show keyboard" → InputHandler.showSoftInput()
- [ ] Voice input: "close app" → AppControlHandler dispatch GLOBAL_ACTION_BACK
- [ ] Voice input: "read screen" → ReadingHandler.textToSpeech.speak(screenText)
- [ ] Export: CommandManager.exportCommands(locale, "app") → Downloads/en-US.app.vos, registry entry created
- [ ] Import: VosFileImporter.importCommands(File, locale) → commands inserted, registry entry created, dedup verified

## Compilation Verification

- **Database module**: compileDebugKotlinAndroid ✅
- **VoiceOSCore module**: compileDebugKotlinAndroid ✅
- **Full app**: assembleDebug ✅

## VOS File Split Summary

| Locale | .app.vos Commands | .web.vos Commands | Total |
|--------|-------------------|-------------------|-------|
| en-US | 62 (nav, media, sys, voice, app, acc, text, input, appctl) | 45 (browser, gesture) | 107 |
| es-ES | 62 | 45 | 107 |
| fr-FR | 62 | 45 | 107 |
| de-DE | 62 | 45 | 107 |
| hi-IN | 62 | 45 | 107 |

## Branch & Commits

**Branch**: `VoiceOSCore-KotlinUpdate`

**Key Commits** (sequential):
1. `feat(voiceoscore): VOS file split into app/web domains`
2. `feat(database): Add vos_file_registry table + repository`
3. `feat(voiceoscore): Add 7 new handlers (Media, Screen, Text, Input, AppControl, Reading, VoiceControl)`
4. `feat(voiceoscore): Wire handler registration in AndroidHandlerFactory`
5. `feat(voiceoscore): Add VosFileExporter and VosFileImporter`

## Next Steps (Phase B - Future Session)

### Distribution via Cloud Sync
1. **FTP/S3 Sync Manager**: VosSyncManager + VosFtpClient for cloud upload
2. **Manifest File**: manifest.json tracks versions, hashes, generation dates
3. **Background Sync**: WorkManager periodic task (daily) checks for new .web.vos files
4. **On-Demand Download**: User triggers manual sync from Settings → Downloads .web.vos for unscraped websites

### Voice Control Callbacks Integration
1. **Wiring**: VoiceControlCallbacks.registerCallback() called in VoiceAvanueAccessibilityService.onServiceReady()
2. **Callbacks**:
   - `onMuteVoice`: Disable recognizer, show "Voice Muted" toast
   - `onWakeVoice`: Enable recognizer, show "Voice Ready" toast
   - `onEnableVoice`: Full voice system ON
   - `onDisableVoice`: Full voice system OFF
   - `onDictationStart`: Open dictation input (via system InputMethod)
   - `onHelpRequested`: Show help dialog with all available commands

## Related Documentation

- **4-Tier Voice Enablement**: docs/analysis/VoiceOSCore/VoiceOSCore-Analysis-4TierVoiceEnablement-260211-V1.md
- **Multi-Locale Support**: docs/fixes/VoiceOSCore/VoiceOSCore-Fix-MultiLocaleVOSSupport-260211-V1.md
- **DB-Driven Commands Phase 2**: docs/fixes/VoiceOSCore/VoiceOSCore-Fix-Phase2DBDrivenCommands-260211-V1.md
- **Developer Manual Chapter 93**: Docs/MasterDocs/NewAvanues-Developer-Manual/Developer-Manual-Chapter93-VoiceCommandPipeline.md

## Implementation Notes

### Why VOS v2.1 (not inline extension)?
- **v2.0 → v2.1**: Adds `domain` field, enables single-file ID mapping for both app+web
- **Not inlined into existing tables**: Keeps schema focused on runtime data, registry tracks *file-level* metadata
- **SHA-256 content hash**: Enables exact duplicate detection, cloud sync reconciliation

### Why Split Domain?
- **App commands**: User-facing, translated per locale, rarely change, shipped in APK
- **Web commands**: Universal (same phrases across all locales), scraped from websites, synced from cloud
- **Separate files**: Allows independent versioning, localization, and distribution

### Why 7 Handlers Instead of 1?
- **Separation of concerns**: Each handler owns its action category
- **Testability**: Mock specific dependencies per handler
- **Extensibility**: New handler + register in factory = new category
- **Failure isolation**: One handler crash doesn't stop others

### Why Static Callback Registry in VoiceControlHandler?
- **No circular dependency**: VoiceAvanueAccessibilityService can register without importing handler package
- **Decoupled**: Service doesn't know handler implementation, handler doesn't know service
- **Runtime binding**: Callbacks registered after service ready, unregistered on shutdown
- **Typed interface**: `VoiceControlCallback` is single-method, type-safe

## Known Limitations & Future Work

1. **Phase B**: FTP/S3 cloud sync not yet implemented (export/import local only)
2. **No auto-migration**: Old .VOS v1.0 files must be manually re-created as v2.1 (CommandLoader doesn't auto-convert)
3. **No compression**: VOS files stored as raw JSON (gzip in Phase B)
4. **ReadingHandler**: Requires full accessibility tree extraction (battery impact on large screens)
5. **ScreenHandler brightness**: May require SYSTEM_ALERT_WINDOW permission on Android 10+

---

**Document Version**: V1
**Date**: 2026-02-11
**Status**: Implementation ready
**Branch**: VoiceOSCore-KotlinUpdate
