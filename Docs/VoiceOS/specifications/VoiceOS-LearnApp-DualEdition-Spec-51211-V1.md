# LearnApp Dual-Edition System Specification

**Schema**: `avu-1.0`
**Version**: `2.0.0`
**Author**: Manoj Jhawar
**Created**: 2025-12-11
**Status**: Draft

---

## 1. Executive Summary

LearnApp is a dual-edition system for automated and developer-assisted app exploration:
- **User Edition**: Automated exploration with minimal intervention
- **Developer Edition**: Full debugging tools with Neo4j graph database

**Core Architecture**: JIT-as-Scraper pattern - VoiceOSCore AccessibilityService streams events to LearnApp coordinator via AIDL.

---

## 2. Architecture Overview

### 2.1 Module Structure

```
LearnAppCore (shared library)
├── Core business logic
├── Element processing
├── AVU format serialization
├── Safety systems (Do Not Click, Loop Detection)
└── Database abstraction

LearnApp User Edition (app)
├── Automated exploration engine
├── SQLDelight hybrid storage (in-memory + persistent)
├── Progress notification + floating overlay
└── AVU export (encrypted JSON)

LearnApp Developer Edition (app)
├── Manual intervention tools
├── Neo4j embedded graph database
├── Live element inspector
├── Screen diff viewer
├── Command test harness
└── AVU export (unencrypted + decryption tool)
```

### 2.2 JIT-as-Scraper Architecture

```
VoiceOSCore Process                    LearnApp Process
─────────────────                      ────────────────
VoiceOSService                         LearnAppActivity
    │ AccessibilityService                   │
    ▼                                        │
JITLearningService ◄───── AIDL ─────────────┘
    │                   Event Streaming
    ▼
IAccessibilityEventListener.onScreenChanged()
IAccessibilityEventListener.onElementAction()
```

**Mutual Exclusion**: JIT passive learning OR LearnApp exploration (never both)

---

## 3. AIDL Interface Extension (IPC Format)

### 3.1 Extended IElementCaptureService.aidl

```aidl
package com.augmentalis.jitlearning;

import com.augmentalis.jitlearning.JITState;
import com.augmentalis.jitlearning.IAccessibilityEventListener;
import com.augmentalis.jitlearning.ParcelableNodeInfo;
import com.augmentalis.jitlearning.ExplorationCommand;

interface IElementCaptureService {
    // Existing methods
    void pauseCapture();
    void resumeCapture();
    JITState queryState();
    List<String> getLearnedScreenHashes(in String packageName);

    // NEW: Event streaming (IPC format)
    void registerEventListener(IAccessibilityEventListener listener);
    void unregisterEventListener(IAccessibilityEventListener listener);

    // NEW: Screen/element queries
    ParcelableNodeInfo getCurrentScreenInfo();
    ParcelableNodeInfo getFullMenuContent(in String menuNodeId);
    List<ParcelableNodeInfo> queryElements(in String selector);

    // NEW: Exploration commands
    void performClick(in String elementUuid);
    void performScroll(in String direction, int distance);
    void performAction(in ExplorationCommand command);
}
```

### 3.2 IAccessibilityEventListener.aidl (NEW)

```aidl
package com.augmentalis.jitlearning;

import com.augmentalis.jitlearning.ParcelableNodeInfo;
import com.augmentalis.jitlearning.ScreenChangeEvent;

/**
 * Event callback interface using IPC-compatible format
 * Events serialized as: CODE:field1:field2:field3
 */
interface IAccessibilityEventListener {
    // SCH:hash:activity:timestamp:element_count
    void onScreenChanged(in ScreenChangeEvent event);

    // ELA:uuid:action_type:result:timestamp
    void onElementAction(in String elementUuid, in String actionType, boolean success);

    // SCR:direction:distance:new_elements_count
    void onScrollDetected(in String direction, int distance, int newElements);

    // DYN:screen_hash:region_id:change_type
    void onDynamicContentDetected(in String screenHash, in String regionId);

    // MNU:menu_id:total_items:visible_items
    void onMenuDiscovered(in String menuId, int totalItems, int visibleItems);

    // LGN:package:screen_hash:login_type
    void onLoginScreenDetected(in String packageName, in String screenHash);
}
```

---

## 4. AVU Export Format (Compact)

### 4.1 File Structure

```
# Avanues Universal Format v1.0
# Type: VOS
# Extension: .vos
# Generated by: LearnApp v2.0
---
schema: avu-1.0
version: 1.0.0
locale: en-US
project: voiceos
metadata:
  file: com.microsoft.teams.vos
  category: learned_app
  count: 87
  exploration_mode: automated|developer
  duration_s: 245
  timestamp: 1733931600
---
APP:com.microsoft.teams:Microsoft Teams:1733931600
STA:12:87:43:3.5:4:85.2
SCR:abc123:CallsActivity:1733931600:15
ELM:btn-001:Calls:android.widget.BottomNavigationItemView:click:0,1800,270,1920:NAV
ELM:btn-002:Chat:android.widget.BottomNavigationItemView:click:270,1800,540,1920:NAV
ELM:btn-003:Search:android.widget.EditText:click+edit:100,100,980,180:INP
ELM:txt-004:Mike Johnson:android.widget.TextView:click:0,300,800,400:CNT
SCR:def456:ChatActivity:1733931610:22
NAV:abc123:def456:btn-002:Chat:1733931605
DNC:btn-end:End Call:android.widget.Button:CALL_END
DNC:btn-post:Post:android.widget.Button:CREATE_CONTENT
DYN:abc123:feed_region:INFINITE_SCROLL
MNU:more_menu:15:5:OVERFLOW
CNT:cnt-001:Mike Johnson:mike@company.com:+1555123456:Teams
---
synonyms:
  calls: [phone, dial, ring]
  chat: [message, text, dm]
  search: [find, look for, locate]
```

### 4.2 IPC Codes for LearnApp

| Code | Meaning | Format | Purpose |
|------|---------|--------|---------|
| `APP` | App Metadata | `package:name:learned_at` | App identification |
| `STA` | Statistics | `screens:elements:commands:avg_depth:max_depth:coverage` | Learning stats |
| `SCR` | Screen Definition | `hash:activity:timestamp:element_count` | Screen identification |
| `ELM` | Element Definition | `uuid:label:type:actions:bounds:category` | UI element data |
| `NAV` | Navigation Path | `from_hash:to_hash:trigger_uuid:trigger_label:timestamp` | Screen transitions |
| `DNC` | Do Not Click | `element_id:label:type:reason` | Excluded elements |
| `DYN` | Dynamic Region | `screen_hash:region_id:change_type` | Dynamic content markers |
| `MNU` | Menu Definition | `menu_id:total_items:visible_items:menu_type` | Expandable menus |
| `CNT` | Contact | `contact_id:name:email:phone:source_app` | Extracted contacts |
| `CMD` | Generated Command | `uuid:trigger:action:element_uuid:confidence` | Voice command |
| `SYN` | Synonym Set | `word:syn1+syn2+syn3` | Command synonyms |

### 4.3 Element Categories

| Category | Code | Examples |
|----------|------|----------|
| Navigation | `NAV` | Bottom nav, tabs, back buttons |
| Action | `ACT` | Submit, save, confirm buttons |
| Input | `INP` | Text fields, search boxes |
| Display | `DSP` | Labels, images, status text |
| Contact | `CNT` | Contact list items |
| Menu | `MNU` | Overflow menus, dropdowns |
| Dangerous | `DNG` | Excluded via Do Not Click |

---

## 5. Safety Systems

### 5.1 Do Not Click List

**Purpose**: Prevent destructive actions during exploration

```kotlin
object DoNotClickList {
    // Category: CALL_ACTIONS
    val CALL_KEYWORDS = setOf(
        "call", "dial", "ring", "phone",
        "end call", "hang up", "decline",
        "answer", "accept call"
    )

    // Category: CONTENT_CREATION
    val POST_KEYWORDS = setOf(
        "post", "publish", "send", "submit",
        "share", "tweet", "comment", "reply",
        "create", "new post", "upload"
    )

    // Category: EXIT_ACTIONS
    val EXIT_KEYWORDS = setOf(
        "exit", "quit", "close", "end",
        "leave", "sign out", "log out",
        "delete", "remove", "cancel"
    )

    // Category: AUTH_ACTIONS
    val AUTH_KEYWORDS = setOf(
        "login", "log in", "sign in",
        "password", "username", "email",
        "forgot password", "reset", "otp"
    )

    // Category: PAYMENT_ACTIONS
    val PAYMENT_KEYWORDS = setOf(
        "pay", "purchase", "buy", "checkout",
        "subscribe", "upgrade", "premium",
        "credit card", "billing"
    )

    // Resource ID patterns (regex)
    val DANGEROUS_RESOURCE_IDS = listOf(
        Regex(".*end_call.*", RegexOption.IGNORE_CASE),
        Regex(".*btn_post.*", RegexOption.IGNORE_CASE),
        Regex(".*btn_send.*", RegexOption.IGNORE_CASE),
        Regex(".*delete.*", RegexOption.IGNORE_CASE),
        Regex(".*logout.*", RegexOption.IGNORE_CASE),
        Regex(".*payment.*", RegexOption.IGNORE_CASE)
    )

    fun shouldNotClick(element: ElementInfo): DoNotClickReason? {
        val label = element.label.lowercase()
        val resourceId = element.resourceId.lowercase()

        return when {
            CALL_KEYWORDS.any { label.contains(it) } -> DoNotClickReason.CALL_ACTION
            POST_KEYWORDS.any { label.contains(it) } -> DoNotClickReason.CONTENT_CREATION
            EXIT_KEYWORDS.any { label.contains(it) } -> DoNotClickReason.EXIT_ACTION
            AUTH_KEYWORDS.any { label.contains(it) } -> DoNotClickReason.AUTH_ACTION
            PAYMENT_KEYWORDS.any { label.contains(it) } -> DoNotClickReason.PAYMENT_ACTION
            DANGEROUS_RESOURCE_IDS.any { it.matches(resourceId) } -> DoNotClickReason.DANGEROUS_ID
            else -> null
        }
    }
}

enum class DoNotClickReason {
    CALL_ACTION,      // Could initiate/end calls
    CONTENT_CREATION, // Could create posts/messages
    EXIT_ACTION,      // Could close app/session
    AUTH_ACTION,      // Could expose credentials
    PAYMENT_ACTION,   // Could trigger purchases
    DANGEROUS_ID      // Matched dangerous resource ID pattern
}
```

### 5.2 Dynamic Content Detection

**Purpose**: Avoid infinite loops on changing content

```kotlin
object DynamicContentDetector {

    // Indicators of dynamic content regions
    val DYNAMIC_INDICATORS = listOf(
        "RecyclerView",      // Scrolling lists
        "ListView",          // Legacy lists
        "ViewPager",         // Swipeable content
        "feed",              // Social feeds
        "timeline",          // Activity streams
        "notification",      // Notification lists
        "message_list",      // Chat messages
        "post_container"     // Social posts
    )

    // Content change detection
    data class ContentFingerprint(
        val elementCount: Int,
        val textHash: Int,
        val structureHash: Int
    )

    private val screenFingerprints = mutableMapOf<String, ContentFingerprint>()
    private val changeCount = mutableMapOf<String, Int>()

    fun detectDynamicRegion(
        screenHash: String,
        node: AccessibilityNodeInfo
    ): DynamicRegion? {
        val nodeId = node.viewIdResourceName ?: return null

        // Check if node matches dynamic indicators
        val isDynamicContainer = DYNAMIC_INDICATORS.any {
            node.className?.contains(it, ignoreCase = true) == true ||
            nodeId.contains(it, ignoreCase = true)
        }

        if (!isDynamicContainer) return null

        // Calculate content fingerprint
        val fingerprint = calculateFingerprint(node)
        val key = "$screenHash:$nodeId"

        // Compare with previous fingerprint
        val previousFingerprint = screenFingerprints[key]
        if (previousFingerprint != null && previousFingerprint != fingerprint) {
            val count = changeCount.getOrDefault(key, 0) + 1
            changeCount[key] = count

            // Mark as dynamic if changed 3+ times
            if (count >= 3) {
                return DynamicRegion(
                    screenHash = screenHash,
                    regionId = nodeId,
                    changeType = classifyChangeType(previousFingerprint, fingerprint)
                )
            }
        }

        screenFingerprints[key] = fingerprint
        return null
    }

    private fun classifyChangeType(
        old: ContentFingerprint,
        new: ContentFingerprint
    ): DynamicChangeType {
        return when {
            new.elementCount > old.elementCount * 2 -> DynamicChangeType.INFINITE_SCROLL
            old.textHash != new.textHash -> DynamicChangeType.CONTENT_REFRESH
            old.structureHash != new.structureHash -> DynamicChangeType.LAYOUT_CHANGE
            else -> DynamicChangeType.UNKNOWN
        }
    }
}

enum class DynamicChangeType {
    INFINITE_SCROLL,   // Feed-like content that keeps loading
    CONTENT_REFRESH,   // Same structure, different content (e.g., notifications)
    LAYOUT_CHANGE,     // Structure changes (e.g., ads injected)
    UNKNOWN
}

data class DynamicRegion(
    val screenHash: String,
    val regionId: String,
    val changeType: DynamicChangeType
)
```

### 5.3 Menu Discovery (Full Query)

**Purpose**: Discover complete menu contents without rescanning visible items

```kotlin
object MenuDiscovery {

    /**
     * Query full menu content, not just visible items
     * Handles: Overflow menus, dropdown menus, sliding drawers
     */
    suspend fun discoverFullMenu(
        menuNode: AccessibilityNodeInfo,
        jitService: IElementCaptureService
    ): MenuContent {
        val menuId = menuNode.viewIdResourceName ?: generateMenuId(menuNode)
        val visibleItems = extractVisibleMenuItems(menuNode)

        // Check if menu is scrollable
        val isScrollable = menuNode.isScrollable ||
            menuNode.actionList.contains(AccessibilityAction.ACTION_SCROLL_FORWARD)

        if (!isScrollable) {
            // Static menu - return visible items
            return MenuContent(
                menuId = menuId,
                items = visibleItems,
                totalItems = visibleItems.size,
                menuType = MenuType.STATIC
            )
        }

        // Scrollable menu - discover all items
        val allItems = mutableSetOf<MenuItem>()
        allItems.addAll(visibleItems)

        var scrollAttempts = 0
        val maxScrollAttempts = 20
        var lastItemCount = 0

        while (scrollAttempts < maxScrollAttempts) {
            // Request full menu content via AIDL
            val fullContent = jitService.getFullMenuContent(menuId)
            if (fullContent != null) {
                // Service returned full menu - use it
                return parseMenuFromParcelable(fullContent)
            }

            // Fallback: Scroll and collect
            jitService.performScroll("down", 300)
            delay(200) // Wait for content load

            val newVisibleItems = extractVisibleMenuItems(menuNode)
            allItems.addAll(newVisibleItems)

            // Check if we've reached the end
            if (allItems.size == lastItemCount) {
                scrollAttempts++
            } else {
                scrollAttempts = 0
                lastItemCount = allItems.size
            }
        }

        // Scroll back to top
        repeat(maxScrollAttempts) {
            jitService.performScroll("up", 300)
            delay(100)
        }

        return MenuContent(
            menuId = menuId,
            items = allItems.toList(),
            totalItems = allItems.size,
            menuType = MenuType.SCROLLABLE
        )
    }
}

data class MenuContent(
    val menuId: String,
    val items: List<MenuItem>,
    val totalItems: Int,
    val menuType: MenuType
)

data class MenuItem(
    val uuid: String,
    val label: String,
    val icon: String?,
    val isEnabled: Boolean,
    val hasSubmenu: Boolean
)

enum class MenuType {
    STATIC,       // Fixed items, no scrolling
    SCROLLABLE,   // Scrollable list
    OVERFLOW,     // "More" menu
    DRAWER,       // Navigation drawer
    DROPDOWN      // Dropdown/spinner
}
```

### 5.4 Login Screen Handling

**Purpose**: Detect login screens, prompt user, never capture credentials

```kotlin
object LoginScreenDetector {

    val LOGIN_INDICATORS = listOf(
        // Screen titles
        "sign in", "log in", "login", "welcome",
        "authentication", "verify", "enter password",

        // Input field hints
        "email", "username", "phone number",
        "password", "pin", "otp", "verification code",

        // Button labels
        "sign in", "log in", "continue", "next",
        "forgot password", "create account", "register"
    )

    val LOGIN_RESOURCE_ID_PATTERNS = listOf(
        Regex(".*login.*", RegexOption.IGNORE_CASE),
        Regex(".*signin.*", RegexOption.IGNORE_CASE),
        Regex(".*password.*", RegexOption.IGNORE_CASE),
        Regex(".*username.*", RegexOption.IGNORE_CASE),
        Regex(".*email_input.*", RegexOption.IGNORE_CASE),
        Regex(".*otp.*", RegexOption.IGNORE_CASE)
    )

    fun isLoginScreen(rootNode: AccessibilityNodeInfo): LoginScreenInfo? {
        var loginScore = 0
        var hasPasswordField = false
        var hasUsernameField = false
        var hasLoginButton = false

        traverseTree(rootNode) { node ->
            val text = (node.text?.toString() ?: "").lowercase()
            val hint = (node.hintText?.toString() ?: "").lowercase()
            val resourceId = (node.viewIdResourceName ?: "").lowercase()
            val className = node.className?.toString() ?: ""

            // Check for password field (most reliable indicator)
            if (className.contains("EditText") && node.isPassword) {
                hasPasswordField = true
                loginScore += 30
            }

            // Check for username/email field
            if (className.contains("EditText") &&
                (hint.contains("email") || hint.contains("username") ||
                 hint.contains("phone"))) {
                hasUsernameField = true
                loginScore += 20
            }

            // Check for login button
            if ((className.contains("Button") || node.isClickable) &&
                LOGIN_INDICATORS.any { text.contains(it) }) {
                hasLoginButton = true
                loginScore += 15
            }

            // Check resource IDs
            if (LOGIN_RESOURCE_ID_PATTERNS.any { it.matches(resourceId) }) {
                loginScore += 10
            }

            // Check text content
            if (LOGIN_INDICATORS.any { text.contains(it) || hint.contains(it) }) {
                loginScore += 5
            }
        }

        // Login screen if score >= 40
        return if (loginScore >= 40) {
            LoginScreenInfo(
                packageName = rootNode.packageName?.toString() ?: "",
                screenHash = calculateScreenHash(rootNode),
                loginType = classifyLoginType(hasPasswordField, hasUsernameField),
                confidence = minOf(loginScore, 100) / 100f
            )
        } else null
    }

    private fun classifyLoginType(
        hasPassword: Boolean,
        hasUsername: Boolean
    ): LoginType {
        return when {
            hasPassword && hasUsername -> LoginType.STANDARD
            hasPassword -> LoginType.PASSWORD_ONLY
            hasUsername -> LoginType.SSO_OR_MAGIC_LINK
            else -> LoginType.UNKNOWN
        }
    }
}

data class LoginScreenInfo(
    val packageName: String,
    val screenHash: String,
    val loginType: LoginType,
    val confidence: Float
)

enum class LoginType {
    STANDARD,           // Username + Password
    PASSWORD_ONLY,      // Password for existing account
    SSO_OR_MAGIC_LINK,  // Email/phone only (no password visible)
    TWO_FACTOR,         // OTP/2FA screen
    UNKNOWN
}
```

---

## 6. Contact Extraction (Future Feature)

### 6.1 Contact Screen Detection

```kotlin
object ContactScreenDetector {

    fun isContactListScreen(rootNode: AccessibilityNodeInfo): Boolean {
        // Check for RecyclerView/ListView with person-like items
        // Look for avatar images + text patterns
        // Detect "Contact", "People", "Calls" in screen title
        // Check for phone/email patterns in child nodes

        var hasContactList = false
        var hasPersonItems = false
        var hasContactTitle = false

        traverseTree(rootNode) { node ->
            val className = node.className?.toString() ?: ""
            val text = (node.text?.toString() ?: "").lowercase()
            val resourceId = (node.viewIdResourceName ?: "").lowercase()

            // Check for list containers
            if (className.contains("RecyclerView") || className.contains("ListView")) {
                if (resourceId.contains("contact") || resourceId.contains("people")) {
                    hasContactList = true
                }
            }

            // Check for contact title
            if (text.contains("contact") || text.contains("people") ||
                text.contains("calls")) {
                hasContactTitle = true
            }

            // Check for person-like patterns
            if (text.matches(Regex("^[A-Z][a-z]+ [A-Z][a-z]+$")) || // "John Smith"
                text.matches(Regex(".*@.*\\..*")) ||                  // Email
                text.matches(Regex("\\+?[0-9\\s\\-()]{10,}"))) {      // Phone
                hasPersonItems = true
            }
        }

        return hasContactList && (hasPersonItems || hasContactTitle)
    }
}
```

### 6.2 Contact Data Model

```kotlin
data class ExtractedContact(
    val contactId: String,           // UUID
    val name: String,                // Display name
    val normalizedName: String,      // For deduplication
    val email: String?,
    val phone: String?,
    val sourceApp: String,           // Package name
    val sourceScreenHash: String,
    val extractedAt: Long,
    val metadata: Map<String, String> // App-specific data
)

// AVU format: CNT:contact_id:name:email:phone:source_app
fun ExtractedContact.toAVU(): String {
    return "CNT:$contactId:$name:${email ?: ""}:${phone ?: ""}:$sourceApp"
}
```

### 6.3 MS Teams Specific Detection

```kotlin
object TeamsContactDetector {
    const val TEAMS_PACKAGE = "com.microsoft.teams"

    // Teams-specific activity names
    val CONTACT_ACTIVITIES = listOf(
        "CallsActivity",
        "PeopleActivity",
        "ContactsActivity"
    )

    // Teams-specific resource IDs
    val CONTACT_LIST_IDS = listOf(
        "contact_list",
        "people_recycler_view",
        "speed_dial_list"
    )

    fun isTeamsContactScreen(
        packageName: String,
        activityName: String,
        rootNode: AccessibilityNodeInfo
    ): Boolean {
        if (packageName != TEAMS_PACKAGE) return false

        // Check activity name
        if (CONTACT_ACTIVITIES.any { activityName.contains(it) }) {
            return true
        }

        // Check for Teams-specific resource IDs
        var foundContactList = false
        traverseTree(rootNode) { node ->
            val resourceId = node.viewIdResourceName ?: ""
            if (CONTACT_LIST_IDS.any { resourceId.contains(it) }) {
                foundContactList = true
            }
        }

        return foundContactList
    }
}
```

---

## 7. Database Schema Mapping

### 7.1 Generated Commands Mapping

LearnApp output maps directly to `commands_generated` table:

| AVU Field | DB Column | Notes |
|-----------|-----------|-------|
| `CMD:uuid` | `elementHash` | Element UUID |
| `CMD:trigger` | `commandText` | Voice trigger phrase |
| `CMD:action` | `actionType` | click, edit, scroll, etc. |
| `CMD:confidence` | `confidence` | 0.0-1.0 |
| `SYN:word:syns` | `synonyms` | JSON array |
| - | `isUserApproved` | Default 0 |
| - | `usageCount` | Default 0 |
| - | `createdAt` | Extraction timestamp |

### 7.2 External Folder Ingestion (NEW)

**Feature**: Auto-import .vos files from external folder

```kotlin
object ExternalFolderIngestion {

    // Default external folder path
    val EXTERNAL_IMPORT_PATH = "/storage/emulated/0/VoiceOS/import/"

    /**
     * Watch external folder for new .vos files
     * Auto-ingest when detected
     */
    class ExternalFolderWatcher(
        private val context: Context,
        private val database: VoiceOSDatabaseManager
    ) {
        private val fileObserver: FileObserver

        init {
            // Create folder if not exists
            File(EXTERNAL_IMPORT_PATH).mkdirs()

            // Watch for new files
            fileObserver = object : FileObserver(EXTERNAL_IMPORT_PATH, CREATE or MOVED_TO) {
                override fun onEvent(event: Int, path: String?) {
                    if (path?.endsWith(".vos") == true) {
                        CoroutineScope(Dispatchers.IO).launch {
                            ingestFile(File(EXTERNAL_IMPORT_PATH, path))
                        }
                    }
                }
            }
        }

        fun startWatching() = fileObserver.startWatching()
        fun stopWatching() = fileObserver.stopWatching()

        suspend fun ingestFile(file: File): IngestionResult {
            return try {
                val content = file.readText()
                val parsed = AVUParser.parse(content)

                // Extract commands and insert to database
                val commands = parsed.getCommands()
                var inserted = 0

                commands.forEach { cmd ->
                    database.generatedCommandRepository.insertIfNotExists(
                        elementHash = cmd.uuid,
                        commandText = cmd.trigger,
                        actionType = cmd.action,
                        confidence = cmd.confidence,
                        synonyms = cmd.synonyms?.joinToString(","),
                        isUserApproved = 0,
                        usageCount = 0,
                        lastUsed = null,
                        createdAt = System.currentTimeMillis()
                    )
                    inserted++
                }

                // Move file to processed folder
                val processedDir = File(EXTERNAL_IMPORT_PATH, "processed")
                processedDir.mkdirs()
                file.renameTo(File(processedDir, file.name))

                IngestionResult(
                    success = true,
                    commandsLoaded = inserted,
                    source = "external:${file.name}"
                )
            } catch (e: Exception) {
                IngestionResult(
                    success = false,
                    commandsLoaded = 0,
                    errors = listOf(e.message ?: "Unknown error"),
                    source = "external:${file.name}"
                )
            }
        }
    }
}
```

---

## 8. NLU Integration

### 8.1 AVU Quantization

LearnApp output integrates with existing `AVUQuantizer` for NLU:

```kotlin
// From: learnapp/ai/quantized/AVUQuantizer.kt

/**
 * Quantize LearnApp output for NLU consumption
 * Reduces token count while preserving semantic meaning
 */
object AVUQuantizer {

    /**
     * Convert AVU file to quantized format (.vosq)
     * Size reduction: 60-80%
     */
    fun quantize(avuContent: String): QuantizedContext {
        val parsed = AVUParser.parse(avuContent)

        return QuantizedContext(
            appId = parsed.getApp().packageName,
            screens = parsed.getScreens().map { screen ->
                QuantizedScreen(
                    id = screen.hash.take(8), // Truncate hash
                    name = inferScreenName(screen),
                    elements = screen.elements.map { elem ->
                        QuantizedElement(
                            id = elem.uuid.take(8),
                            label = elem.label,
                            category = elem.category,
                            actions = elem.actions.joinToString("+")
                        )
                    }
                )
            },
            transitions = parsed.getNavigations().map { nav ->
                QuantizedTransition(
                    from = nav.fromHash.take(8),
                    to = nav.toHash.take(8),
                    trigger = nav.triggerLabel
                )
            }
        )
    }
}
```

### 8.2 LLM Prompt Formats

Three formats for different NLU contexts:

**Compact (~50-100 tokens)**:
```
App:Teams|Screens:Login,Calls,Chat|Nav:Login>Calls(click Calls)|Elements:Calls[NAV],Search[INP]
```

**HTML-like (~200 tokens)**:
```html
<app name="Teams">
  <screen id="Calls">
    <nav label="Calls" action="click"/>
    <input label="Search" action="edit"/>
    <contact name="Mike" action="click"/>
  </screen>
</app>
```

**Full (~500+ tokens)**:
```
Application: Microsoft Teams (com.microsoft.teams)
Learned Screens: 12
Generated Commands: 43

Screen: CallsActivity (hash: abc123)
- Element: Calls (Navigation) - Actions: click
- Element: Search (Input) - Actions: click, edit
- Element: Mike Johnson (Contact) - Actions: click

Navigation: Login -> Calls (trigger: "click Calls tab")
```

---

## 9. Developer Tools

### 9.1 Activation Methods

**All 4 methods implemented**:

1. **Tap Sequence**: Tap app version 7x (like Android Developer Options)
2. **Build Variant**: `assembleDevDebug` vs `assembleUserDebug`
3. **Secret Code**: Long-press settings icon 5 seconds
4. **Remote Flag**: Check `https://api.augmentalis.com/v1/dev-mode/{device_id}` (coded but inactive)

### 9.2 Live Element Inspector

```kotlin
class LiveElementInspector {

    /**
     * Pause exploration and inspect current element
     * Shows: All properties, hierarchy path, selector suggestions
     */
    fun inspect(element: ParcelableNodeInfo): InspectionResult {
        return InspectionResult(
            // Basic properties
            className = element.className,
            text = element.text,
            contentDescription = element.contentDescription,
            resourceId = element.resourceId,
            bounds = element.bounds,

            // State
            isClickable = element.isClickable,
            isEnabled = element.isEnabled,
            isVisible = element.isVisibleToUser,
            isFocused = element.isFocused,

            // Hierarchy
            hierarchyPath = buildHierarchyPath(element),
            depth = calculateDepth(element),
            childCount = element.childCount,

            // Selectors (suggested ways to find this element)
            selectors = listOf(
                "resourceId:${element.resourceId}",
                "text:${element.text}",
                "contentDescription:${element.contentDescription}",
                "className:${element.className}[${element.indexInParent}]"
            ).filter { !it.endsWith(":") && !it.endsWith(":null") },

            // Safety
            doNotClickReason = DoNotClickList.shouldNotClick(element),
            isDynamicRegion = DynamicContentDetector.isInDynamicRegion(element)
        )
    }
}
```

### 9.3 Manual Click Injection

```kotlin
class ManualClickInjection {

    /**
     * Developer taps element in LearnApp screenshot
     * Action replayed in target app via accessibility
     */
    suspend fun injectClick(
        screenshot: Bitmap,
        tapX: Float,
        tapY: Float,
        jitService: IElementCaptureService
    ): ClickResult {
        // Get current screen info
        val screenInfo = jitService.getCurrentScreenInfo()

        // Find element at tap coordinates
        val element = findElementAtCoordinates(screenInfo, tapX, tapY)
            ?: return ClickResult.NotFound

        // Check safety
        val doNotClickReason = DoNotClickList.shouldNotClick(element)
        if (doNotClickReason != null) {
            return ClickResult.Blocked(doNotClickReason)
        }

        // Perform click via AIDL
        jitService.performClick(element.uuid)

        return ClickResult.Success(element)
    }
}
```

### 9.4 Command Test Harness

```kotlin
class CommandTestHarness {

    /**
     * Validate command works before saving
     * Runs 3x by default, reports success rate
     */
    suspend fun testCommand(
        command: GeneratedCommand,
        jitService: IElementCaptureService,
        iterations: Int = 3
    ): TestResult {
        val results = mutableListOf<SingleTestResult>()

        repeat(iterations) { i ->
            // Navigate to screen containing element
            val navigated = navigateToScreen(command.screenHash, jitService)
            if (!navigated) {
                results.add(SingleTestResult(false, "Navigation failed"))
                return@repeat
            }

            // Find element
            val element = jitService.queryElements("uuid:${command.elementUuid}")
                .firstOrNull()
            if (element == null) {
                results.add(SingleTestResult(false, "Element not found"))
                return@repeat
            }

            // Perform action
            val success = when (command.actionType) {
                "click" -> jitService.performClick(command.elementUuid)
                else -> false
            }

            results.add(SingleTestResult(success, if (success) "OK" else "Action failed"))

            // Wait and go back for next iteration
            delay(1000)
            jitService.performAction(ExplorationCommand.Back)
        }

        val successRate = results.count { it.success } / results.size.toFloat()

        return TestResult(
            command = command,
            iterations = iterations,
            successRate = successRate,
            results = results,
            recommendation = when {
                successRate >= 0.9 -> TestRecommendation.SAVE
                successRate >= 0.5 -> TestRecommendation.REVIEW
                else -> TestRecommendation.DISCARD
            }
        )
    }
}
```

---

## 10. Export Formats

### 10.1 User Edition Export

**Encrypted AVU JSON**:
```kotlin
object EncryptedAVUExport {

    private const val ENCRYPTION_ALGORITHM = "AES/GCM/NoPadding"
    private const val KEY_SIZE = 256

    fun export(
        avuContent: String,
        outputPath: String,
        password: String
    ): File {
        // Generate key from password
        val salt = generateSalt()
        val key = deriveKey(password, salt)

        // Encrypt content
        val cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM)
        val iv = generateIV()
        cipher.init(Cipher.ENCRYPT_MODE, key, GCMParameterSpec(128, iv))
        val encrypted = cipher.doFinal(avuContent.toByteArray())

        // Write to file with header
        val output = File(outputPath)
        output.writeBytes(
            byteArrayOf(0xAV.toByte(), 0xU1.toByte()) + // Magic bytes
            salt + iv + encrypted
        )

        return output
    }
}
```

### 10.2 Developer Edition Export

**Unencrypted AVU + Decryption Tool**:
```kotlin
object DeveloperAVUExport {

    fun export(
        avuContent: String,
        outputDir: String
    ): List<File> {
        val files = mutableListOf<File>()

        // 1. Main AVU file (unencrypted)
        val avuFile = File(outputDir, "export.vos")
        avuFile.writeText(avuContent)
        files.add(avuFile)

        // 2. JSON representation (for external tools)
        val jsonFile = File(outputDir, "export.json")
        jsonFile.writeText(AVUParser.parse(avuContent).toJSON())
        files.add(jsonFile)

        // 3. Neo4j import script
        val neo4jFile = File(outputDir, "neo4j_import.cypher")
        neo4jFile.writeText(generateNeo4jImport(avuContent))
        files.add(neo4jFile)

        return files
    }

    private fun generateNeo4jImport(avuContent: String): String {
        val parsed = AVUParser.parse(avuContent)
        val cypher = StringBuilder()

        // Create screen nodes
        parsed.getScreens().forEach { screen ->
            cypher.appendLine(
                "CREATE (s:Screen {hash: '${screen.hash}', name: '${screen.name}'})"
            )
        }

        // Create navigation relationships
        parsed.getNavigations().forEach { nav ->
            cypher.appendLine(
                "MATCH (a:Screen {hash: '${nav.fromHash}'}), (b:Screen {hash: '${nav.toHash}'}) " +
                "CREATE (a)-[:LEADS_TO {trigger: '${nav.triggerLabel}'}]->(b)"
            )
        }

        return cypher.toString()
    }
}
```

---

## 11. Quality Gates

| Metric | Target | Measurement |
|--------|--------|-------------|
| Screen coverage | 80%+ | Screens visited / Total screens |
| Element discovery | 90%+ | Elements found / Interactive elements |
| Command accuracy | 95%+ | Successful executions / Total executions |
| Loop avoidance | 100% | No infinite loops in exploration |
| Safety compliance | 100% | No dangerous clicks executed |
| Export validity | 100% | All exports pass AVU schema validation |

---

## 12. Implementation Phases

### Phase 1: Core Safety (Week 1-2)
- [ ] Do Not Click list implementation
- [ ] Dynamic content detection
- [ ] Login screen handling
- [ ] Menu discovery (full query)

### Phase 2: AIDL Extension (Week 3-4)
- [ ] IAccessibilityEventListener interface
- [ ] Event streaming implementation
- [ ] ParcelableNodeInfo serialization
- [ ] Exploration command execution

### Phase 3: User Edition (Week 5-7)
- [ ] Automated exploration engine
- [ ] SQLDelight hybrid storage
- [ ] Progress notification/overlay
- [ ] Encrypted AVU export

### Phase 4: Developer Edition (Week 8-10)
- [ ] Neo4j embedded integration
- [ ] Live element inspector
- [ ] Manual click injection
- [ ] Command test harness

### Phase 5: External Ingestion (Week 11)
- [ ] Folder watcher implementation
- [ ] AVU parser enhancements
- [ ] Database ingestion pipeline
- [ ] NLU quantization integration

### Phase 6: Contact Extraction (Week 12-14)
- [ ] Contact screen detection
- [ ] Scroll-based extraction
- [ ] Deduplication algorithm
- [ ] Privacy consent flow

---

## 13. Related Documents

- AVU Format Spec: `Docs/VoiceOS/Specifications/VoiceOS-AVU-UNIVERSAL-FORMAT-SPEC-50312-V1.md`
- IPC Protocol Spec: `Docs/AVA/Ideacode/specs/AVA-UNIVERSAL-IPC-SPEC-52011-V1.md`
- Database Schema: `Modules/VoiceOS/core/database/src/commonMain/sqldelight/`
- NLU Quantizer: `Modules/VoiceOS/apps/VoiceOSCore/src/main/java/com/augmentalis/voiceoscore/learnapp/ai/quantized/`

---

**Version History**:
| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2025-12-11 | Initial specification |

**Author**: Manoj Jhawar
**License**: Proprietary - Augmentalis ES
