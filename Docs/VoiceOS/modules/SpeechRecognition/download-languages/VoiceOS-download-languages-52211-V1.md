<!--
filename: SpeechRecognition-Architecture-Map.md
created: 2025-11-22 15:50:00 IST
author: VOS4 Development Team
copyright: Copyright (C) Manoj Jhawar/Aman Jhawar, Intelligent Devices LLC
purpose: Architecture map for Speech Recognition module with version history for reverting
last-modified: 2025-11-22 15:50:00 IST
version: 1.0.0
-->

# Download & Setup Vivoka Libs from Cloud

This module provides functionality for downloading and setting up Vivoka speech recognition libraries (libs) from the cloud for Voiceos using Kotlin.
It supports dynamic grammar-based recognition and free speech (dictation) libs.

## **Key features:**

- **Language-Specific Downloads:** Fetch language-specific Vivoka libs from the cloud. For example, you can download Spanish or French libs as needed.
- **Fallback Language:** If no external language pack is available or successfully downloaded, English is bundled within the APK as the
  default/fallback language.
- **Integration with Vivoka SDK:** Use dynamic grammar commands and dictation/free speech capabilities via Vivoka's SDK.

---

## Integrating the Download & Setup Process in Your Android/Kotlin Module

## 1. Create required folder structure and config JSON file

Create required folder structure for required VIVOKA Engine which is mentioned in config json file. Both Config JSON file and folder structure should
match

### 1. Vivoka Voice Resource Folder Structure

This document outlines the folder structure for the Vivoka voice resource files used within the ASR (Automatic Speech Recognition) engine. Each
language-specific resource pack is organized in a structured manner for the Vivoka SDK to function properly.

**Note:** `<Language_Code>` should be replaced by the actual language identifier, e.g., `en`, `fr`, `es`, etc.

#### Folder Hierarchy

<Language_Code>_voice_resource/ └── data/ └── csdk/ └── asr/ ├── acmod/ ├── clc/ ├── ctx/ └── lm/

#### Overview of Each Directory

1. **asr/**  - Used for both dynamic grammar and free speech related file The `asr` (Automatic Speech Recognition) directory contains all core speech
   recognition files. Within `asr`, there are subdirectories that represent different components essential for ASR.

2. **acmod/**  - Used for both dynamic grammar and free speech related file The `acmod` (Acoustic Model) folder contains the acoustic model files.
   These files represent the sounds of the language, used by the ASR engine to map incoming audio to phonemes or other acoustic units.

3. **clc/**  - Used for dynamic grammar The `clc` directory stores custom language component files or language configuration files that help refine
   and adapt the recognition for the chosen language.

4. **ctx/**  - Used for both dynamic grammar and free speech related file The `ctx` (Context) folder includes context-related resources. These might
   define context-specific grammars, dictionaries, or additional files that provide the ASR engine with knowledge about certain domains, commands, or
   situational cues.

5. **lm/**  - Used for free speech related file The `lm` (Language Model) directory contains the language models. These models are statistical or
   rule-based representations of the language’s vocabulary and grammar. They guide the ASR in predicting likely word sequences.

---

**Example:** For French (fr) resources, the structure would be:

fr_voice_resource/ └── data/ └── csdk/ └── asr/ ├── acmod/ ├── clc/ ├── ctx/ └── lm/

Each directory will contain files specific to the French (fr) language, such as `acmod` files trained on French (fr) speech data, an French (fr)
language model (`lm`), and any context or language configuration files (`ctx`, `clc`).

---

**Important:** Ensure that all these directories are populated with the correct files generated by Vivoka’s VDK Studio or provided by Vivoka. Failure
to include required files in any of these directories may result in incomplete or inaccurate speech recognition performance.

### 2. Vivoka ASR Configuration JSON Files

This document describes the configuration JSON files used by the Vivoka SDK to locate and load language-specific ASR (Automatic Speech Recognition)
resources at runtime. These JSON configurations reference all the essential files, including acoustic models, language models, context files, and
lexicon files.

When the Vivoka SDK initializes, it reads the configuration JSON to determine which files to load for a particular language. This flexible,
data-driven approach allows you to switch languages or ASR configurations without modifying code.

---

#### General Structure

The configuration JSON files follow a similar pattern across languages:

- **`version`**: Indicates the configuration file format version.
- **`csdk`**: The main object containing all CSDK (Vivoka Core SDK) settings.
  - **`log`**: Logging configuration.
  - **`asr`**: Automatic Speech Recognition configuration.
    - **`recognizers`**: Defines recognizer-level configurations, including references to acoustic model files (`acmods`).
    - **`models`**: Defines individual ASR models (both free-speech and dynamic) including:
      - **`acmod`**: Acoustic model file reference.
      - **`file`**: The main context file (often `.fcf`) that defines the recognition grammar or domain.
      - **`extra_models`**: Additional language model files for various domains or restricted vocabularies.
      - **`type`**: The type of recognition, such as `free-speech` (dictation) or `dynamic` (dynamic grammar-based).
      - **`settings`**: Optional parameters to fine-tune recognition behavior (e.g., silence threshold).
      - **`slots`**: Customizable slots for handling dynamic vocabularies.
      - **`lexicon`**: References to lexicon or CLC files that provide phonetic and lexical data.

---

#### Example: Japanese Configuration

**Path:** Typically placed in `<Language_Code>_voice_resource/data/csdk/asr/` and loaded at runtime.

```json
{
  "version": "2.0",
  "csdk": {
    "log": {
      "cache": {
        "enabled": false
      }
    },
    "asr": {
      "recognizers": {
        "rec": {
          "acmods": [
            "acmod6_6000_jpj_gen_car_f16_v1_0_1.dat"
          ]
        }
      },
      "models": {
        "japanese-dictation": {
          "acmod": "acmod6_6000_jpj_gen_car_f16_v1_0_1.dat",
          "extra_models": {
            "LM1": "lm-navigation_jpj_vocon_car_restricted_202011262200.dat",
            "LM2": "lm-wuw_jpj_vocon_car_restricted_202011262200.dat",
            "LM3": "lm-assistant_jpj_vocon_car_restricted_202011262200.dat"
          },
          "file": "ctx_jpj_vocon_car_202011262200.fcf",
          "type": "free-speech"
        },
        "asrjpn-JP": {
          "file": "asrjpn-JP.fcf",
          "type": "dynamic",
          "acmod": "acmod6_6000_jpj_gen_car_f16_v1_0_1.dat",
          "settings": {
            "LH_SEARCH_PARAM_MAXNBEST": 1,
            "LH_SEARCH_PARAM_TSILENCE": 600
          },
          "slots": {
            "itemName": {
              "slot": "ASRJPN-JP#item",
              "category": "name",
              "allow_custom_phonetic": true
            }
          },
          "lexicon": {
            "clc": "clc_jpj_cfg3_v6_5_000000.dat"
          }
        }
      }
    }
  }
}
```

### 3. Hosted Files and Remote Configuration

The voice resource files and configuration JSONs for specific languages (in this example, Spanish) are hosted on custom servers and managed via
Firebase Remote Config. Using Remote Config, you can dynamically update the URLs in your Android app at runtime, ensuring the app always downloads the
latest ASR resources and configuration files without requiring a new app build.

#### 1. Release - https://www.augmentalis.com/avanuevoiceosava/

#### 2. Debug - http://fs.dilonline.in/avanue_files/

---

#### Firebase Remote Config Parameters

The following parameters are configured in Firebase Remote Config and can be accessed by the app at runtime. Each parameter value is a URL pointing to
a hosted file on a custom server.

##### Spanish Example

| Parameter Name            | Description                        | URL                                                                          |
| ------------------------- | ---------------------------------- | ---------------------------------------------------------------------------- |
| `es_json`                 | Spanish configuration JSON         | `https://www.augmentalis.com/avanuevoiceosava/Spanish/spanish.json`          |
| `es_json_debug`           | Spanish configuration JSON (Debug) | `http://fs.dilonline.in/avanue_files/spanish.json`                           |
| `es_voice_resource`       | Spanish voice resources ZIP file   | `https://www.augmentalis.com/avanuevoiceosava/Spanish/es_voice_resource.zip` |
| `es_voice_resource_debug` | Spanish voice resources (Debug)    | `http://fs.dilonline.in/avanue_files/es_voice_resource.zip`                  |

**Note:**

- The `*_debug` variants are intended for development or testing environments.
- The non-debug variants (without `_debug`) are meant for production usage.

##### Username and Password for live server (https://www.augmentalis.com/avanuevoiceosava/)

```text
USERNAME = "avanuevoiceos"
PASSWORD = "!AvA\$Avanue123#"
```

### 4. Download Hosted Files and Remote Configuration - FirebaseRemoteConfigRepository.kt

#### FirebaseRemoteConfigRepository

`FirebaseRemoteConfigRepository.kt` is a Kotlin class to downloading and updating voice recognition resources and configuration files at runtime in an
app. By leveraging Firebase Remote Config, this repository fetches the latest file URLs without requiring an app update, ensuring that your speech
recognition models, language resources, and configuration JSONs remain current and adaptable.

#### Key Features

1. **Firebase Remote Config Integration:**  
   Dynamically retrieves the latest URLs for language resources and configuration files from Remote Config parameters. This enables easy and immediate
   updates to resource endpoints without redeploying the app.

```kotlin
private val remoteConfig: FirebaseRemoteConfig = Firebase.remoteConfig

val resultResource = if (!isDebug) {
    "$normalizedLanguageId$VOICE_RESOURCE_SUFFIX" to remoteConfig.getString("$normalizedLanguageId$VOICE_RESOURCE_SUFFIX")
} else {
    "$normalizedLanguageId$VOICE_RESOURCE_SUFFIX_DEBUG" to remoteConfig.getString("$normalizedLanguageId$VOICE_RESOURCE_SUFFIX_DEBUG")
}

```

2. **Seamless Resource Downloads:**  
   Downloads language-specific voice resource ZIP files and configuration JSON files using OkHttp. This includes both production and debug endpoints,
   automatically selected based on the build configuration.

```kotlin
@Throws
    private suspend fun downloadResource(
        pair: Pair<String, String>,
        downloadProgress: (progress: Int) -> Unit
    ): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                android.util.Log.i(TAG, "downloadResource: ${pair.second}")
                // Encode credentials in Base64
                val credentials: String = Credentials.basic(USERNAME, PASSWORD)
                val request = Request.Builder()
                    .addHeader(HEADER_AUTHORIZATION, credentials)
                    .url(pair.second)
                    .build()
                val response = client.newCall(request).execute()

                if (!response.isSuccessful) {
                    android.util.Log.i(TAG, "downloadResource: Failed to download file")
                    return@withContext false
                }

                // Create a file in the external storage directory
                val internalDir = context.filesDir
                val tempFile = File(internalDir, VOICE_TEMP)
                if (!tempFile.exists()) {
                    tempFile.mkdir()
                }
                val file = File(tempFile, "${pair.first}.zip")
                var inputStream: InputStream? = null
                var outputStream: FileOutputStream? = null

                try {
                    inputStream = response.body?.byteStream()
                    outputStream = FileOutputStream(file)

                    // Buffer size for reading data
                    val buffer = ByteArray(2048)
                    var bytesRead: Int
                    val totalBytes = response.body?.contentLength() ?: 0
                    var downloadedBytes: Long = 0

                    // Read from the input stream and write to the output stream
                    while (inputStream?.read(buffer).also { bytesRead = it ?: -1 } != -1) {
                        outputStream.write(buffer, 0, bytesRead)
                        downloadedBytes += bytesRead
                        // Update download progress
                        val progress = (downloadedBytes * 100 / totalBytes)
                        downloadProgress(progress.toInt())
                    }
                    downloadProgress(100)
                    outputStream.flush()
                    return@withContext true
                } catch (e: Exception) {
                    e.printStackTrace()
                    android.util.Log.i(TAG, "Error writing file: ${e.message}")
                    return@withContext false
                } finally {
                    inputStream?.close()
                    outputStream?.close()
                }
            } catch (e: Exception) {
                e.printStackTrace()
                android.util.Log.i(TAG, "Error during download: ${e.message}")
                return@withContext false
            }
        }
    }
```

3. **File Extraction & Management:**  
   After downloading the ZIP file, the repository extracts its contents into a temporary directory and then copies the extracted voice recognition
   resources (`acmod`, `clc`, `ctx`, `lm`) into the app’s file system for immediate use by the Vivoka SDK.  After downloading the ZIP file, the repository extracts its contents into a temporary directory (e.g., `context.filesDir/voice_temp`) and then moves
   the extracted voice recognition resources into the final required directory structure `context.filesDir/vsdk/data/csdk/asr`. For example:

```kotlin
val rootSourceDir = File(context.filesDir, "voice_temp/${languageId}_voice_resource/data/csdk/asr")

val pathResolver = VivokaPathResolver(context)
val path = pathResolver.resolveVsdkPath()
val rootTargetDir = File(path, "data/csdk/asr")


@Throws(Exception::class)
private suspend fun extractFile(languageId: String): Pair<Boolean, File> {
    return withContext(Dispatchers.IO) {
        val internalDir = context.filesDir
        val sourceFile = if (!isDebug) {
            File(internalDir, "$VOICE_TEMP/$languageId$VOICE_RESOURCE_SUFFIX.zip")
        } else {
            File(internalDir, "$VOICE_TEMP/$languageId$VOICE_RESOURCE_SUFFIX_DEBUG.zip")
        }
        val destinationFile = File(internalDir, VOICE_TEMP)
        val isExtracted = FileZipManager().unzip(sourceFile, destinationFile)
        return@withContext Pair(isExtracted, destinationFile)
    }
}
```

4. **Progress & Status Callbacks:**  
   Reports download progress, extraction state, and completion or failure events via `FileStatus` callbacks, allowing the UI to update accordingly (e.g.,
   showing a progress bar or error message).

```kotlin
 suspend fun getLanguageResource(
        languageId: String,
        callback: (status: FileStatus) -> Unit
    ): String? {
     .....
    callback(FileStatus.Initialization)
    callback(FileStatus.Downloading(0))
    callback(FileStatus.Downloading(downloadedProgress))
    callback(FileStatus.Error(FileError.REMOTE))
    callback(FileStatus.Extracting)
    callback(FileStatus.Completed)
    callback(FileStatus.Error(FileError.LOCAL))
    callback(FileStatus.Error(FileError.REMOTE))
    callback(FileStatus.Error(FileError.REMOTE))
     ....
    }
```

5. **Error Handling & Logging:**  
   Integrates with Firebase Crashlytics for error reporting and uses `VoiceOsLogger` for internal logging. This ensures that any network, file I/O, or
   runtime errors are captured for debugging.

The configuration JSON is not stored as a file; instead, it’s downloaded as a string and can be passed directly to the Vivoka SDK for initialization.

#### Usage Example in `VivokaSpeechRecognitionService.kt`

**Initialization:**

```kotlin
val repository = FirebaseRemoteConfigRepository(context)
repository.init() // Fetches remote config settings and activates them.
```

**Download & Setup Language Resources:** Class `FirebaseRemoteConfigRepository` is being Used / Initialize in  `VivokaEngine`
inside function `initialize`. And `initialize` function in  `VivokaEngine` is being called whenever user  install fresh app and
start `AccessibilityService (VoiceOsService)`

```kotlin
val languageId = "es" // Spanish
repository.getLanguageResource(languageId) { status: FileStatus ->
    when (status) {
        FileStatus.Initialization -> { /* Show loading indicator */
        }
        is FileStatus.Downloading -> { /* Update download progress UI */
        }
        FileStatus.Extracting -> { /* Notify user that files are being extracted */
        }
        FileStatus.Completed -> {
            // Voice resources ready. Initialize Vivoka SDK now.
        }
        is FileStatus.Error -> {
            // Handle error (e.g., retry or show error message)
        }
    }
}
```
#### Merge with downloaded models and config

Once language files get downloaded it should merge with already downloaded files   

##### Merge model files in `FirebaseRemoteConfigRepository.kt`

```kotlin
 @Throws(Exception::class)
    private suspend fun copyFiles(languageId: String) {
        withContext(Dispatchers.IO) {
            val rootSourceDir = File(context.filesDir, "voice_temp/${languageId}_voice_resource/data/csdk/asr")
            val pathResolver = VivokaPathResolver(context)
            val path = pathResolver.resolveVsdkPath()
            val rootTargetDir = File(path, "data/csdk/asr")

            // List of folders that need to be processed
            val folders = listOf("clc", "acmod", "lm", "ctx")

            // Iterate over each subfolder and move the files
            folders.forEach { subfolder ->

                val sourceDir = File(rootSourceDir, subfolder)
                val targetDir = File(rootTargetDir, subfolder)
                // If the target directory doesn't exist, create it
                if (!targetDir.exists()) {
                    targetDir.mkdirs()
                }
                // Move files from sourceDir to targetDir
                sourceDir.listFiles()?.forEach { file ->
                    if (file.isFile) {
                        val targetFile = File(targetDir, file.name)
                        file.copyTo(targetFile, overwrite = true)
                        file.delete()  // Delete the original file after copying
                    }
                }
            }
        }


    }
```

##### Merge Config File in VivokaEngine and VivokaConfig 
Merge `config.json` in VivokaConfig so that all models get initialized parallel   

```kotlin
fun mergeJsonFiles(downloadedFile: String): String? {
        try {// Step 1: Read the existing JSON from internal storage
            val vsdkFile = File(configPath)
            val vsdkContent = FileReader(vsdkFile).readText()
            val gson = Gson()
            // Load and parse local english file from assets
            val vsdkContentRoot = gson.fromJson(vsdkContent, Root::class.java)

            Log.i(TAG, "mergeJsonFiles: vsdkContentRoot = $vsdkContentRoot")

            // Load and parse download files
            val downloadRoot = gson.fromJson(downloadedFile, Root::class.java)

            Log.i(TAG, "mergeJsonFiles: frenchRoot = $downloadRoot")
            // Merge acmods
            vsdkContentRoot.csdk.asr.recognizers.rec.acmods.addAll(downloadRoot.csdk.asr.recognizers.rec.acmods)

            // Merge models from French and Spanish into English
            downloadRoot.csdk.asr.models.forEach { (name, value) ->
                value.let {
                    vsdkContentRoot.csdk.asr.models[name] = mergeModels(
                        vsdkContentRoot.csdk.asr.models[name],
                        it
                    )
                }
            }

            // Save the final merged JSON as final.json in internal storage
            val finalJsonString = gson.toJson(vsdkContentRoot)
            Log.i(TAG, "mergeJsonFiles: finalJsonString = $finalJsonString")
            // Step 4: Write the modified JSON back to the file
            FileOutputStream(vsdkFile).use {
                it.write(finalJsonString.toByteArray())  // The 4 spaces indentation makes it nicely formatted
            }
            return vsdkFile.path
        } catch (e: Exception) {
            e.printStackTrace()
            return null
        }
    }

    // Helper function to merge two Model objects
    private fun mergeModels(existing: Model?, newModel: Model): Model {
        val mergedExtraModels = (existing?.extraModels ?: mutableMapOf()).apply {
            putAll(newModel.extraModels ?: emptyMap())
        }
        val mergedSettings = (existing?.settings ?: mutableMapOf()).apply {
            putAll(newModel.settings ?: emptyMap())
        }
        return Model(
            type = newModel.type,
            file = newModel.file,
            acmod = newModel.acmod,
            extraModels = mergedExtraModels,
            settings = mergedSettings,
            slots = newModel.slots ?: existing?.slots,
            lexicon = newModel.lexicon ?: existing?.lexicon
        )
    }
```