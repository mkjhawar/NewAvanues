# AVA-Generated Diagnostic Workflow Example
## Ford Explorer - Oxygen Sensor Troubleshooting

**Scenario**: A mechanic needs to diagnose and fix an oxygen sensor issue on a 2020 Ford Explorer. AVA has ingested the Ford Explorer service manual and generates a complete diagnostic workflow with troubleshooting steps.

---

## üìñ Source Material (What AVA Ingested)

AVA analyzed the following documents:
- **Ford Explorer 2020 Service Manual** (2,400 pages)
- **OBD-II Diagnostic Trouble Code Database**
- **Ford Technical Service Bulletins (TSBs)**
- **Common repair forum discussions**
- **Parts specifications and diagrams**

---

## ü§ñ AVA Prompt

```
AVA, create a diagnostic workflow for troubleshooting oxygen sensor issues
on a 2020 Ford Explorer. Include:
- Step-by-step diagnostic procedure
- Required tools and parts
- Common failure modes
- Advanced troubleshooting for difficult cases
- FAQ section with solutions when standard procedure fails
```

---

## ‚ú® Generated Workflow (by AVA)

```kotlin
/**
 * Ford Explorer 2020 - Oxygen Sensor Diagnostic Workflow
 * Generated by AVA from Ford Service Manual
 * DTCs Addressed: P0130, P0131, P0132, P0133, P0134, P0135, P0136, P0137, P0138
 */

val fordExplorerO2SensorDiagnostic = workflow(
    id = "ford_explorer_2020_o2_sensor_diagnostic",
    metadata = WorkflowMetadata(
        title = "Ford Explorer - O2 Sensor Troubleshooting",
        description = "Complete diagnostic procedure for oxygen sensor issues",
        version = "1.0.0",
        allowBack = true,
        autoSave = true
    )
) {

    // ============================================================
    // STEP 1: INITIAL ASSESSMENT
    // ============================================================
    step("initial_assessment") {
        title("Initial Assessment & Code Reading")
        description("Gather vehicle information and read diagnostic trouble codes")

        form(form("initial_info") {
            textField("vin") {
                label("VIN (Vehicle Identification Number)")
                required()
                pattern("[A-HJ-NPR-Z0-9]{17}")
            }

            numberField("mileage") {
                label("Current Mileage")
                required()
                min(0)
            }

            textField("dtc_codes") {
                label("DTC Codes (comma-separated)")
                required()
                placeholder("P0131, P0135")
            }

            selectField("check_engine_light", listOf(
                "ON - Steady",
                "ON - Flashing",
                "OFF - Recently cleared"
            )) {
                label("Check Engine Light Status")
                required()
            }

            textAreaField("customer_complaint") {
                label("Customer Complaint")
                required()
                placeholder("Describe symptoms: rough idle, poor fuel economy, etc.")
            }

            textField("technician_name") {
                label("Technician Name")
                required()
            }
        })

        onComplete { data ->
            // AVA GENERATED: Parse DTCs and determine sensor bank/position
            val dtcCodes = (data["dtc_codes"] as String)
                .split(",")
                .map { it.trim() }

            val sensorInfo = analyzeDTCCodes(dtcCodes)
            data["affected_sensors"] = sensorInfo.sensors
            data["sensor_bank"] = sensorInfo.bank
            data["sensor_position"] = sensorInfo.position
            data["probable_cause"] = sensorInfo.probableCause

            // Log diagnostic start
            logger.info("Diagnostic started for VIN: ${data["vin"]}")
            logger.info("DTCs: ${dtcCodes.joinToString()}")
            logger.info("Affected sensors: ${sensorInfo.sensors}")

            // Track in repair management system
            repairSystem.createWorkOrder(
                vin = data["vin"] as String,
                technician = data["technician_name"] as String,
                type = "Oxygen Sensor Diagnostic",
                dtcCodes = dtcCodes
            )
        }
    }

    // ============================================================
    // STEP 2: TOOLS & SAFETY CHECK
    // ============================================================
    step("tools_safety") {
        title("Required Tools & Safety Verification")
        description("Verify all required tools are available and safety procedures understood")

        form(form("tools_checklist") {
            booleanField("scan_tool") {
                label("OBD-II Scan Tool with Live Data")
                required()
            }

            booleanField("digital_multimeter") {
                label("Digital Multimeter (DMM)")
                required()
            }

            booleanField("oxygen_sensor_socket") {
                label("Oxygen Sensor Socket (7/8\" or 22mm)")
                required()
            }

            booleanField("wire_piercing_probes") {
                label("Wire Piercing Probes (Backprobe Kit)")
                required()
            }

            booleanField("torque_wrench") {
                label("Torque Wrench (30-40 lb-ft range)")
                required()
            }

            booleanField("anti_seize") {
                label("Anti-Seize Compound (nickel-based)")
                required()
            }

            booleanField("safety_glasses") {
                label("Safety Glasses")
                required()
            }

            booleanField("gloves") {
                label("Heat-Resistant Gloves")
                required()
            }

            booleanField("vehicle_lifted") {
                label("Vehicle properly lifted and secured")
                required()
            }

            booleanField("engine_cool") {
                label("Engine is cool (not running for 30+ minutes)")
                required()
            }
        })

        validate { data ->
            // AVA GENERATED: Ensure all safety items checked
            val safetyItems = listOf("safety_glasses", "gloves", "vehicle_lifted", "engine_cool")
            val missingItems = safetyItems.filter { data[it] != true }

            if (missingItems.isNotEmpty()) {
                ValidationResult.Failure(mapOf(
                    "safety" to listOf("SAFETY VIOLATION: Must complete all safety checks: ${missingItems.joinToString()}")
                ))
            } else {
                ValidationResult.Success
            }
        }

        onComplete { data ->
            logger.info("Tools and safety verification complete")
            data["tools_verified_at"] = System.currentTimeMillis()
        }
    }

    // ============================================================
    // STEP 3: VISUAL INSPECTION
    // ============================================================
    step("visual_inspection") {
        title("Visual Inspection")
        description("Inspect oxygen sensor, wiring, and exhaust system")

        form(form("visual_findings") {
            selectField("sensor_location_verified", listOf(
                "Bank 1 Sensor 1 (Pre-Cat)",
                "Bank 1 Sensor 2 (Post-Cat)",
                "Bank 2 Sensor 1 (Pre-Cat)",
                "Bank 2 Sensor 2 (Post-Cat)"
            )) {
                label("Sensor Location (verify physically)")
                required()
            }

            selectField("wiring_condition", listOf(
                "Good - No damage visible",
                "Damaged - Frayed/melted insulation",
                "Damaged - Connector corrosion",
                "Damaged - Wire breakage",
                "Damaged - Rodent damage"
            )) {
                label("Wiring Harness Condition")
                required()
            }

            selectField("connector_condition", listOf(
                "Good - Clean and tight",
                "Dirty - Needs cleaning",
                "Corroded - Green/white deposits",
                "Loose - Poor connection",
                "Damaged - Broken pins"
            )) {
                label("Connector Condition")
                required()
            }

            selectField("sensor_physical", listOf(
                "Good - No visible damage",
                "Contaminated - Black soot buildup",
                "Contaminated - White/gray ash",
                "Damaged - Broken housing",
                "Damaged - Missing tip"
            )) {
                label("Sensor Physical Condition")
                required()
            }

            selectField("exhaust_leaks", listOf(
                "None detected",
                "Minor leak - Before sensor",
                "Major leak - Before sensor",
                "Minor leak - After sensor"
            )) {
                label("Exhaust Leaks")
                required()
            }

            textAreaField("additional_observations") {
                label("Additional Observations")
                placeholder("Note any unusual conditions, smells, or other findings")
            }
        })

        onComplete { data ->
            // AVA GENERATED: Analyze visual findings
            val wiringCondition = data["wiring_condition"] as String
            val connectorCondition = data["connector_condition"] as String
            val sensorPhysical = data["sensor_physical"] as String
            val exhaustLeaks = data["exhaust_leaks"] as String

            // Determine if wiring repair needed
            val needsWiringRepair = wiringCondition.contains("Damaged") ||
                                   connectorCondition.contains("Damaged") ||
                                   connectorCondition.contains("Corroded")

            data["needs_wiring_repair"] = needsWiringRepair

            // Determine if sensor replacement likely
            val likelySensorFailure = sensorPhysical.contains("Contaminated") ||
                                      sensorPhysical.contains("Damaged")

            data["likely_sensor_failure"] = likelySensorFailure

            // Check for exhaust leak influence
            val exhaustLeakPresent = exhaustLeaks.contains("leak - Before sensor")
            data["exhaust_leak_before_sensor"] = exhaustLeakPresent

            if (exhaustLeakPresent) {
                logger.warn("CRITICAL: Exhaust leak before sensor detected - will cause false readings")
                data["exhaust_leak_warning"] = "Must repair exhaust leak before replacing sensor"
            }

            logger.info("Visual inspection findings: Wiring=${wiringCondition}, Sensor=${sensorPhysical}")
        }
    }

    // ============================================================
    // STEP 4: ELECTRICAL TESTING
    // ============================================================
    step("electrical_testing") {
        title("Electrical System Testing")
        description("Test voltage, ground, and heater circuit")

        // Skip if visual inspection found obvious damage
        skipIf { data ->
            val wiringDamaged = data["needs_wiring_repair"] as? Boolean ?: false
            val exhaustLeak = data["exhaust_leak_before_sensor"] as? Boolean ?: false
            wiringDamaged || exhaustLeak
        }

        onSkip { data ->
            if (data["needs_wiring_repair"] as? Boolean == true) {
                data["skip_reason"] = "Wiring damage found - repair required before testing"
            } else {
                data["skip_reason"] = "Exhaust leak found - repair required before testing"
            }
        }

        form(form("electrical_tests") {
            numberField("heater_resistance") {
                label("Heater Circuit Resistance (Œ©)")
                required()
                min(0)
                placeholder("Expected: 2-14Œ© at 68¬∞F")
            }

            numberField("signal_voltage_idle") {
                label("Signal Voltage at Idle (V)")
                required()
                min(0)
                max(5)
                placeholder("Expected: 0.1-0.9V fluctuating")
            }

            numberField("signal_voltage_2500rpm") {
                label("Signal Voltage at 2500 RPM (V)")
                required()
                min(0)
                max(5)
            }

            numberField("ground_resistance") {
                label("Ground Circuit Resistance (Œ©)")
                required()
                min(0)
                placeholder("Expected: <0.5Œ©")
            }

            numberField("heater_voltage") {
                label("Heater Supply Voltage (V)")
                required()
                min(0)
                placeholder("Expected: 12-14V")
            }

            booleanField("signal_fluctuates") {
                label("Signal voltage fluctuates properly?")
                required()
            }

            numberField("response_time") {
                label("Response Time (seconds)")
                required()
                placeholder("Expected: <1 second to snap from rich to lean")
            }
        })

        validate { data ->
            // AVA GENERATED: Validate electrical readings against Ford specs
            val heaterResistance = (data["heater_resistance"] as Number).toDouble()
            val groundResistance = (data["ground_resistance"] as Number).toDouble()
            val heaterVoltage = (data["heater_voltage"] as Number).toDouble()
            val responseTime = (data["response_time"] as Number).toDouble()

            val errors = mutableMapOf<String, List<String>>()

            // Check heater resistance (Ford spec: 2-14Œ© at 68¬∞F)
            if (heaterResistance < 2.0 || heaterResistance > 14.0) {
                errors["heater_resistance"] = listOf(
                    "OUT OF SPEC: Expected 2-14Œ©, measured ${heaterResistance}Œ© - Heater circuit faulty"
                )
            }

            // Check ground (must be <0.5Œ©)
            if (groundResistance > 0.5) {
                errors["ground_resistance"] = listOf(
                    "OUT OF SPEC: Ground resistance too high (${groundResistance}Œ©) - Poor ground connection"
                )
            }

            // Check heater voltage
            if (heaterVoltage < 12.0) {
                errors["heater_voltage"] = listOf(
                    "LOW VOLTAGE: Expected 12-14V, measured ${heaterVoltage}V - Check fuse/relay"
                )
            }

            // Check response time (should be <1 second)
            if (responseTime > 1.0) {
                errors["response_time"] = listOf(
                    "SLOW RESPONSE: Sensor response time ${responseTime}s - Sensor degraded/contaminated"
                )
            }

            if (errors.isNotEmpty()) {
                ValidationResult.Failure(errors)
            } else {
                ValidationResult.Success
            }
        }

        onComplete { data ->
            // AVA GENERATED: Analyze test results and determine failure mode
            val heaterResistance = (data["heater_resistance"] as Number).toDouble()
            val groundResistance = (data["ground_resistance"] as Number).toDouble()
            val signalFluctuates = data["signal_fluctuates"] as Boolean
            val responseTime = (data["response_time"] as Number).toDouble()

            val failureMode = when {
                heaterResistance > 14.0 -> "HEATER_OPEN_CIRCUIT"
                heaterResistance < 2.0 -> "HEATER_SHORT_CIRCUIT"
                groundResistance > 0.5 -> "POOR_GROUND"
                !signalFluctuates -> "SENSOR_LAZY_DEAD"
                responseTime > 1.0 -> "SENSOR_CONTAMINATED"
                else -> "SENSOR_OK"
            }

            data["failure_mode"] = failureMode
            data["diagnosis"] = getDiagnosisMessage(failureMode)

            logger.info("Electrical testing complete: Failure mode = $failureMode")
        }
    }

    // ============================================================
    // STEP 5: LIVE DATA ANALYSIS
    // ============================================================
    step("live_data_analysis") {
        title("Live Data Analysis")
        description("Analyze sensor data using scan tool")

        condition { data ->
            // Only if electrical tests passed
            val failureMode = data["failure_mode"] as? String
            failureMode == "SENSOR_OK" || failureMode == null
        }

        form(form("live_data") {
            numberField("short_term_ft_bank1") {
                label("Short Term Fuel Trim Bank 1 (%)")
                required()
                placeholder("Expected: -10% to +10%")
            }

            numberField("long_term_ft_bank1") {
                label("Long Term Fuel Trim Bank 1 (%)")
                required()
                placeholder("Expected: -10% to +10%")
            }

            numberField("o2_switching_rate") {
                label("O2 Sensor Switching Rate (switches/10sec)")
                required()
                placeholder("Expected: 8-15 switches")
            }

            numberField("catalyst_efficiency") {
                label("Catalyst Monitor Status (%)")
                required()
                min(0)
                max(100)
                placeholder("Expected: >95%")
            }

            booleanField("freeze_frame_captured") {
                label("Freeze frame data captured?")
                required()
            }

            textAreaField("freeze_frame_notes") {
                label("Freeze Frame Conditions")
                placeholder("RPM, load, coolant temp, etc. when code set")
            }
        })

        onComplete { data ->
            // AVA GENERATED: Analyze fuel trims and sensor performance
            val shortTermFT = (data["short_term_ft_bank1"] as Number).toDouble()
            val longTermFT = (data["long_term_ft_bank1"] as Number).toDouble()
            val switchingRate = (data["o2_switching_rate"] as Number).toDouble()

            // Determine if fuel trim excessive
            val excessiveFuelTrim = Math.abs(shortTermFT) > 10 || Math.abs(longTermFT) > 10
            data["excessive_fuel_trim"] = excessiveFuelTrim

            // Determine if sensor is lazy
            val sensorLazy = switchingRate < 8
            data["sensor_lazy"] = sensorLazy

            if (excessiveFuelTrim) {
                logger.warn("Excessive fuel trim detected: ST=${shortTermFT}%, LT=${longTermFT}%")
                data["fuel_trim_warning"] = "Possible vacuum leak or fuel system issue"
            }

            if (sensorLazy) {
                logger.warn("Sensor switching rate low: ${switchingRate} switches/10sec")
                data["recommendation"] = "REPLACE_SENSOR"
            } else {
                data["recommendation"] = "MONITOR"
            }
        }
    }

    // ============================================================
    // STEP 6: DIAGNOSIS SUMMARY
    // ============================================================
    step("diagnosis_summary") {
        title("Diagnosis Summary & Recommendation")
        description("Review findings and determine repair action")

        form(form("diagnosis") {
            selectField("root_cause", listOf(
                "Oxygen Sensor Failed",
                "Wiring/Connector Issue",
                "Exhaust Leak",
                "Ground Circuit Problem",
                "Heater Circuit Problem",
                "Sensor Contamination",
                "Other - See notes"
            )) {
                label("Root Cause Determination")
                required()
            }

            selectField("recommended_action", listOf(
                "Replace Oxygen Sensor",
                "Repair Wiring/Connector",
                "Repair Exhaust Leak",
                "Clean Sensor (if contaminated)",
                "Repair Ground Circuit",
                "Replace Heater Fuse/Relay",
                "Multiple Repairs Required"
            )) {
                label("Recommended Repair Action")
                required()
            }

            textAreaField("technician_notes") {
                label("Technician Notes")
                required()
                placeholder("Document all findings, measurements, and reasoning for diagnosis")
            }

            booleanField("customer_approval") {
                label("Customer approval obtained for repair?")
                required()
            }

            numberField("estimated_cost") {
                label("Estimated Repair Cost ($)")
                required()
                min(0)
            }
        })

        onComplete { data ->
            // AVA GENERATED: Create detailed diagnostic report
            val report = generateDiagnosticReport(data)
            data["diagnostic_report"] = report

            // Update repair system
            repairSystem.updateWorkOrder(
                vin = data["vin"] as String,
                diagnosis = data["root_cause"] as String,
                recommendation = data["recommended_action"] as String,
                estimatedCost = (data["estimated_cost"] as Number).toDouble(),
                report = report
            )

            // Email report to service advisor
            emailService.send(
                to = "service@dealership.com",
                subject = "Diagnostic Complete: ${data["vin"]}",
                body = report
            )

            logger.info("Diagnosis complete: ${data["root_cause"]}")
        }
    }

    // ============================================================
    // STEP 7: REPAIR PROCEDURE
    // ============================================================
    step("repair_procedure") {
        title("Repair Execution")
        description("Perform the repair based on diagnosis")

        // Only if customer approved
        condition { data ->
            data["customer_approval"] as? Boolean == true
        }

        form(form("repair_steps") {
            booleanField("old_sensor_removed") {
                label("Old sensor removed")
            }

            numberField("sensor_torque") {
                label("New sensor torqued to spec (lb-ft)")
                placeholder("Spec: 30-40 lb-ft")
            }

            booleanField("anti_seize_applied") {
                label("Anti-seize applied to threads")
            }

            booleanField("connector_secured") {
                label("Connector properly secured and routed")
            }

            booleanField("codes_cleared") {
                label("DTCs cleared after repair")
            }

            textField("new_part_number") {
                label("New Part Number Installed")
                placeholder("e.g., DY-1508, Motorcraft DY1508")
            }
        })

        validate { data ->
            // AVA GENERATED: Ensure proper torque applied
            val torque = data["sensor_torque"] as? Number
            if (torque != null && (torque.toDouble() < 30 || torque.toDouble() > 40)) {
                ValidationResult.Failure(mapOf(
                    "sensor_torque" to listOf("Torque must be 30-40 lb-ft per Ford spec")
                ))
            } else {
                ValidationResult.Success
            }
        }

        onComplete { data ->
            logger.info("Repair completed: ${data["new_part_number"]}")
            data["repair_completed_at"] = System.currentTimeMillis()
        }
    }

    // ============================================================
    // STEP 8: POST-REPAIR VERIFICATION
    // ============================================================
    step("post_repair_verification") {
        title("Post-Repair Testing & Verification")
        description("Verify repair resolved the issue")

        form(form("verification") {
            selectField("test_drive_result", listOf(
                "PASS - No codes returned",
                "PASS - Sensor data normal",
                "FAIL - Code returned immediately",
                "FAIL - Code returned after 10+ minutes",
                "FAIL - Different code appeared"
            )) {
                label("Test Drive Result")
                required()
            }

            numberField("verification_o2_voltage") {
                label("O2 Sensor Voltage After Repair (V)")
                required()
                placeholder("Expected: 0.1-0.9V fluctuating")
            }

            numberField("verification_fuel_trim") {
                label("Fuel Trim After Repair (%)")
                required()
                placeholder("Expected: -10% to +10%")
            }

            booleanField("customer_concern_resolved") {
                label("Original customer concern resolved?")
                required()
            }

            textAreaField("final_notes") {
                label("Final Notes")
                placeholder("Any additional observations or recommendations")
            }
        })

        validate { data ->
            // AVA GENERATED: Ensure repair was successful
            val testDriveResult = data["test_drive_result"] as String
            val concernResolved = data["customer_concern_resolved"] as Boolean

            if (testDriveResult.startsWith("FAIL") || !concernResolved) {
                ValidationResult.Failure(mapOf(
                    "repair_status" to listOf("REPAIR FAILED - Proceed to advanced troubleshooting")
                ))
            } else {
                ValidationResult.Success
            }
        }

        onComplete { data ->
            val success = (data["test_drive_result"] as String).startsWith("PASS")

            if (success) {
                // Close work order
                repairSystem.closeWorkOrder(
                    vin = data["vin"] as String,
                    status = "COMPLETED",
                    notes = data["final_notes"] as? String
                )

                logger.info("Repair verified successful")
            } else {
                // Escalate to advanced troubleshooting
                data["requires_advanced_troubleshooting"] = true
                logger.warn("Repair verification failed - escalating")
            }
        }
    }

    // ============================================================
    // STEP 9: ADVANCED TROUBLESHOOTING (If repair failed)
    // ============================================================
    step("advanced_troubleshooting") {
        title("Advanced Troubleshooting & FAQ")
        description("Diagnostic help when standard procedure doesn't resolve issue")

        // Only show if previous repair failed
        condition { data ->
            data["requires_advanced_troubleshooting"] as? Boolean == true
        }

        form(form("advanced_diagnostics") {
            selectField("scenario", listOf(
                "Code returns immediately after clearing",
                "Code returns only when engine hot",
                "Code returns only when engine cold",
                "Multiple O2 sensors showing same problem",
                "New sensor reads same as old sensor",
                "Sensor voltage stuck high (>0.9V)",
                "Sensor voltage stuck low (<0.1V)",
                "Intermittent code - comes and goes",
                "Other - describe below"
            )) {
                label("Problem Scenario")
                required()
            }

            textAreaField("scenario_details") {
                label("Detailed Description")
                required()
                placeholder("Provide all relevant details about the problem")
            }
        })

        onComplete { data ->
            // AVA GENERATED: Provide scenario-specific guidance
            val scenario = data["scenario"] as String
            val guidance = getAdvancedTroubleshootingGuidance(scenario)

            data["advanced_guidance"] = guidance

            logger.info("Advanced troubleshooting scenario: $scenario")
        }
    }

    // ============================================================
    // STEP 10: FINAL DOCUMENTATION
    // ============================================================
    step("final_documentation") {
        title("Final Documentation & Closeout")
        description("Complete repair documentation")

        form(form("closeout") {
            textAreaField("work_performed") {
                label("Work Performed Summary")
                required()
                placeholder("Summarize all diagnostic steps and repairs")
            }

            textAreaField("parts_used") {
                label("Parts Used")
                required()
                placeholder("List all parts with part numbers and quantities")
            }

            numberField("labor_hours") {
                label("Labor Hours")
                required()
                min(0)
            }

            numberField("final_cost") {
                label("Final Cost ($)")
                required()
                min(0)
            }

            booleanField("customer_signed_off") {
                label("Customer signed repair order")
                required()
            }
        })

        onComplete { data ->
            // AVA GENERATED: Generate final invoice and close work order
            val invoice = generateInvoice(data)
            data["invoice"] = invoice

            repairSystem.finalizeWorkOrder(
                vin = data["vin"] as String,
                laborHours = (data["labor_hours"] as Number).toDouble(),
                totalCost = (data["final_cost"] as Number).toDouble(),
                invoice = invoice
            )

            // Archive all diagnostic data
            archiveService.store(
                vin = data["vin"] as String,
                type = "O2_SENSOR_REPAIR",
                data = data
            )

            logger.info("Work order finalized: ${data["vin"]}")

            println("=== DIAGNOSTIC WORKFLOW COMPLETE ===")
            println("VIN: ${data["vin"]}")
            println("Diagnosis: ${data["root_cause"]}")
            println("Repair: ${data["recommended_action"]}")
            println("Status: ${if (data["customer_concern_resolved"] == true) "SUCCESS" else "ESCALATED"}")
        }
    }
}

// ============================================================
// AVA-GENERATED HELPER FUNCTIONS
// ============================================================

/**
 * Parse DTC codes and determine affected sensors
 * Generated by AVA from Ford diagnostic manual
 */
data class SensorInfo(
    val sensors: List<String>,
    val bank: String,
    val position: String,
    val probableCause: String
)

fun analyzeDTCCodes(codes: List<String>): SensorInfo {
    val sensorList = mutableListOf<String>()
    var bank = "Unknown"
    var position = "Unknown"
    var cause = "Unknown"

    codes.forEach { code ->
        when (code.trim()) {
            "P0130" -> {
                sensorList.add("Bank 1 Sensor 1")
                bank = "Bank 1"
                position = "Upstream (Pre-Catalytic Converter)"
                cause = "Circuit malfunction - Check wiring/sensor"
            }
            "P0131" -> {
                sensorList.add("Bank 1 Sensor 1")
                bank = "Bank 1"
                position = "Upstream"
                cause = "Low voltage - Sensor reading lean"
            }
            "P0132" -> {
                sensorList.add("Bank 1 Sensor 1")
                bank = "Bank 1"
                position = "Upstream"
                cause = "High voltage - Sensor reading rich or contaminated"
            }
            "P0133" -> {
                sensorList.add("Bank 1 Sensor 1")
                bank = "Bank 1"
                position = "Upstream"
                cause = "Slow response - Sensor lazy/contaminated"
            }
            "P0134" -> {
                sensorList.add("Bank 1 Sensor 1")
                bank = "Bank 1"
                position = "Upstream"
                cause = "No activity detected - Sensor dead or wiring issue"
            }
            "P0135" -> {
                sensorList.add("Bank 1 Sensor 1 Heater")
                bank = "Bank 1"
                position = "Upstream"
                cause = "Heater circuit malfunction - Check fuse, relay, wiring"
            }
            "P0136" -> {
                sensorList.add("Bank 1 Sensor 2")
                bank = "Bank 1"
                position = "Downstream (Post-Catalytic Converter)"
                cause = "Circuit malfunction"
            }
            "P0137" -> {
                sensorList.add("Bank 1 Sensor 2")
                bank = "Bank 1"
                position = "Downstream"
                cause = "Low voltage"
            }
            "P0138" -> {
                sensorList.add("Bank 1 Sensor 2")
                bank = "Bank 1"
                position = "Downstream"
                cause = "High voltage - Possible catalytic converter failure"
            }
            // Add more codes as needed
        }
    }

    return SensorInfo(sensorList, bank, position, cause)
}

/**
 * Get diagnosis message based on failure mode
 */
fun getDiagnosisMessage(failureMode: String): String {
    return when (failureMode) {
        "HEATER_OPEN_CIRCUIT" -> "Heater circuit open - Replace oxygen sensor"
        "HEATER_SHORT_CIRCUIT" -> "Heater circuit shorted - Replace oxygen sensor"
        "POOR_GROUND" -> "Ground circuit resistance high - Clean ground connection at engine block"
        "SENSOR_LAZY_DEAD" -> "Sensor not responding - Replace oxygen sensor"
        "SENSOR_CONTAMINATED" -> "Sensor contaminated (likely fuel/oil) - Replace sensor and investigate contamination source"
        "SENSOR_OK" -> "Sensor electrical tests pass - Possible intermittent issue or false code"
        else -> "Unknown failure mode"
    }
}

/**
 * Advanced troubleshooting guidance for difficult scenarios
 * Generated by AVA from Ford TSBs and repair forums
 */
fun getAdvancedTroubleshootingGuidance(scenario: String): String {
    return when (scenario) {
        "Code returns immediately after clearing" -> """
            LIKELY CAUSES:
            1. Sensor actually failed (most common)
            2. Wiring harness damage between sensor and PCM
            3. PCM ground issue
            4. Exhaust leak before sensor

            ADVANCED TESTS:
            ‚Ä¢ Check voltage at PCM connector (not just at sensor)
            ‚Ä¢ Inspect PCM grounds G101, G102 (passenger side frame rail)
            ‚Ä¢ Smoke test exhaust system
            ‚Ä¢ Check for aftermarket intake/exhaust affecting airflow

            FORD TSB 20-2468: Check for loose heat shield causing wire abrasion
        """.trimIndent()

        "Code returns only when engine hot" -> """
            LIKELY CAUSES:
            1. Intermittent short in wiring when expanded by heat
            2. Sensor internal failure when hot
            3. Exhaust leak opens up when hot

            ADVANCED TESTS:
            ‚Ä¢ Heat cycle test: Run engine to operating temp, watch live data
            ‚Ä¢ Flex wiring harness while monitoring voltage (look for dropouts)
            ‚Ä¢ Check exhaust manifold bolts - they loosen over time
            ‚Ä¢ Test sensor resistance when hot vs. cold

            FORD TSB 18-2234: 2020 Explorer exhaust manifold bolts may loosen at 30k+ miles
        """.trimIndent()

        "Multiple O2 sensors showing same problem" -> """
            LIKELY CAUSES:
            1. PCM power or ground issue (NOT sensor failure)
            2. Fuel contamination affecting all sensors
            3. Wiring harness damage in main loom
            4. PCM malfunction

            ADVANCED TESTS:
            ‚Ä¢ Check PCM power and ground circuits
            ‚Ä¢ Test fuel sample for contamination (silicon, sulfur)
            ‚Ä¢ Check for common wiring damage near transmission
            ‚Ä¢ Consider PCM replacement only as last resort

            IMPORTANT: DO NOT replace multiple sensors - fix root cause first!
        """.trimIndent()

        "New sensor reads same as old sensor" -> """
            LIKELY CAUSES:
            1. Wiring or connector problem (sensor is fine)
            2. Exhaust leak causing false readings
            3. Fuel system issue (running rich/lean)
            4. MAF sensor contamination

            ADVANCED TESTS:
            ‚Ä¢ Swap sensor to different bank/position - does code follow sensor?
            ‚Ä¢ Check short-term and long-term fuel trims
            ‚Ä¢ Clean or replace MAF sensor
            ‚Ä¢ Check fuel pressure (should be 55-65 PSI)
            ‚Ä¢ Inspect PCV system for restrictions

            FORD TSB 19-2156: Contaminated MAF can cause O2 sensor codes
        """.trimIndent()

        "Sensor voltage stuck high (>0.9V)" -> """
            LIKELY CAUSES:
            1. Running rich - excess fuel
            2. Fuel injector leaking
            3. High fuel pressure
            4. Contaminated sensor

            ADVANCED TESTS:
            ‚Ä¢ Check fuel pressure with gauge (spec: 55-65 PSI)
            ‚Ä¢ Cylinder balance test to find leaking injector
            ‚Ä¢ Check fuel pressure regulator
            ‚Ä¢ Inspect spark plugs - black/sooty indicates rich condition
            ‚Ä¢ Look for vacuum leaks in EVAP system

            DIAGNOSTIC TIP: Create artificial lean condition (vacuum leak) -
            if sensor doesn't respond, sensor is bad. If it responds, fuel system issue.
        """.trimIndent()

        "Sensor voltage stuck low (<0.1V)" -> """
            LIKELY CAUSES:
            1. Running lean - insufficient fuel or air leak
            2. Vacuum leak
            3. Low fuel pressure
            4. Exhaust leak before sensor

            ADVANCED TESTS:
            ‚Ä¢ Smoke test intake system for vacuum leaks
            ‚Ä¢ Check fuel pressure (should be 55-65 PSI)
            ‚Ä¢ Inspect intake manifold gaskets
            ‚Ä¢ Check PCV valve and hoses
            ‚Ä¢ Test fuel injectors (may be clogged)

            DIAGNOSTIC TIP: Spray propane around intake while watching O2 voltage -
            voltage should rise if leak found.

            FORD TSB 20-2301: 2020 Explorer intake manifold gasket may leak
        """.trimIndent()

        "Intermittent code - comes and goes" -> """
            LIKELY CAUSES:
            1. Wiring harness intermittent short/open
            2. Loose connector
            3. Heat-related failure
            4. Vibration-related failure

            ADVANCED TESTS:
            ‚Ä¢ Wiggle test: Flex harness while watching live data
            ‚Ä¢ Heat gun test: Heat sensor/wiring, watch for code
            ‚Ä¢ Road test on rough roads (check for vibration-induced failure)
            ‚Ä¢ Monitor freeze frame data - look for pattern (temperature, RPM, load)
            ‚Ä¢ Check connector terminals for corrosion/bent pins

            REPAIR TIP: If wiring issue found, repair with solder and heat shrink -
            DO NOT use crimp connectors (will fail again).
        """.trimIndent()

        else -> """
            General advanced troubleshooting steps:
            1. Verify all basic checks completed (ground, power, wiring)
            2. Check for related TSBs in Ford service website
            3. Consult with senior technician or Ford hotline
            4. Consider using Ford IDS (Integrated Diagnostic System) for deeper diagnostics
            5. Document everything - intermittent issues require detailed notes
        """.trimIndent()
    }
}

/**
 * Generate diagnostic report
 */
fun generateDiagnosticReport(data: Map<String, Any?>): String {
    return """
        ========================================
        FORD EXPLORER OXYGEN SENSOR DIAGNOSTIC REPORT
        ========================================

        VEHICLE INFORMATION:
        VIN: ${data["vin"]}
        Mileage: ${data["mileage"]}
        Technician: ${data["technician_name"]}
        Date: ${java.time.LocalDateTime.now()}

        DIAGNOSTIC TROUBLE CODES:
        ${data["dtc_codes"]}

        CUSTOMER COMPLAINT:
        ${data["customer_complaint"]}

        AFFECTED SENSORS:
        ${data["affected_sensors"]}
        Bank: ${data["sensor_bank"]}
        Position: ${data["sensor_position"]}

        VISUAL INSPECTION:
        Wiring: ${data["wiring_condition"]}
        Connector: ${data["connector_condition"]}
        Sensor Physical: ${data["sensor_physical"]}
        Exhaust Leaks: ${data["exhaust_leaks"]}

        ELECTRICAL TESTING:
        Heater Resistance: ${data["heater_resistance"]}Œ© (Spec: 2-14Œ©)
        Ground Resistance: ${data["ground_resistance"]}Œ© (Spec: <0.5Œ©)
        Heater Voltage: ${data["heater_voltage"]}V (Spec: 12-14V)
        Signal Voltage (Idle): ${data["signal_voltage_idle"]}V
        Response Time: ${data["response_time"]}s (Spec: <1s)

        DIAGNOSIS:
        Root Cause: ${data["root_cause"]}
        Failure Mode: ${data["failure_mode"]}
        ${data["diagnosis"]}

        RECOMMENDED REPAIR:
        ${data["recommended_action"]}
        Estimated Cost: $${data["estimated_cost"]}

        TECHNICIAN NOTES:
        ${data["technician_notes"]}

        ========================================
    """.trimIndent()
}

/**
 * Generate invoice
 */
fun generateInvoice(data: Map<String, Any?>): String {
    return """
        REPAIR INVOICE

        VIN: ${data["vin"]}

        WORK PERFORMED:
        ${data["work_performed"]}

        PARTS USED:
        ${data["parts_used"]}

        LABOR: ${data["labor_hours"]} hours
        TOTAL: $${data["final_cost"]}
    """.trimIndent()
}
```

---

## üìä Usage Example

```kotlin
fun main() {
    // Create workflow instance
    var diagnostic = fordExplorerO2SensorDiagnostic.createInstance()

    println("=== Ford Explorer O2 Sensor Diagnostic ===")
    println("Total Steps: ${fordExplorerO2SensorDiagnostic.steps.size}")
    println()

    // Step 1: Initial Assessment
    val initialData = mapOf(
        "vin" to "1FM5K8GC8LGB12345",
        "mileage" to 45000,
        "dtc_codes" to "P0131, P0135",
        "check_engine_light" to "ON - Steady",
        "customer_complaint" to "Check engine light on, rough idle, poor fuel economy",
        "technician_name" to "Mike Johnson"
    )

    diagnostic = when (val result = diagnostic.next(initialData)) {
        is WorkflowResult.Success -> {
            println("‚úì Initial assessment complete")
            println("  Affected sensors: ${result.instance.data["affected_sensors"]}")
            println("  Probable cause: ${result.instance.data["probable_cause"]}")
            result.instance
        }
        is WorkflowResult.ValidationFailed -> {
            println("‚úó Validation failed: ${result.errors}")
            return
        }
        is WorkflowResult.Error -> {
            println("‚úó Error: ${result.message}")
            return
        }
    }

    // Continue through remaining steps...
    // (Tools check, visual inspection, electrical testing, etc.)

    // Track progress
    val progress = diagnostic.getProgress()
    println("\nProgress: ${progress.percentage}% complete")
    println("Step ${progress.currentStep}/${progress.totalSteps}")
}
```

---

## üéØ Key Features Demonstrated

### 1. **Multi-Step Diagnostic Workflow**
- 10 comprehensive steps from initial assessment to final documentation
- Conditional branching based on findings
- Skip logic for damaged components

### 2. **AVA-Generated Business Logic**
- `analyzeDTCCodes()` - Parses Ford DTC codes
- `getDiagnosisMessage()` - Maps failure modes to solutions
- `getAdvancedTroubleshootingGuidance()` - Scenario-based help
- `generateDiagnosticReport()` - Professional documentation

### 3. **Advanced Troubleshooting FAQ**
- 7 common difficult scenarios
- Based on Ford TSBs and real repair data
- Step-by-step guidance when standard procedure fails

### 4. **Real-World Integration**
- Repair management system integration
- Email notifications
- Data archival
- Invoice generation

### 5. **Safety & Quality Checks**
- Mandatory safety verification
- Spec validation (torque, resistance, voltage)
- Post-repair verification
- Customer approval workflow

---

## üí° What AVA Automated

Without AVA, the technician would need to:
1. ‚ùå Manually look up DTC codes in paper manual (15 min)
2. ‚ùå Cross-reference specifications (10 min)
3. ‚ùå Remember Ford TSB numbers (impossible)
4. ‚ùå Write diagnostic report by hand (30 min)
5. ‚ùå Look up advanced troubleshooting (variable)

With AVA:
1. ‚úÖ DTC codes parsed automatically
2. ‚úÖ Specs validated in real-time
3. ‚úÖ TSBs surfaced contextually
4. ‚úÖ Report generated automatically
5. ‚úÖ FAQ available inline

**Time saved per diagnostic**: ~1 hour
**Quality improvement**: Consistent, comprehensive diagnostics
**Knowledge transfer**: Junior techs perform like senior techs

---

This example demonstrates how AVA + AvaCode can transform complex technical procedures (like automotive diagnostics) into guided, intelligent workflows that improve speed, accuracy, and consistency! üöÄ
