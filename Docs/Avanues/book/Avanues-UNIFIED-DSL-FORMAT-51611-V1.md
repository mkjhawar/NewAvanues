# Unified DSL Format: One DSL, Two Modes

**Version:** 5.3.0
**Date:** 2025-11-02
**Author:** Manoj Jhawar, manoj@ideahq.net

**Purpose:** Clarify that IDEAMagic uses ONE unified DSL format (`.vos`) that supports BOTH runtime interpretation AND code generation.

---

## IMPORTANT: One DSL Format, Not Two!

**CORRECTED UNDERSTANDING:**

‚ùå **WRONG:** "IDEAMagic has two DSL formats: AvaUI DSL and JSON DSL"

‚úÖ **CORRECT:** "IDEAMagic has ONE unified DSL format (`.vos`) with two execution modes"

---

## The Unified AvaUI DSL Format

### Single DSL Syntax

**File Extension:** `.vos`
**Syntax:** Declarative, JavaScript-like
**Execution:** Determined by file header

### Two Execution Modes

| Mode | Header | Purpose | Execution |
|------|--------|---------|-----------|
| **Runtime** | `#!vos:D` | User apps, plugins, hot-reload | Interpreted by AvaUI Runtime |
| **Codegen** | `#!vos:K` | Production apps, best performance | Generated to Kotlin/Swift/TS |

**Key Insight:** **SAME DSL**, different execution strategy!

---

## Example: Same DSL, Two Modes

### Login Screen DSL (Single Source)

```dsl
# login.vos - Same DSL for both modes!

App {
  id: "com.example.login"
  name: "Login Screen"

  # State
  state: {
    email: ""
    password: ""
  }

  # UI
  Column {
    id: "main_column"
    spacing: 16
    padding: 24

    Text {
      id: "title"
      content: "Welcome Back"
      variant: "H1"
    }

    TextField {
      id: "email_field"
      label: "Email"
      type: "email"
      value: state.email

      onValueChange: (value) => {
        state.email = value
      }
    }

    TextField {
      id: "password_field"
      label: "Password"
      type: "password"
      value: state.password

      onValueChange: (value) => {
        state.password = value
      }
    }

    Button {
      id: "login_btn"
      text: "Sign In"
      variant: "primary"

      onClick: () => {
        handleLogin(state.email, state.password)
      }
    }
  }

  # Voice Commands
  VoiceCommands {
    "sign in" => "login_btn.click"
    "show email" => "email_field.focus"
  }
}
```

### Mode 1: Runtime Interpretation

**File:** `login.vos`
**Header:** `#!vos:D`

```dsl
#!vos:D
# Runtime Mode - Interpreted by AvaUI Runtime
# User-created app, hot-reload enabled

App {
  id: "com.example.login"
  name: "Login Screen"
  # ... (same DSL as above)
}
```

**Execution:**
```kotlin
// AvaUI Runtime interprets this directly
val runtime = AvaUIRuntime()
val app = runtime.loadApp(File("login.vos"))
runtime.start(app)
// App runs! No code generation needed
```

**Use Cases:**
- User-created apps (AVA AI generates)
- Plugins with hot-reload
- Rapid prototyping
- Dynamic UI changes

**Advantages:**
- ‚úÖ Hot-reload (instant changes)
- ‚úÖ Dynamic UI (runtime changes)
- ‚úÖ App Store compliant (data, not code)
- ‚úÖ No build step required

---

### Mode 2: Code Generation

**File:** `login.vos`
**Header:** `#!vos:K`

```dsl
#!vos:K
# Codegen Mode - Generate native code
# Production app, best performance

@Generate(
  target: "kotlin-compose",
  package: "com.example.generated",
  output: "app/src/main/kotlin/generated/"
)

App {
  id: "com.example.login"
  name: "Login Screen"
  # ... (same DSL as above)
}
```

**Code Generation:**
```bash
# AvaCode generates Kotlin Compose
avacode generate --input login.vos --output LoginScreen.kt
```

**Generated Output:** `LoginScreen.kt`
```kotlin
// Generated by AvaCode from login.vos
package com.example.generated

import androidx.compose.runtime.*
import androidx.compose.material3.*
import androidx.compose.foundation.layout.*

@Composable
fun LoginScreen() {
    var email by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text(
            text = "Welcome Back",
            style = MaterialTheme.typography.headlineLarge
        )

        OutlinedTextField(
            value = email,
            onValueChange = { email = it },
            label = { Text("Email") },
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),
            modifier = Modifier.fillMaxWidth()
        )

        OutlinedTextField(
            value = password,
            onValueChange = { password = it },
            label = { Text("Password") },
            visualTransformation = PasswordVisualTransformation(),
            modifier = Modifier.fillMaxWidth()
        )

        Button(
            onClick = { handleLogin(email, password) },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Sign In")
        }
    }
}
```

**Use Cases:**
- Production apps (developer-written)
- App Store distribution
- Best performance required
- Type safety needed

**Advantages:**
- ‚úÖ Best performance (compiled native)
- ‚úÖ Type-safe (compile-time errors)
- ‚úÖ Debuggable (native debugger)
- ‚úÖ No runtime overhead

---

## Comparison: Runtime vs Codegen

| Feature | Runtime (`#!vos:D`) | Codegen (`#!vos:K`) |
|---------|-------------------|-------------------|
| **DSL Syntax** | ‚úÖ Same | ‚úÖ Same |
| **File Extension** | `.vos` | `.vos` |
| **Execution** | Interpreted | Compiled |
| **Performance** | Good (60fps) | Best (native) |
| **Hot-Reload** | ‚úÖ Yes | ‚ùå No |
| **Dynamic UI** | ‚úÖ Yes | ‚ùå No |
| **Type Safety** | Runtime errors | Compile-time errors |
| **Build Step** | ‚ùå No | ‚úÖ Yes |
| **App Store** | ‚úÖ Compliant (data) | ‚úÖ Compliant (compiled) |
| **Target Users** | End users | Developers |
| **Created By** | AVA AI, users | Developers |

**Key Takeaway:** Write once, execute two ways!

---

## Multi-Platform Code Generation

**Same DSL generates code for ALL platforms:**

### From One `.vos` File:

```dsl
#!vos:K
# Generate for all platforms!

App {
  id: "com.example.app"
  name: "My App"

  Button {
    text: "Click Me"
    onClick: () => handleClick()
  }
}
```

### To Three Platform Outputs:

**Android (Kotlin + Compose):**
```bash
avacode generate --input app.vos --platform android --output App.kt
```
```kotlin
@Composable
fun MyApp() {
    Button(onClick = { handleClick() }) {
        Text("Click Me")
    }
}
```

**iOS (Swift + SwiftUI):**
```bash
avacode generate --input app.vos --platform ios --output App.swift
```
```swift
struct MyAppView: View {
    var body: some View {
        Button("Click Me") {
            handleClick()
        }
    }
}
```

**Web (TypeScript + React):**
```bash
avacode generate --input app.vos --platform web --output App.tsx
```
```typescript
export const MyApp: React.FC = () => {
  return (
    <Button onClick={handleClick}>
      Click Me
    </Button>
  );
};
```

**Result:** ONE DSL source ‚Üí THREE platform outputs!

---

## What About JSON DSL?

**Short Answer:** JSON DSL was a **misunderstanding/alternative format** - we should standardize on the `.vos` format.

**History:**
- Initial design had JSON for code generation
- `.vos` DSL format was created later
- Both coexist currently (confusing!)

**Recommendation:** **Deprecate JSON DSL, use `.vos` exclusively**

**Migration Path:**
```bash
# Convert JSON to .vos DSL
avacode convert --input screen.json --output screen.vos

# Add header for codegen mode
echo "#!vos:K" | cat - screen.vos > screen_final.vos
```

**Advantages of Unified Format:**
- ‚úÖ Single syntax to learn
- ‚úÖ Same file for runtime AND codegen
- ‚úÖ Better developer experience
- ‚úÖ Less confusion

---

## Framework Comparison: CORRECTED

### IDEAMagic's Unique Approach

**One DSL, Two Execution Modes:**

| Framework | DSL Format | Runtime Mode? | Codegen Mode? |
|-----------|------------|---------------|---------------|
| **IDEAMagic** | **`.vos` (unified)** | ‚úÖ `#!vos:D` | ‚úÖ `#!vos:K` |
| React Native | JSX | ‚ùå No (always runtime) | ‚ùå No |
| Flutter | Dart | ‚ùå No (always compiled) | ‚úÖ Yes (always) |
| Unity | C# | ‚ö†Ô∏è Partial (Mono) | ‚úÖ Yes (IL2CPP) |
| Swift/SwiftUI | Swift | ‚ùå No | ‚úÖ Yes (always) |
| Jetpack Compose | Kotlin | ‚ùå No | ‚úÖ Yes (always) |

**Key Insight:**
- üèÜ **IDEAMagic is the ONLY framework with BOTH runtime interpretation AND code generation from the SAME DSL**
- Other frameworks are either runtime-only (React Native) or compiled-only (Flutter, Swift, Compose)
- Unity has partial runtime (Mono) but requires C# (not user-friendly DSL)

---

## Developer Workflows

### Workflow 1: User-Created App (Runtime)

```bash
# 1. User speaks to AVA AI
User: "Create a shopping list app"

# 2. AVA AI generates .vos file
# File: shopping-list.vos
#!vos:D
App {
  id: "com.user.shoppinglist"
  name: "Shopping List"
  # ... DSL generated by AI
}

# 3. AvaUI Runtime loads and runs it
# No build step! App runs immediately
runtime.loadApp("shopping-list.vos")
```

### Workflow 2: Developer App (Codegen)

```bash
# 1. Developer writes .vos file
# File: production-app.vos
#!vos:K
App {
  id: "com.company.app"
  name: "Production App"
  # ... DSL written by developer
}

# 2. Generate native code
avacode generate --input production-app.vos --platform android
avacode generate --input production-app.vos --platform ios

# 3. Build and deploy
./gradlew :app:android:build
xcodebuild -project App.xcodeproj
```

---

## Advantages of Unified DSL

### 1. Single Syntax to Learn

**Before (Confusing):**
- Learn AvaUI DSL (`.vos`) for runtime
- Learn JSON DSL (`.json`) for codegen
- Two different formats, same purpose

**After (Clear):**
- Learn ONE AvaUI DSL (`.vos`)
- Use for both runtime AND codegen
- Just change the header: `#!vos:D` vs `#!vos:K`

### 2. Flexible Development Path

**Prototype ‚Üí Production:**
```bash
# Step 1: Rapid prototype (runtime)
echo "#!vos:D" > app.vos
# ... write DSL
# Test with hot-reload

# Step 2: Convert to production (codegen)
sed -i '1s/D/K/' app.vos  # Change header D ‚Üí K
avacode generate --input app.vos --platform android
# Same DSL, now compiled!
```

### 3. Hybrid Apps

**Mix runtime and codegen in one app:**
```dsl
#!vos:X
# Mixed mode - some runtime, some codegen

App {
  id: "com.example.hybrid"
  name: "Hybrid App"

  # User-customizable UI (runtime)
  @DSL
  UserDashboard {
    # Users can modify this at runtime
    # Changes apply without recompiling
  }

  # Core app logic (codegen)
  @Codegen(target: "kotlin-compose")
  CoreFeatures {
    # Generated as native code
    # Best performance, type-safe
  }
}
```

---

## Implementation Status

### Current State

**What Exists:**
- ‚úÖ VosParser.kt - Parses `.vos` DSL
- ‚úÖ AvaUI Runtime - Interprets DSL (`#!vos:D` mode)
- ‚ö†Ô∏è AvaCode CodeGen - EXISTS but currently uses JSON input
- ‚úÖ `.vos` file format spec - Supports both modes

**What Needs Fixing:**
- ‚ùå AvaCode should accept `.vos` files (not JSON)
- ‚ùå VosParser should support codegen mode (`#!vos:K`)
- ‚ùå CLI should detect mode from header
- ‚ùå Documentation needs updating

### Migration Plan

**Phase 1: Enable `.vos` Input for AvaCode (2 weeks)**
```kotlin
// Update CodeGeneratorFactory
fun generate(vosFile: File): GeneratedCode {
    val mode = detectMode(vosFile)  // Read header

    return when (mode) {
        VosMode.RUNTIME -> {
            // Mode D - for documentation/validation only
            throw IllegalArgumentException("Use AvaUI Runtime for mode D")
        }
        VosMode.CODEGEN -> {
            // Mode K - generate code
            val ast = VosParser(vosFile).parse()
            val generator = createGenerator(platform)
            generator.generate(ast)
        }
    }
}
```

**Phase 2: Deprecate JSON DSL (1 week)**
- Update documentation
- Add conversion tool: `avacode convert --from json --to vos`
- Migration guide for existing JSON files

**Phase 3: Update All Examples (1 week)**
- Convert all JSON examples to `.vos`
- Update documentation book
- Update code examples

**Total: 4 weeks to fully migrate**

---

## Summary

### Key Points

1. ‚úÖ **IDEAMagic has ONE unified DSL format** (`.vos`)
2. ‚úÖ **Two execution modes:** Runtime (`#!vos:D`) and Codegen (`#!vos:K`)
3. ‚úÖ **Same DSL syntax** for both modes
4. ‚ö†Ô∏è **JSON DSL should be deprecated** (confusing, unnecessary)
5. üèÜ **UNIQUE:** No other framework offers both runtime + codegen from same DSL

### Competitive Advantage

**IDEAMagic's Two-Mode DSL:**
- üèÜ **Flexibility:** Write once, execute two ways
- üèÜ **User-Friendly:** End users can write apps (runtime mode)
- üèÜ **Performance:** Developers get native code (codegen mode)
- üèÜ **Migration Path:** Prototype ‚Üí Production with same DSL

**No competitor offers this combination!**

---

## Conclusion

**The framework comparison should emphasize:**

1. **ONE unified DSL format** (`.vos`)
2. **Two execution modes** (runtime interpretation + code generation)
3. **Flexibility** (prototype fast, optimize later)
4. **User empowerment** (non-developers can create apps)
5. **Developer power** (native performance when needed)

**This is the correct understanding of IDEAMagic's architecture.**

---

**Created by Manoj Jhawar, manoj@ideahq.net**
