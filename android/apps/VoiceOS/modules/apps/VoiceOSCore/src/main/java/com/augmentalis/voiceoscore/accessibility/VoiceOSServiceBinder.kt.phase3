/**
 * VoiceOSServiceBinder.kt - IPC service binder implementation for VoiceOSService
 *
 * Copyright (C) Manoj Jhawar/Aman Jhawar, Intelligent Devices LLC
 * Author: AI Code Quality Expert
 * Created: 2025-11-10
 */
package com.augmentalis.voiceoscore.accessibility

import android.os.RemoteCallbackList
import android.os.RemoteException
import android.util.Log
import com.google.gson.Gson
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch

/**
 * VoiceOS Service AIDL implementation
 *
 * Exposes VoiceOSService functionality via IPC for use by external apps.
 * This binder wraps the VoiceOSService and provides thread-safe access
 * to its functionality across process boundaries.
 *
 * Features:
 * - Thread-safe callback management with RemoteCallbackList
 * - Automatic callback cleanup on client death
 * - Error handling and logging
 * - JSON-based data serialization
 * - Coroutine support for async operations
 *
 * Usage:
 * ```kotlin
 * // In VoiceOSService.onBind()
 * private var serviceBinder: VoiceOSServiceBinder? = null
 *
 * override fun onBind(intent: Intent?): IBinder? {
 *     return when (intent?.action) {
 *         "com.augmentalis.voiceoscore.BIND_IPC" -> {
 *             serviceBinder = VoiceOSServiceBinder(this)
 *             serviceBinder!!.asBinder()
 *         }
 *         else -> super.onBind(intent)
 *     }
 * }
 * ```
 */
class VoiceOSServiceBinder(
    private val service: VoiceOSService
) : IVoiceOSService.Stub() {

    companion object {
        private const val TAG = "VoiceOSServiceBinder"
    }

    /**
     * Thread-safe callback list
     *
     * RemoteCallbackList automatically handles:
     * - Client process death detection
     * - Callback cleanup
     * - Thread-safe iteration
     */
    private val callbacks = RemoteCallbackList<IVoiceOSCallback>()

    /**
     * Coroutine scope for async operations
     */
    private val scope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    /**
     * JSON serializer for status and data
     */
    private val gson = Gson()

    /**
     * Check if VoiceOS service is currently running and ready
     *
     * @return true if service is active and ready, false otherwise
     */
    override fun isServiceReady(): Boolean {
        Log.d(TAG, "IPC: isServiceReady() called")
        return try {
            VoiceOSService.isServiceRunning() && service.isServiceReady
        } catch (e: Exception) {
            Log.e(TAG, "Error checking service ready state", e)
            false
        }
    }

    /**
     * Execute a system voice command
     *
     * Delegates to VoiceOSService.executeCommand() which handles:
     * - back, go back
     * - home, go home
     * - recent, recent apps
     * - notifications
     * - settings, quick settings
     * - power, power menu
     * - screenshot
     *
     * @param commandText The voice command to execute
     * @return true if command executed successfully, false otherwise
     */
    override fun executeCommand(commandText: String): Boolean {
        Log.d(TAG, "IPC: executeCommand($commandText)")

        return try {
            val startTime = System.currentTimeMillis()
            val success = VoiceOSService.executeCommand(commandText)
            val executionTime = System.currentTimeMillis() - startTime

            // Notify callbacks
            notifyCommandExecuted(commandText, success, executionTime)

            success
        } catch (e: Exception) {
            Log.e(TAG, "Error executing command: $commandText", e)
            notifyCommandExecuted(commandText, false, 0, e.message)
            false
        }
    }

    /**
     * Execute custom accessibility action
     *
     * Placeholder for future custom action support.
     * Currently returns false as ActionCoordinator integration is pending.
     *
     * @param actionType Action type identifier (e.g., "click", "scroll", "swipe")
     * @param parameters JSON string containing action parameters
     * @return true if action executed successfully, false otherwise
     */
    override fun executeAccessibilityAction(actionType: String, parameters: String): Boolean {
        Log.d(TAG, "IPC: executeAccessibilityAction($actionType, $parameters)")

        // TODO: Integrate with ActionCoordinator when API is available
        Log.w(TAG, "executeAccessibilityAction not yet implemented - pending ActionCoordinator integration")
        return false
    }

    /**
     * Request UI scraping of current screen
     *
     * Triggers accessibility tree scraping and returns scraped elements as JSON.
     *
     * Placeholder for future scraping integration.
     * Requires AccessibilityScrapingIntegration API exposure.
     *
     * @return JSON string containing scraped UI elements
     */
    override fun scrapeCurrentScreen(): String {
        Log.d(TAG, "IPC: scrapeCurrentScreen() called")

        // TODO: Integrate with AccessibilityScrapingIntegration when API is available
        Log.w(TAG, "scrapeCurrentScreen not yet implemented - pending AccessibilityScrapingIntegration API")

        return gson.toJson(mapOf(
            "status" to "not_implemented",
            "message" to "Scraping API integration pending"
        ))
    }

    /**
     * Register callback for service events
     *
     * Client will receive events via IVoiceOSCallback:
     * - onCommandRecognized(command, confidence)
     * - onCommandExecuted(command, success, message)
     * - onServiceStateChanged(state, message)
     * - onScrapingComplete(elementsJson, elementCount)
     *
     * Callbacks are automatically cleaned up when client process dies.
     *
     * @param callback Callback interface to receive service events
     */
    override fun registerCallback(callback: IVoiceOSCallback?) {
        if (callback == null) {
            Log.w(TAG, "IPC: registerCallback called with null callback")
            return
        }

        try {
            callbacks.register(callback)
            Log.d(TAG, "IPC: Callback registered successfully")

            // Send initial service state
            callback.onServiceStateChanged(
                if (isServiceReady()) 2 else 0, // 2 = ready, 0 = stopped
                "Service connected"
            )
        } catch (e: RemoteException) {
            Log.e(TAG, "Error registering callback", e)
        }
    }

    /**
     * Unregister previously registered callback
     *
     * @param callback Callback interface to unregister
     */
    override fun unregisterCallback(callback: IVoiceOSCallback?) {
        if (callback == null) {
            Log.w(TAG, "IPC: unregisterCallback called with null callback")
            return
        }

        try {
            val removed = callbacks.unregister(callback)
            Log.d(TAG, "IPC: Callback unregistered: $removed")
        } catch (e: Exception) {
            Log.e(TAG, "Error unregistering callback", e)
        }
    }

    /**
     * Get service status information
     *
     * Returns JSON with current service state:
     * - isReady: boolean
     * - isRunning: boolean
     * - timestamp: long
     *
     * @return JSON string with service status details
     */
    override fun getServiceStatus(): String {
        Log.d(TAG, "IPC: getServiceStatus() called")

        val status = mapOf(
            "isReady" to isServiceReady(),
            "isRunning" to VoiceOSService.isServiceRunning(),
            "timestamp" to System.currentTimeMillis()
        )

        return gson.toJson(status)
    }

    /**
     * Get available voice commands
     *
     * Returns list of supported system commands.
     *
     * @return List of available voice command strings
     */
    override fun getAvailableCommands(): List<String> {
        Log.d(TAG, "IPC: getAvailableCommands() called")

        return listOf(
            "back", "go back",
            "home", "go home",
            "recent", "recent apps",
            "notifications",
            "settings", "quick settings",
            "power", "power menu",
            "screenshot"
        )
    }

    // ============================================================================
    // Callback Notification Methods
    // ============================================================================

    /**
     * Notify all registered callbacks that a command was recognized
     *
     * @param command The recognized command text
     * @param confidence Confidence score (0.0 to 1.0)
     */
    fun notifyCommandRecognized(command: String, confidence: Float) {
        scope.launch {
            broadcastCallback { callback ->
                callback.onCommandRecognized(command, confidence)
            }
        }
    }

    /**
     * Notify all registered callbacks that a command execution completed
     *
     * @param command The executed command
     * @param success true if command succeeded, false otherwise
     * @param executionTime Execution time in milliseconds
     * @param errorMessage Optional error message
     */
    private fun notifyCommandExecuted(
        command: String,
        success: Boolean,
        executionTime: Long,
        errorMessage: String? = null
    ) {
        scope.launch {
            val message = if (success) {
                "Command executed in ${executionTime}ms"
            } else {
                errorMessage ?: "Command execution failed"
            }

            broadcastCallback { callback ->
                callback.onCommandExecuted(command, success, message)
            }
        }
    }

    /**
     * Notify all registered callbacks of service state change
     *
     * @param state New state (0=stopped, 1=starting, 2=ready, 3=error)
     * @param message State description message
     */
    fun notifyServiceStateChanged(state: Int, message: String) {
        scope.launch {
            broadcastCallback { callback ->
                callback.onServiceStateChanged(state, message)
            }
        }
    }

    /**
     * Notify all registered callbacks that UI scraping completed
     *
     * @param elementsJson JSON string containing scraped elements
     * @param elementCount Number of elements scraped
     */
    fun notifyScrapingComplete(elementsJson: String, elementCount: Int) {
        scope.launch {
            broadcastCallback { callback ->
                callback.onScrapingComplete(elementsJson, elementCount)
            }
        }
    }

    /**
     * Broadcast to all registered callbacks
     *
     * Thread-safe iteration with automatic cleanup of dead callbacks.
     *
     * @param block Callback invocation block
     */
    private inline fun broadcastCallback(crossinline block: (IVoiceOSCallback) -> Unit) {
        val count = callbacks.beginBroadcast()
        try {
            for (i in 0 until count) {
                try {
                    val callback = callbacks.getBroadcastItem(i)
                    block(callback)
                } catch (e: RemoteException) {
                    Log.w(TAG, "Error invoking callback (client may have died)", e)
                } catch (e: Exception) {
                    Log.e(TAG, "Unexpected error invoking callback", e)
                }
            }
        } finally {
            callbacks.finishBroadcast()
        }
    }

    // ============================================================
    // Phase 3: Extended IPC Methods
    // ============================================================

    /**
     * Start voice recognition with specified configuration
     * Phase 3: Initial implementation
     */
    override fun startVoiceRecognition(language: String, recognizerType: String): Boolean {
        Log.d(TAG, "IPC: startVoiceRecognition(language=$language, type=$recognizerType)")
        return try {
            service.startVoiceRecognition(language, recognizerType)
        } catch (e: Exception) {
            Log.e(TAG, "Error starting voice recognition via IPC", e)
            false
        }
    }

    /**
     * Stop currently active voice recognition
     * Phase 3: Initial implementation
     */
    override fun stopVoiceRecognition(): Boolean {
        Log.d(TAG, "IPC: stopVoiceRecognition()")
        return try {
            service.stopVoiceRecognition()
        } catch (e: Exception) {
            Log.e(TAG, "Error stopping voice recognition via IPC", e)
            false
        }
    }

    /**
     * Trigger app learning for currently focused app
     * Phase 3: Initial implementation
     */
    override fun learnCurrentApp(): String {
        Log.d(TAG, "IPC: learnCurrentApp()")
        return try {
            service.learnCurrentApp()
        } catch (e: Exception) {
            Log.e(TAG, "Error learning current app via IPC", e)
            """{"error": "${e.message}"}"""
        }
    }

    /**
     * Get list of apps that have learned voice commands
     * Phase 3: Stub implementation
     */
    override fun getLearnedApps(): List<String> {
        Log.d(TAG, "IPC: getLearnedApps()")
        return try {
            service.getLearnedApps()
        } catch (e: Exception) {
            Log.e(TAG, "Error getting learned apps via IPC", e)
            emptyList()
        }
    }

    /**
     * Get voice commands available for specific app
     * Phase 3: Stub implementation
     */
    override fun getCommandsForApp(packageName: String): List<String> {
        Log.d(TAG, "IPC: getCommandsForApp(packageName=$packageName)")
        return try {
            service.getCommandsForApp(packageName)
        } catch (e: Exception) {
            Log.e(TAG, "Error getting commands for app via IPC", e)
            emptyList()
        }
    }

    /**
     * Register dynamic voice command at runtime
     * Phase 3: Initial implementation
     */
    override fun registerDynamicCommand(commandText: String, actionJson: String): Boolean {
        Log.d(TAG, "IPC: registerDynamicCommand(command=$commandText)")
        return try {
            service.registerDynamicCommand(commandText, actionJson)
        } catch (e: Exception) {
            Log.e(TAG, "Error registering dynamic command via IPC", e)
            false
        }
    }

    /**
     * Cleanup resources
     *
     * Should be called when service is being destroyed.
     */
    fun cleanup() {
        try {
            callbacks.kill()
            Log.d(TAG, "Callbacks cleaned up")
        } catch (e: Exception) {
            Log.e(TAG, "Error cleaning up callbacks", e)
        }
    }
}
