package com.augmentalis.voiceoscore

/**
 * AVU Serializer - Serializes and parses AVU (Avanues Universal) format.
 *
 * The AVU format is a line-based compact format for voice accessibility data.
 *
 * Format Structure:
 * ```
 * # Avanues Universal Format v1.0
 * # Type: VOS
 * ---
 * schema: avu-1.0
 * version: 1.0.0
 * metadata:
 *   file: com.app.package.vos
 *   category: learned_app
 * ---
 * APP:package:name:timestamp
 * STA:screens:elements:commands:avg_depth:max_depth:coverage
 * SCR:hash:activity:timestamp:element_count
 * ELM:uuid:label:type:actions:bounds:category
 * NAV:from_hash:to_hash:trigger_uuid:trigger_label:timestamp
 * CMD:uuid:trigger:action:element_uuid:confidence
 * ```
 */
object AVUSerializer {

    private const val SCHEMA_VERSION = "avu-1.0"
    private const val FORMAT_VERSION = "1.0.0"
    private const val LOCALE = "en-US"
    private const val PROJECT = "voiceos"

    /**
     * Serialize QuantizedContext to AVU format string.
     *
     * @param context The context to serialize
     * @param stats Optional exploration statistics
     * @return AVU format string
     */
    fun serialize(
        context: QuantizedContext,
        stats: ExplorationStats? = null
    ): String = buildString {
        // Header comments
        appendLine("# Avanues Universal Format v1.0")
        appendLine("# Type: VOS")
        appendLine("# Extension: .vos")
        appendLine("# Generated by: VoiceOSCoreNG")

        // Schema section
        appendLine("---")
        appendLine("schema: $SCHEMA_VERSION")
        appendLine("version: $FORMAT_VERSION")
        appendLine("locale: $LOCALE")
        appendLine("project: $PROJECT")
        appendLine("metadata:")
        appendLine("  file: ${context.packageName}.vos")
        appendLine("  category: learned_app")
        appendLine("  count: ${countDataLines(context)}")

        // Data section
        appendLine("---")

        // APP line
        appendLine(context.toAppLine())

        // STA line (statistics)
        val explorationStats = stats ?: calculateStats(context)
        appendLine(explorationStats.toStaLine())

        // SCR and ELM lines
        for (screen in context.screens) {
            appendLine(screen.toScrLine())
            for (element in screen.elements) {
                appendLine(element.toElmLine())
            }
        }

        // NAV lines
        for (nav in context.navigation) {
            appendLine(nav.toNavLine())
        }

        // CMD lines
        for (cmd in context.knownCommands) {
            appendLine(cmd.toCmdLine())
        }
    }

    /**
     * Parse AVU format string to QuantizedContext.
     *
     * @param avu AVU format string
     * @return QuantizedContext or null if parsing fails
     */
    fun parse(avu: String): QuantizedContext? {
        if (avu.isBlank()) return null
        if (!isValidAVU(avu)) return null

        try {
            val lines = avu.lines()
            var section = "header"

            var packageName = ""
            var appName = ""
            var generatedAt = 0L

            val screens = mutableListOf<QuantizedScreen>()
            var currentScreenHash: String? = null
            var currentScreenTitle: String? = null
            var currentActivityName: String? = null
            var currentElements = mutableListOf<QuantizedElement>()

            val navigation = mutableListOf<QuantizedNavigation>()
            val commands = mutableListOf<QuantizedCommand>()
            val vocabulary = mutableSetOf<String>()

            for (line in lines) {
                val trimmed = line.trim()

                // Skip empty lines and comments
                if (trimmed.isEmpty() || trimmed.startsWith("#")) continue

                // Section delimiter
                if (trimmed == "---") {
                    section = when (section) {
                        "header" -> "schema"
                        "schema" -> "data"
                        else -> section
                    }
                    continue
                }

                // Parse data section
                if (section == "data") {
                    parseDataLine(trimmed)?.let { parsed ->
                        when (parsed) {
                            is ParsedApp -> {
                                packageName = parsed.packageName
                                appName = parsed.appName
                                generatedAt = parsed.timestamp
                            }
                            is ParsedScreen -> {
                                // Save previous screen if exists
                                currentScreenHash?.let { hash ->
                                    screens.add(
                                        QuantizedScreen(
                                            hash,
                                            currentScreenTitle ?: "",
                                            currentActivityName,
                                            currentElements.toList()
                                        )
                                    )
                                    currentElements.clear()
                                }
                                currentScreenHash = parsed.screenHash
                                currentScreenTitle = parsed.activityName
                                currentActivityName = parsed.activityName
                            }
                            is ParsedElement -> {
                                currentElements.add(parsed.element)
                                vocabulary.add(parsed.element.label)
                            }
                            is ParsedNavigation -> {
                                navigation.add(parsed.navigation)
                            }
                            is ParsedCommand -> {
                                commands.add(parsed.command)
                            }
                        }
                    }
                }
            }

            // Add last screen
            currentScreenHash?.let { hash ->
                screens.add(
                    QuantizedScreen(
                        hash,
                        currentScreenTitle ?: "",
                        currentActivityName,
                        currentElements.toList()
                    )
                )
            }

            if (packageName.isBlank()) return null

            return QuantizedContext(
                packageName = packageName,
                appName = appName,
                versionCode = 0L,
                versionName = "unknown",
                generatedAt = generatedAt,
                screens = screens,
                navigation = navigation,
                vocabulary = vocabulary,
                knownCommands = commands
            )

        } catch (e: Exception) {
            return null
        }
    }

    /**
     * Parse statistics from AVU format.
     *
     * @param avu AVU format string
     * @return ExplorationStats or null if not found
     */
    fun parseStats(avu: String): ExplorationStats? {
        val staLine = avu.lines().find { it.trim().startsWith("STA:") }
        return staLine?.let { ExplorationStats.fromStaLine(it.trim()) }
    }

    /**
     * Validate AVU format.
     *
     * @param avu String to validate
     * @return true if valid AVU format
     */
    fun isValidAVU(avu: String): Boolean {
        if (avu.isBlank()) return false

        val lines = avu.lines()

        // Must have header
        val hasHeader = lines.any {
            it.contains("Avanues Universal Format")
        }
        if (!hasHeader) return false

        // Must have schema
        val hasSchema = lines.any {
            it.trim().startsWith("schema:")
        }
        if (!hasSchema) return false

        return true
    }

    // ==================== Private Helpers ====================

    private fun countDataLines(context: QuantizedContext): Int {
        var count = 1 // APP line
        count += 1 // STA line
        count += context.screens.size // SCR lines
        count += context.screens.sumOf { it.elements.size } // ELM lines
        count += context.navigation.size // NAV lines
        count += context.knownCommands.size // CMD lines
        return count
    }

    private fun calculateStats(context: QuantizedContext): ExplorationStats {
        return ExplorationStats(
            screenCount = context.screens.size,
            elementCount = context.screens.sumOf { it.elements.size },
            commandCount = context.knownCommands.size,
            avgDepth = 2.0f, // Default
            maxDepth = 4, // Default
            coverage = 0.5f // Default
        )
    }

    private sealed class ParsedLine
    private data class ParsedApp(val packageName: String, val appName: String, val timestamp: Long) : ParsedLine()
    private data class ParsedScreen(val screenHash: String, val activityName: String, val timestamp: Long) : ParsedLine()
    private data class ParsedElement(val element: QuantizedElement) : ParsedLine()
    private data class ParsedNavigation(val navigation: QuantizedNavigation) : ParsedLine()
    private data class ParsedCommand(val command: QuantizedCommand) : ParsedLine()

    private fun parseDataLine(line: String): ParsedLine? {
        val code = line.substringBefore(":")
        val content = line.substring(code.length + 1)
        val parts = content.split(":")

        return when (code) {
            "APP" -> {
                if (parts.size >= 3) {
                    ParsedApp(
                        packageName = parts[0],
                        appName = parts[1],
                        timestamp = parts[2].toLongOrNull() ?: 0L
                    )
                } else null
            }
            "SCR" -> {
                if (parts.size >= 3) {
                    ParsedScreen(
                        screenHash = parts[0],
                        activityName = parts[1],
                        timestamp = parts[2].toLongOrNull() ?: 0L
                    )
                } else null
            }
            "ELM" -> {
                if (parts.size >= 4) {
                    ParsedElement(
                        QuantizedElement(
                            avid = parts[0],
                            label = parts[1],
                            type = try {
                                ElementType.valueOf(parts[2])
                            } catch (e: Exception) {
                                ElementType.OTHER
                            },
                            actions = parts.getOrNull(3) ?: "",
                            bounds = parts.getOrNull(4) ?: "",
                            category = parts.getOrNull(5) ?: ""
                        )
                    )
                } else null
            }
            "NAV" -> {
                if (parts.size >= 5) {
                    ParsedNavigation(
                        QuantizedNavigation(
                            fromScreenHash = parts[0],
                            toScreenHash = parts[1],
                            triggerVuid = parts[2],
                            triggerLabel = parts[3],
                            timestamp = parts[4].toLongOrNull() ?: 0L
                        )
                    )
                } else null
            }
            "CMD" -> {
                if (parts.size >= 5) {
                    ParsedCommand(
                        QuantizedCommand(
                            avid = parts[0],
                            phrase = parts[1],
                            actionType = CommandActionType.fromString(parts[2]),
                            targetAvid = parts[3].takeIf { it.isNotBlank() },
                            confidence = parts[4].toFloatOrNull() ?: 0f
                        )
                    )
                } else null
            }
            else -> null
        }
    }
}
