// filename: Universal/AVA/Features/RAG/src/androidTest/kotlin/com/augmentalis/ava/features/rag/RAGPerformanceBenchmark.kt
// created: 2025-11-22
// author: AVA AI Team - Testing Phase 2.0
// © Augmentalis Inc, Intelligent Devices LLC

package com.augmentalis.ava.features.rag

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.augmentalis.ava.features.rag.data.SQLiteRAGRepository
import com.augmentalis.ava.features.rag.domain.*
import com.augmentalis.ava.features.rag.embeddings.EmbeddingProvider
import com.augmentalis.ava.features.rag.parser.TextChunker
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.Assert.*
import timber.log.Timber
import java.io.File
import kotlin.system.measureTimeMillis

/**
 * Performance benchmarks for RAG module
 *
 * Measures and documents:
 * - Document ingestion time
 * - Search latency
 * - Memory usage
 * - Chunking performance
 * - Embedding generation speed
 * - Database query performance
 *
 * Part of: RAG Phase 2.0 - Testing (90% coverage target)
 */
@RunWith(AndroidJUnit4::class)
class RAGPerformanceBenchmark {

    private lateinit var context: Context
    private lateinit var repository: SQLiteRAGRepository
    private lateinit var mockEmbeddingProvider: MockEmbeddingProvider
    private val testResults = mutableMapOf<String, BenchmarkResult>()

    @Before
    fun setup() {
        context = ApplicationProvider.getApplicationContext()
        mockEmbeddingProvider = MockEmbeddingProvider()

        repository = SQLiteRAGRepository(
            context = context,
            embeddingProvider = mockEmbeddingProvider,
            chunkingConfig = ChunkingConfig(
                strategy = ChunkingStrategy.FIXED_SIZE,
                maxTokens = 100,
                overlapTokens = 10
            ),
            enableClustering = true
        )

        Timber.plant(Timber.DebugTree())
    }

    @After
    fun tearDown() = runBlocking {
        repository.clearAll()

        // Clear database
        val dbFile = context.getDatabasePath("rag_database")
        dbFile.delete()

        // Print benchmark results
        printBenchmarkResults()
    }

    // ========== INGESTION PERFORMANCE ==========

    @Test
    fun benchmarkSmallDocumentIngestion() = runBlocking {
        val file = createTestFile("small-doc.txt", 1_000)  // 1KB

        val time = measureTimeMillis {
            repository.addDocument(
                AddDocumentRequest(filePath = file.absolutePath, title = "Small Doc")
            )
        }

        testResults["Small Document Ingestion (1KB)"] = BenchmarkResult(
            operationName = "Add 1KB document",
            timeMs = time,
            targetMs = 100,
            memoryUsedKB = 0L  // TODO: Measure actual memory
        )

        assertTrue("Small doc ingestion should be < 100ms", time < 100)
        Timber.d("Small document ingestion: ${time}ms")

        file.delete()
    }

    @Test
    fun benchmarkMediumDocumentIngestion() = runBlocking {
        val file = createTestFile("medium-doc.txt", 100_000)  // 100KB

        val time = measureTimeMillis {
            repository.addDocument(
                AddDocumentRequest(filePath = file.absolutePath, title = "Medium Doc")
            )
        }

        testResults["Medium Document Ingestion (100KB)"] = BenchmarkResult(
            operationName = "Add 100KB document",
            timeMs = time,
            targetMs = 500,
            memoryUsedKB = 0L
        )

        assertTrue("Medium doc ingestion should be < 500ms", time < 500)
        Timber.d("Medium document ingestion: ${time}ms")

        file.delete()
    }

    @Test
    fun benchmarkLargeDocumentIngestion() = runBlocking {
        val file = createTestFile("large-doc.txt", 1_000_000)  // 1MB

        val time = measureTimeMillis {
            repository.addDocument(
                AddDocumentRequest(filePath = file.absolutePath, title = "Large Doc")
            )
        }

        testResults["Large Document Ingestion (1MB)"] = BenchmarkResult(
            operationName = "Add 1MB document",
            timeMs = time,
            targetMs = 2000,
            memoryUsedKB = 0L
        )

        assertTrue("Large doc ingestion should be < 2000ms", time < 2000)
        Timber.d("Large document ingestion: ${time}ms")

        file.delete()
    }

    // ========== SEARCH PERFORMANCE ==========

    @Test
    fun benchmarkSearchLatency() = runBlocking {
        // Add test document
        val file = createTestFile("search-test.txt", 10_000)
        repository.addDocument(AddDocumentRequest(filePath = file.absolutePath))

        // Warm-up search
        repository.search(SearchQuery(query = "test", maxResults = 10))

        // Benchmark search
        val time = measureTimeMillis {
            repository.search(SearchQuery(query = "performance test", maxResults = 10))
        }

        testResults["Search Latency"] = BenchmarkResult(
            operationName = "Search with 10 results",
            timeMs = time,
            targetMs = 50,
            memoryUsedKB = 0L
        )

        assertTrue("Search should be < 50ms", time < 50)
        Timber.d("Search latency: ${time}ms")

        file.delete()
    }

    @Test
    fun benchmarkSearchWithMultipleDocuments() = runBlocking {
        // Add 10 documents
        val files = (1..10).map { i ->
            createTestFile("doc-$i.txt", 5_000).also { file ->
                repository.addDocument(
                    AddDocumentRequest(filePath = file.absolutePath, title = "Doc $i")
                )
            }
        }

        // Benchmark search across all documents
        val time = measureTimeMillis {
            repository.search(SearchQuery(query = "content", maxResults = 20))
        }

        testResults["Multi-Document Search (10 docs)"] = BenchmarkResult(
            operationName = "Search 10 documents",
            timeMs = time,
            targetMs = 100,
            memoryUsedKB = 0L
        )

        assertTrue("Multi-doc search should be < 100ms", time < 100)
        Timber.d("Multi-document search: ${time}ms")

        files.forEach { it.delete() }
    }

    @Test
    fun benchmarkConsecutiveSearches() = runBlocking {
        val file = createTestFile("consecutive-test.txt", 10_000)
        repository.addDocument(AddDocumentRequest(filePath = file.absolutePath))

        val queries = listOf("test", "performance", "content", "document", "search")

        val totalTime = measureTimeMillis {
            queries.forEach { query ->
                repository.search(SearchQuery(query = query, maxResults = 10))
            }
        }

        val avgTime = totalTime / queries.size

        testResults["Consecutive Searches (5 queries)"] = BenchmarkResult(
            operationName = "5 consecutive searches",
            timeMs = totalTime,
            targetMs = 250,
            memoryUsedKB = 0L
        )

        assertTrue("Average search time should be < 50ms", avgTime < 50)
        Timber.d("Consecutive searches: ${totalTime}ms total, ${avgTime}ms avg")

        file.delete()
    }

    // ========== CHUNKING PERFORMANCE ==========

    @Test
    fun benchmarkChunking() = runBlocking {
        val chunker = TextChunker(
            config = ChunkingConfig(
                strategy = ChunkingStrategy.FIXED_SIZE,
                maxTokens = 100,
                overlapTokens = 10
            )
        )

        val text = "This is a test sentence. ".repeat(1000)  // ~5000 words
        val parsedDoc = ParsedDocument(
            text = text,
            sections = emptyList(),
            pages = emptyList()
        )

        val document = createDummyDocument()

        val time = measureTimeMillis {
            chunker.chunk(document, parsedDoc)
        }

        testResults["Chunking (5000 words)"] = BenchmarkResult(
            operationName = "Chunk 5000 words",
            timeMs = time,
            targetMs = 200,
            memoryUsedKB = 0L
        )

        assertTrue("Chunking should be < 200ms", time < 200)
        Timber.d("Chunking performance: ${time}ms")
    }

    // ========== EMBEDDING PERFORMANCE ==========

    @Test
    fun benchmarkSingleEmbedding() = runBlocking {
        val text = "This is a test sentence for embedding generation."

        val time = measureTimeMillis {
            mockEmbeddingProvider.embed(text)
        }

        testResults["Single Embedding"] = BenchmarkResult(
            operationName = "Generate 1 embedding",
            timeMs = time,
            targetMs = 10,
            memoryUsedKB = 0L
        )

        assertTrue("Single embedding should be < 10ms", time < 10)
        Timber.d("Single embedding: ${time}ms")
    }

    @Test
    fun benchmarkBatchEmbedding() = runBlocking {
        val texts = (1..100).map { "Test sentence number $it for batch embedding." }

        val time = measureTimeMillis {
            mockEmbeddingProvider.embedBatch(texts)
        }

        val avgTime = time / texts.size

        testResults["Batch Embedding (100 items)"] = BenchmarkResult(
            operationName = "Generate 100 embeddings",
            timeMs = time,
            targetMs = 500,
            memoryUsedKB = 0L
        )

        assertTrue("Batch embedding should be < 500ms", time < 500)
        Timber.d("Batch embedding: ${time}ms total, ${avgTime}ms avg")
    }

    // ========== DATABASE PERFORMANCE ==========

    @Test
    fun benchmarkDatabaseInsertion() = runBlocking {
        val file = createTestFile("db-insert.txt", 10_000)

        val time = measureTimeMillis {
            repository.addDocument(AddDocumentRequest(filePath = file.absolutePath))
        }

        testResults["Database Insertion"] = BenchmarkResult(
            operationName = "Insert document to DB",
            timeMs = time,
            targetMs = 100,
            memoryUsedKB = 0L
        )

        assertTrue("DB insertion should be < 100ms", time < 100)
        Timber.d("Database insertion: ${time}ms")

        file.delete()
    }

    @Test
    fun benchmarkDatabaseQuery() = runBlocking {
        // Add documents
        val files = (1..5).map { i ->
            createTestFile("query-$i.txt", 5_000).also { file ->
                repository.addDocument(AddDocumentRequest(filePath = file.absolutePath))
            }
        }

        // Benchmark list query
        val time = measureTimeMillis {
            kotlinx.coroutines.flow.toList(repository.listDocuments())
        }

        testResults["Database Query (List)"] = BenchmarkResult(
            operationName = "List all documents",
            timeMs = time,
            targetMs = 50,
            memoryUsedKB = 0L
        )

        assertTrue("DB query should be < 50ms", time < 50)
        Timber.d("Database query: ${time}ms")

        files.forEach { it.delete() }
    }

    @Test
    fun benchmarkStatisticsQuery() = runBlocking {
        // Add some documents
        val file = createTestFile("stats.txt", 5_000)
        repository.addDocument(AddDocumentRequest(filePath = file.absolutePath))

        val time = measureTimeMillis {
            repository.getStatistics()
        }

        testResults["Statistics Query"] = BenchmarkResult(
            operationName = "Get RAG statistics",
            timeMs = time,
            targetMs = 50,
            memoryUsedKB = 0L
        )

        assertTrue("Statistics query should be < 50ms", time < 50)
        Timber.d("Statistics query: ${time}ms")

        file.delete()
    }

    // ========== MEMORY PERFORMANCE ==========

    @Test
    fun benchmarkMemoryUsage() = runBlocking {
        val runtime = Runtime.getRuntime()
        val beforeMemory = runtime.totalMemory() - runtime.freeMemory()

        // Add multiple documents
        val files = (1..10).map { i ->
            createTestFile("mem-$i.txt", 10_000).also { file ->
                repository.addDocument(AddDocumentRequest(filePath = file.absolutePath))
            }
        }

        // Force garbage collection
        runtime.gc()
        Thread.sleep(100)

        val afterMemory = runtime.totalMemory() - runtime.freeMemory()
        val memoryIncrease = (afterMemory - beforeMemory) / 1024  // KB

        testResults["Memory Usage (10 docs)"] = BenchmarkResult(
            operationName = "Memory for 10 documents",
            timeMs = 0,
            targetMs = 0,
            memoryUsedKB = memoryIncrease
        )

        Timber.d("Memory increase: ${memoryIncrease}KB")

        files.forEach { it.delete() }
    }

    // ========== CONCURRENT OPERATIONS ==========

    @Test
    fun benchmarkConcurrentSearches() = runBlocking {
        val file = createTestFile("concurrent.txt", 10_000)
        repository.addDocument(AddDocumentRequest(filePath = file.absolutePath))

        // Launch concurrent searches
        val time = measureTimeMillis {
            val jobs = (1..5).map { i ->
                kotlinx.coroutines.async {
                    repository.search(SearchQuery(query = "test $i", maxResults = 10))
                }
            }

            jobs.forEach { it.await() }
        }

        testResults["Concurrent Searches (5)"] = BenchmarkResult(
            operationName = "5 concurrent searches",
            timeMs = time,
            targetMs = 200,
            memoryUsedKB = 0L
        )

        assertTrue("Concurrent searches should be < 200ms", time < 200)
        Timber.d("Concurrent searches: ${time}ms")

        file.delete()
    }

    // ========== HELPER METHODS ==========

    private fun createTestFile(filename: String, sizeBytes: Int): File {
        val file = File(context.cacheDir, filename)
        val content = buildString {
            val sentence = "This is a test sentence with some content. "
            while (length < sizeBytes) {
                append(sentence)
            }
        }
        file.writeText(content)
        return file
    }

    private fun createDummyDocument(): Document {
        return Document(
            id = "dummy-doc",
            title = "Dummy Document",
            filePath = "/dummy.txt",
            fileType = DocumentType.TXT,
            sizeBytes = 1000,
            createdAt = kotlinx.datetime.Clock.System.now(),
            modifiedAt = kotlinx.datetime.Clock.System.now()
        )
    }

    private fun printBenchmarkResults() {
        Timber.d("========== RAG PERFORMANCE BENCHMARK RESULTS ==========")
        Timber.d("")

        testResults.forEach { (name, result) ->
            val status = if (result.targetMs == 0L || result.timeMs <= result.targetMs) {
                "✓ PASS"
            } else {
                "✗ FAIL"
            }

            Timber.d("$status | $name")
            Timber.d("  Operation: ${result.operationName}")
            Timber.d("  Time: ${result.timeMs}ms" +
                    if (result.targetMs > 0) " (target: ${result.targetMs}ms)" else "")

            if (result.memoryUsedKB > 0) {
                Timber.d("  Memory: ${result.memoryUsedKB}KB")
            }
            Timber.d("")
        }

        Timber.d("========== END BENCHMARK RESULTS ==========")
    }

    // ========== DATA CLASSES ==========

    data class BenchmarkResult(
        val operationName: String,
        val timeMs: Long,
        val targetMs: Long,
        val memoryUsedKB: Long
    )

    // ========== MOCK EMBEDDING PROVIDER ==========

    private class MockEmbeddingProvider : EmbeddingProvider {
        override suspend fun embed(text: String): Result<Embedding> {
            val dimension = 384
            val hash = text.hashCode()
            val values = FloatArray(dimension) { i ->
                ((hash + i) % 1000) / 1000f
            }
            return Result.success(Embedding.Float32(values))
        }

        override suspend fun embedBatch(texts: List<String>): Result<List<Embedding>> {
            return Result.success(texts.map { embed(it).getOrThrow() })
        }

        override val dimension: Int = 384
        override val isReady: Boolean = true

        override suspend fun initialize(): Result<Unit> = Result.success(Unit)
        override fun close() {}
    }
}
