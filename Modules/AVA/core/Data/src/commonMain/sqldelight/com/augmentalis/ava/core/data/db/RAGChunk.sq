-- RAG Chunk table for storing document chunks with embeddings
-- Migrated from Room ChunkEntity
-- Core table for vector similarity search

CREATE TABLE rag_chunk (
    id TEXT PRIMARY KEY NOT NULL,
    document_id TEXT NOT NULL,
    chunk_index INTEGER NOT NULL,
    content TEXT NOT NULL,
    token_count INTEGER NOT NULL,
    start_offset INTEGER NOT NULL,
    end_offset INTEGER NOT NULL,
    page_number INTEGER,
    section_title TEXT,
    embedding_blob BLOB NOT NULL,
    embedding_type TEXT NOT NULL,
    embedding_dimension INTEGER NOT NULL,
    quant_scale REAL,
    quant_offset REAL,
    cluster_id TEXT,
    distance_to_centroid REAL,
    created_timestamp TEXT NOT NULL,
    is_encrypted INTEGER AS kotlin.Boolean NOT NULL DEFAULT 0,
    encryption_key_version INTEGER DEFAULT 1,
    FOREIGN KEY (document_id) REFERENCES rag_document(id) ON DELETE CASCADE,
    FOREIGN KEY (cluster_id) REFERENCES rag_cluster(id) ON DELETE SET NULL
);

CREATE INDEX idx_rag_chunk_document_id ON rag_chunk(document_id);
CREATE INDEX idx_rag_chunk_chunk_index ON rag_chunk(chunk_index);
CREATE INDEX idx_rag_chunk_page_number ON rag_chunk(page_number);
CREATE INDEX idx_rag_chunk_cluster_id ON rag_chunk(cluster_id);
CREATE INDEX idx_rag_chunk_created_timestamp ON rag_chunk(created_timestamp DESC);
CREATE INDEX idx_rag_chunk_cluster_distance ON rag_chunk(cluster_id, distance_to_centroid);

-- Get all chunks
selectAll:
SELECT * FROM rag_chunk;

-- Get chunk by ID
selectById:
SELECT * FROM rag_chunk
WHERE id = ?;

-- Get chunks by document
selectByDocument:
SELECT * FROM rag_chunk
WHERE document_id = ?
ORDER BY chunk_index ASC;

-- Get chunks by cluster
selectByCluster:
SELECT * FROM rag_chunk
WHERE cluster_id = ?
ORDER BY distance_to_centroid ASC;

-- Get unclustered chunks
selectUnclustered:
SELECT * FROM rag_chunk
WHERE cluster_id IS NULL;

-- Get chunks by page number
selectByPage:
SELECT * FROM rag_chunk
WHERE document_id = ? AND page_number = ?;

-- Get recent chunks (for LRU cache warming)
selectRecent:
SELECT c.* FROM rag_chunk c
INNER JOIN rag_document d ON c.document_id = d.id
ORDER BY d.last_accessed_timestamp DESC
LIMIT ?;

-- Insert chunk
insert:
INSERT OR REPLACE INTO rag_chunk (
    id, document_id, chunk_index, content, token_count,
    start_offset, end_offset, page_number, section_title,
    embedding_blob, embedding_type, embedding_dimension,
    quant_scale, quant_offset, cluster_id, distance_to_centroid,
    created_timestamp, is_encrypted, encryption_key_version
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

-- Update cluster assignment
updateClusterAssignment:
UPDATE rag_chunk
SET cluster_id = ?,
    distance_to_centroid = ?
WHERE id = ?;

-- Clear cluster assignment
clearClusterAssignment:
UPDATE rag_chunk
SET cluster_id = NULL,
    distance_to_centroid = NULL
WHERE id = ?;

-- Clear all cluster assignments
clearAllClusterAssignments:
UPDATE rag_chunk
SET cluster_id = NULL,
    distance_to_centroid = NULL;

-- Delete chunk by ID
deleteById:
DELETE FROM rag_chunk
WHERE id = ?;

-- Delete chunks by document
deleteByDocument:
DELETE FROM rag_chunk
WHERE document_id = ?;

-- Delete all chunks
deleteAll:
DELETE FROM rag_chunk;

-- Delete oldest chunks (for storage limit)
deleteOldest:
DELETE FROM rag_chunk WHERE id IN (
    SELECT c.id FROM rag_chunk c
    INNER JOIN rag_document d ON c.document_id = d.id
    ORDER BY d.last_accessed_timestamp ASC
    LIMIT ?
);

-- Count all chunks
count:
SELECT COUNT(*) FROM rag_chunk;

-- Count chunks by document
countByDocument:
SELECT COUNT(*) FROM rag_chunk
WHERE document_id = ?;

-- Count chunks by cluster
countByCluster:
SELECT COUNT(*) FROM rag_chunk
WHERE cluster_id = ?;

-- Search chunks with filters (joins with document for metadata filtering)
searchWithFilters:
SELECT rag_chunk.* FROM rag_chunk
INNER JOIN rag_document ON rag_chunk.document_id = rag_document.id
WHERE (:documentType IS NULL OR rag_document.document_type = :documentType)
AND (:startDate IS NULL OR rag_document.added_timestamp >= :startDate)
AND (:endDate IS NULL OR rag_document.added_timestamp <= :endDate)
AND (:minSize IS NULL OR rag_document.size_bytes >= :minSize)
AND (:maxSize IS NULL OR rag_document.size_bytes <= :maxSize)
ORDER BY rag_document.added_timestamp DESC
LIMIT :limitVal;

-- Sum total storage used by chunk embeddings
sumEmbeddingBytes:
SELECT COALESCE(SUM(LENGTH(embedding_blob)), 0) FROM rag_chunk;

-- Sum total storage used by chunk content
sumContentBytes:
SELECT COALESCE(SUM(LENGTH(content)), 0) FROM rag_chunk;

-- Get unencrypted chunks (for migration)
selectUnencrypted:
SELECT * FROM rag_chunk
WHERE is_encrypted = 0
LIMIT ?;

-- Count unencrypted chunks
countUnencrypted:
SELECT COUNT(*) FROM rag_chunk
WHERE is_encrypted = 0;

-- Update encryption status
updateEncryptionStatus:
UPDATE rag_chunk
SET is_encrypted = ?,
    encryption_key_version = ?
WHERE id = ?;
