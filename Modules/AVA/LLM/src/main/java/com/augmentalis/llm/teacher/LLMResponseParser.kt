package com.augmentalis.llm.teacher

import timber.log.Timber

/**
 * Result from parsing LLM teacher response.
 *
 * @property response The natural language response to show the user
 * @property intent The classified intent name (e.g., "play_music")
 * @property variations Alternative phrasings generated by the LLM
 * @property confidence Confidence score 0.0-1.0
 */
data class LLMTeacherResult(
    val response: String,
    val intent: String,
    val variations: List<String>,
    val confidence: Float
) {
    /**
     * Check if this result is valid for teaching the NLU.
     * Requires response, valid intent, and reasonable confidence.
     */
    fun isValidForTeaching(): Boolean {
        return response.isNotBlank() &&
               intent.isNotBlank() &&
               intent != "unknown" &&
               intent != "clarify_request" &&
               confidence >= 0.5f
    }

    /**
     * Check if this is a clarification request.
     */
    val isClarification: Boolean
        get() = intent == "clarify_request"
}

/**
 * Parser for LLM teacher response format.
 *
 * Expected format:
 * ```
 * [RESPONSE]
 * The response text...
 *
 * [INTENT]
 * intent_name
 *
 * [VARIATIONS]
 * - variation 1
 * - variation 2
 *
 * [CONFIDENCE]
 * 0.95
 * ```
 *
 * @see ADR-013: Self-Learning NLU with LLM-as-Teacher Architecture
 */
object LLMResponseParser {

    private val RESPONSE_REGEX = Regex(
        """\[RESPONSE\](.*?)(?:\[INTENT\]|\z)""",
        RegexOption.DOT_MATCHES_ALL
    )

    private val INTENT_REGEX = Regex(
        """\[INTENT\]\s*(\w+)""",
        RegexOption.IGNORE_CASE
    )

    private val VARIATIONS_REGEX = Regex(
        """\[VARIATIONS\](.*?)(?:\[CONFIDENCE\]|\z)""",
        RegexOption.DOT_MATCHES_ALL
    )

    private val CONFIDENCE_REGEX = Regex(
        """\[CONFIDENCE\]\s*([\d.]+)""",
        RegexOption.IGNORE_CASE
    )

    // Fallback for simplified format
    private val SIMPLE_FORMAT_REGEX = Regex(
        """\[RESPONSE\](.*?)\[INTENT\]\s*(\w+)\s*\[CONFIDENCE\]\s*([\d.]+)""",
        setOf(RegexOption.IGNORE_CASE, RegexOption.DOT_MATCHES_ALL)
    )

    /**
     * Parse LLM output into structured result.
     *
     * @param llmOutput Raw LLM output string
     * @return Parsed result or null if parsing fails completely
     */
    fun parse(llmOutput: String): LLMTeacherResult? {
        if (llmOutput.isBlank()) {
            Timber.w("Empty LLM output")
            return null
        }

        // Try simplified format first (faster)
        SIMPLE_FORMAT_REGEX.find(llmOutput)?.let { match ->
            val (response, intent, confStr) = match.destructured
            return LLMTeacherResult(
                response = response.trim(),
                intent = intent.trim().lowercase(),
                variations = emptyList(),
                confidence = confStr.toFloatOrNull()?.coerceIn(0f, 1f) ?: 0.8f
            )
        }

        // Extract response
        val response = RESPONSE_REGEX.find(llmOutput)
            ?.groupValues?.get(1)
            ?.trim()

        if (response.isNullOrBlank()) {
            // Fallback: if no [RESPONSE] tag, try to use the output as-is
            Timber.d("No [RESPONSE] tag found, using fallback parsing")
            return createFallbackResult(llmOutput)
        }

        // Extract intent
        val intent = INTENT_REGEX.find(llmOutput)
            ?.groupValues?.get(1)
            ?.trim()
            ?.lowercase()
            ?: "general_question"

        // Extract variations
        val variationsBlock = VARIATIONS_REGEX.find(llmOutput)
            ?.groupValues?.get(1)
            ?: ""

        val variations = parseVariations(variationsBlock)

        // Extract confidence
        val confidence = CONFIDENCE_REGEX.find(llmOutput)
            ?.groupValues?.get(1)
            ?.toFloatOrNull()
            ?.coerceIn(0f, 1f)
            ?: 0.8f // Default to 0.8 if not specified

        val result = LLMTeacherResult(
            response = response,
            intent = intent,
            variations = variations,
            confidence = confidence
        )

        Timber.d("Parsed LLM response: intent=$intent, confidence=$confidence, variations=${variations.size}")
        return result
    }

    /**
     * Parse variations block into list of strings.
     */
    private fun parseVariations(block: String): List<String> {
        return block
            .lines()
            .map { line ->
                line.trim()
                    .removePrefix("-")
                    .removePrefix("*")
                    .removePrefix("â€¢")
                    .trim()
            }
            .filter { it.isNotBlank() && it.length >= 3 && it.length <= 200 }
            .take(5) // Max 5 variations
    }

    /**
     * Create fallback result when proper tags are not found.
     * Attempts to extract any useful information from the output.
     */
    private fun createFallbackResult(llmOutput: String): LLMTeacherResult {
        // Try to find intent mentioned anywhere
        val intentMatch = Regex("""intent[:\s]+(\w+)""", RegexOption.IGNORE_CASE)
            .find(llmOutput)
        val intent = intentMatch?.groupValues?.get(1)?.lowercase() ?: "general_question"

        // Try to find confidence mentioned anywhere
        val confMatch = Regex("""confidence[:\s]+([\d.]+)""", RegexOption.IGNORE_CASE)
            .find(llmOutput)
        val confidence = confMatch?.groupValues?.get(1)?.toFloatOrNull() ?: 0.5f

        // Use the whole output as response, but clean it up
        val cleanedResponse = llmOutput
            .replace(Regex("""\[.*?\]"""), "") // Remove tags
            .replace(Regex("""intent[:\s]+\w+""", RegexOption.IGNORE_CASE), "")
            .replace(Regex("""confidence[:\s]+[\d.]+""", RegexOption.IGNORE_CASE), "")
            .trim()
            .take(1000) // Limit length

        return LLMTeacherResult(
            response = cleanedResponse.ifBlank { llmOutput.take(500) },
            intent = intent,
            variations = emptyList(),
            confidence = confidence.coerceIn(0f, 1f)
        )
    }

    /**
     * Extract just the response portion for display.
     * Strips all metadata tags.
     *
     * @param llmOutput Raw LLM output
     * @return Clean response text for user display
     */
    fun extractResponseOnly(llmOutput: String): String {
        val parsed = parse(llmOutput)
        return parsed?.response ?: llmOutput
            .replace(Regex("""\[RESPONSE\]""", RegexOption.IGNORE_CASE), "")
            .replace(Regex("""\[INTENT\].*""", setOf(RegexOption.IGNORE_CASE, RegexOption.DOT_MATCHES_ALL)), "")
            .trim()
            .take(2000)
    }

    /**
     * Check if output contains teaching metadata.
     *
     * @param llmOutput Raw LLM output
     * @return True if output has [RESPONSE], [INTENT], etc. tags
     */
    fun hasTeachingMetadata(llmOutput: String): Boolean {
        return llmOutput.contains("[RESPONSE]", ignoreCase = true) &&
               llmOutput.contains("[INTENT]", ignoreCase = true)
    }
}
