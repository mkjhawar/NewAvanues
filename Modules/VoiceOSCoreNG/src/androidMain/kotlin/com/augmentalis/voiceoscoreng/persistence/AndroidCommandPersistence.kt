/**
 * AndroidCommandPersistence.kt - Android SQLDelight implementation of ICommandPersistence
 *
 * Copyright (C) Manoj Jhawar/Aman Jhawar, Intelligent Devices LLC
 * Author: VOS4 Development Team
 * Created: 2026-01-07
 *
 * Bridges the platform-agnostic ICommandPersistence interface to
 * the SQLDelight IGeneratedCommandRepository for Android.
 *
 * This enables JITLearner (in commonMain) to persist commands to
 * SQLDelight database without directly depending on the database module.
 */
package com.augmentalis.voiceoscoreng.persistence

import com.augmentalis.database.dto.GeneratedCommandDTO
import com.augmentalis.database.repositories.IGeneratedCommandRepository
import com.augmentalis.voiceoscoreng.common.CommandActionType
import com.augmentalis.voiceoscoreng.common.QuantizedCommand
import com.augmentalis.voiceoscoreng.features.currentTimeMillis

/**
 * Android implementation of ICommandPersistence using SQLDelight.
 *
 * Wraps IGeneratedCommandRepository to provide command persistence for
 * VoiceOSCoreNG components like JITLearner.
 *
 * ## Usage
 *
 * ```kotlin
 * // In your Android app/DI setup
 * val database = VoiceOSDatabase(driver)
 * val repository = SQLDelightGeneratedCommandRepository(database)
 * val persistence = AndroidCommandPersistence(repository)
 *
 * // Pass to JITLearner
 * val learner = JITLearner(persistence = persistence)
 * ```
 *
 * @property repository The SQLDelight repository for command persistence
 */
class AndroidCommandPersistence(
    private val repository: IGeneratedCommandRepository
) : ICommandPersistence {

    override suspend fun insertBatch(commands: List<QuantizedCommand>) {
        if (commands.isEmpty()) return

        val dtos = commands.map { it.toGeneratedCommandDTO() }
        repository.insertBatch(dtos)
    }

    override suspend fun insert(command: QuantizedCommand): Long? {
        val dto = command.toGeneratedCommandDTO()
        return repository.insert(dto)
    }

    override suspend fun getByPackage(packageName: String): List<QuantizedCommand> {
        val dtos = repository.getByPackage(packageName)
        return dtos.map { it.toQuantizedCommand() }
    }

    override suspend fun countByPackage(packageName: String): Long {
        return repository.getByPackage(packageName).size.toLong()
    }

    override suspend fun deleteByPackage(packageName: String): Int {
        return repository.deleteCommandsByPackage(packageName)
    }
}

// ============================================================================
// QuantizedCommand â†” GeneratedCommandDTO Conversion
// ============================================================================

/**
 * Convert QuantizedCommand to GeneratedCommandDTO for SQLDelight persistence.
 *
 * @throws IllegalStateException if required fields (packageName) are missing from metadata
 */
private fun QuantizedCommand.toGeneratedCommandDTO(): GeneratedCommandDTO {
    // Validate required fields - packageName is required for FK integrity
    val packageName = metadata["packageName"]
    require(!packageName.isNullOrBlank()) {
        "QuantizedCommand missing required packageName in metadata. " +
        "Ensure CommandGenerator.fromElement() is called with valid packageName. " +
        "Command: phrase='$phrase', targetAvid='$targetAvid'"
    }

    // Use elementHash from metadata if available, otherwise fall back to targetAvid/avid
    val elementHash = metadata["elementHash"]
        ?: targetAvid
        ?: avid.ifBlank { packageName.hashCode().toUInt().toString(16) }

    return GeneratedCommandDTO(
        id = 0, // Auto-generated by database
        elementHash = elementHash,
        commandText = phrase,
        actionType = actionType.name,
        confidence = confidence.toDouble(),
        synonyms = null,
        isUserApproved = 0,
        usageCount = 0,
        lastUsed = null,
        createdAt = metadata["createdAt"]?.toLongOrNull() ?: currentTimeMillis(),
        appId = packageName,
        appVersion = metadata["appVersion"] ?: "",
        versionCode = metadata["versionCode"]?.toLongOrNull() ?: 0,
        lastVerified = currentTimeMillis(),
        isDeprecated = 0
    )
}

/**
 * Convert GeneratedCommandDTO to QuantizedCommand for runtime use.
 */
private fun GeneratedCommandDTO.toQuantizedCommand(): QuantizedCommand {
    return QuantizedCommand(
        avid = elementHash,
        phrase = commandText,
        actionType = CommandActionType.fromString(actionType),
        targetAvid = elementHash,
        confidence = confidence.toFloat(),
        metadata = buildMap {
            if (appId.isNotEmpty()) put("packageName", appId)
            if (appVersion.isNotEmpty()) put("appVersion", appVersion)
            if (versionCode > 0) put("versionCode", versionCode.toString())
            put("createdAt", createdAt.toString())
            if (usageCount > 0) put("usageCount", usageCount.toString())
            if (isUserApproved == 1L) put("isUserApproved", "true")
            if (isDeprecated == 1L) put("isDeprecated", "true")
        }
    )
}
