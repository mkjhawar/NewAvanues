// Author: Manoj Jhawar
// Code-Reviewed-By: CCA
// Updated: 2025-01-28 - Implemented with SQLDelight repositories

package com.augmentalis.datamanager.io

import android.content.Context
import android.util.Log
import com.augmentalis.datamanager.data.*
import com.augmentalis.database.dto.CommandHistoryDTO
import com.augmentalis.database.dto.CustomCommandDTO
import com.augmentalis.database.dto.ErrorReportDTO
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONArray
import org.json.JSONObject
import java.io.File
import java.security.MessageDigest

/**
 * Data Importer - Imports VoiceOS data from JSON format
 *
 * Supports importing:
 * - User preferences
 * - Command history
 * - Custom commands
 * - Touch gestures
 * - Device profiles
 * - Usage statistics
 * - Error reports
 * - Gesture learning data
 */
class DataImporter(private val context: Context) {

    companion object {
        private const val TAG = "DataImporter"
    }

    // Repository instances
    private val userPreferenceRepo = UserPreferenceRepo()
    private val commandHistoryRepo = CommandHistoryRepo()
    private val customCommandRepo = CustomCommandRepo()
    private val touchGestureRepo = TouchGestureRepo()
    private val deviceProfileRepo = DeviceProfileRepo()
    private val usageStatisticRepo = UsageStatisticRepo()
    private val errorReportRepo = ErrorReportRepo()
    private val gestureLearningRepo = GestureLearningRepo()

    /**
     * Import data from JSON string
     *
     * @param jsonData The JSON string containing exported data
     * @param replaceExisting If true, clears existing data before importing
     * @param options Import options specifying what to import
     * @return True if import was successful
     */
    suspend fun importFromJson(
        jsonData: String,
        replaceExisting: Boolean = false,
        options: ImportOptions = ImportOptions()
    ): Boolean = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "Starting data import (replaceExisting=$replaceExisting)")

            val wrapper = JSONObject(jsonData)

            // Verify checksum if required
            if (options.verifyChecksum) {
                val storedChecksum = wrapper.optString("dataChecksum", "")
                val dataObj = wrapper.getJSONObject("data")
                val calculatedChecksum = calculateChecksum(dataObj.toString())

                if (storedChecksum.isNotEmpty() && storedChecksum != calculatedChecksum) {
                    Log.e(TAG, "Checksum verification failed")
                    return@withContext false
                }
            }

            val data = wrapper.getJSONObject("data")
            var totalImported = 0

            // Clear existing data if requested
            if (replaceExisting) {
                clearExistingData(options)
            }

            // Import user preferences
            if (options.importPreferences && data.has("userPreferences")) {
                val count = importUserPreferences(data.getJSONArray("userPreferences"))
                totalImported += count
                Log.d(TAG, "Imported $count user preferences")
            }

            // Import command history
            if (options.importCommandHistory && data.has("commandHistory")) {
                val count = importCommandHistory(data.getJSONArray("commandHistory"))
                totalImported += count
                Log.d(TAG, "Imported $count command history entries")
            }

            // Import custom commands
            if (options.importCustomCommands && data.has("customCommands")) {
                val count = importCustomCommands(data.getJSONArray("customCommands"))
                totalImported += count
                Log.d(TAG, "Imported $count custom commands")
            }

            // Import touch gestures
            if (options.importTouchGestures && data.has("touchGestures")) {
                val count = importTouchGestures(data.getJSONArray("touchGestures"))
                totalImported += count
                Log.d(TAG, "Imported $count touch gestures")
            }

            // Import device profiles
            if (options.importDeviceProfiles && data.has("deviceProfiles")) {
                val count = importDeviceProfiles(data.getJSONArray("deviceProfiles"))
                totalImported += count
                Log.d(TAG, "Imported $count device profiles")
            }

            // Import gesture learning data
            if (data.has("gestureLearning")) {
                val count = importGestureLearning(data.getJSONArray("gestureLearning"))
                totalImported += count
                Log.d(TAG, "Imported $count gesture learning entries")
            }

            // Import usage statistics (if enabled)
            if (options.importStatistics && data.has("usageStatistics")) {
                val count = importUsageStatistics(data.getJSONArray("usageStatistics"))
                totalImported += count
                Log.d(TAG, "Imported $count usage statistics")
            }

            // Import error reports (usually not needed but available)
            if (data.has("errorReports")) {
                val count = importErrorReports(data.getJSONArray("errorReports"))
                totalImported += count
                Log.d(TAG, "Imported $count error reports")
            }

            Log.i(TAG, "Data import completed successfully. Total records: $totalImported")
            true

        } catch (e: Exception) {
            Log.e(TAG, "Failed to import data", e)
            false
        }
    }

    /**
     * Import data from a file
     *
     * @param file The file containing exported JSON data
     * @param replaceExisting If true, clears existing data before importing
     * @return True if import was successful
     */
    suspend fun importFromFile(file: File, replaceExisting: Boolean = false): Boolean = withContext(Dispatchers.IO) {
        try {
            if (!file.exists()) {
                Log.e(TAG, "Import file does not exist: ${file.absolutePath}")
                return@withContext false
            }

            val jsonData = file.readText()
            importFromJson(jsonData, replaceExisting)

        } catch (e: Exception) {
            Log.e(TAG, "Failed to import data from file", e)
            false
        }
    }

    // Private helper methods

    private suspend fun clearExistingData(options: ImportOptions) {
        if (options.importPreferences) userPreferenceRepo.deleteAll()
        if (options.importCommandHistory) commandHistoryRepo.deleteAll()
        if (options.importCustomCommands) customCommandRepo.deleteAll()
        if (options.importTouchGestures) touchGestureRepo.deleteAll()
        if (options.importDeviceProfiles) deviceProfileRepo.deleteAll()
        if (options.importStatistics) usageStatisticRepo.deleteAll()
        gestureLearningRepo.deleteAll()
        errorReportRepo.deleteAll()
        Log.d(TAG, "Cleared existing data based on import options")
    }

    private suspend fun importUserPreferences(array: JSONArray): Int {
        var count = 0
        for (i in 0 until array.length()) {
            try {
                val obj = array.getJSONObject(i)
                userPreferenceRepo.setPreference(
                    key = obj.getString("key"),
                    value = obj.getString("value"),
                    type = obj.optString("type", "string")
                )
                count++
            } catch (e: Exception) {
                Log.w(TAG, "Failed to import preference at index $i", e)
            }
        }
        return count
    }

    private suspend fun importCommandHistory(array: JSONArray): Int {
        var count = 0
        for (i in 0 until array.length()) {
            try {
                val obj = array.getJSONObject(i)
                val entry = CommandHistoryDTO(
                    id = 0, // Let database assign new ID
                    originalText = obj.getString("originalText"),
                    processedCommand = obj.getString("processedCommand"),
                    confidence = obj.getDouble("confidence"),
                    timestamp = obj.getLong("timestamp"),
                    language = obj.optString("language", "en"),
                    engineUsed = obj.optString("engineUsed", "Unknown"),
                    success = obj.optBoolean("success", true),
                    executionTimeMs = obj.optLong("executionTimeMs", 0)
                )
                commandHistoryRepo.insert(entry)
                count++
            } catch (e: Exception) {
                Log.w(TAG, "Failed to import command history at index $i", e)
            }
        }
        return count
    }

    private suspend fun importCustomCommands(array: JSONArray): Int {
        var count = 0
        for (i in 0 until array.length()) {
            try {
                val obj = array.getJSONObject(i)
                val phrases = mutableListOf<String>()
                val phrasesArray = obj.getJSONArray("phrases")
                for (j in 0 until phrasesArray.length()) {
                    phrases.add(phrasesArray.getString(j))
                }

                val command = CustomCommandDTO(
                    id = 0, // Let database assign new ID
                    name = obj.getString("name"),
                    description = obj.optString("description", null).takeIf { it.isNotEmpty() },
                    phrases = phrases,
                    action = obj.getString("action"),
                    parameters = obj.optString("parameters", null).takeIf { it.isNotEmpty() },
                    language = obj.optString("language", "en"),
                    isActive = obj.optBoolean("isActive", true),
                    usageCount = obj.optLong("usageCount", 0)
                )
                customCommandRepo.insert(command)
                count++
            } catch (e: Exception) {
                Log.w(TAG, "Failed to import custom command at index $i", e)
            }
        }
        return count
    }

    private suspend fun importTouchGestures(array: JSONArray): Int {
        var count = 0
        for (i in 0 until array.length()) {
            try {
                val obj = array.getJSONObject(i)
                touchGestureRepo.insert(
                    name = obj.getString("name"),
                    gestureData = obj.getString("gestureData"),
                    usageCount = obj.optLong("usageCount", 0),
                    isSystemGesture = obj.optBoolean("isSystemGesture", false),
                    isEnabled = obj.optBoolean("isActive", true)
                )
                count++
            } catch (e: Exception) {
                Log.w(TAG, "Failed to import touch gesture at index $i", e)
            }
        }
        return count
    }

    private suspend fun importDeviceProfiles(array: JSONArray): Int {
        var count = 0
        for (i in 0 until array.length()) {
            try {
                val obj = array.getJSONObject(i)
                deviceProfileRepo.insert(
                    deviceType = obj.getString("deviceType"),
                    deviceModel = obj.getString("deviceModel"),
                    settings = obj.getString("settings"),
                    calibrationData = obj.optString("calibrationData", null).takeIf { it.isNotEmpty() },
                    isActive = obj.optBoolean("isActive", false)
                )
                count++
            } catch (e: Exception) {
                Log.w(TAG, "Failed to import device profile at index $i", e)
            }
        }
        return count
    }

    private suspend fun importUsageStatistics(array: JSONArray): Int {
        var count = 0
        for (i in 0 until array.length()) {
            try {
                val obj = array.getJSONObject(i)
                // Convert legacy format to new metric-based format
                usageStatisticRepo.insert(
                    metricType = "daily_usage",
                    metricName = obj.optString("date", "unknown"),
                    value = obj.optDouble("successRate", 0.0),
                    count = obj.optLong("commandsExecuted", 0),
                    metadata = obj.toString()
                )
                count++
            } catch (e: Exception) {
                Log.w(TAG, "Failed to import usage statistic at index $i", e)
            }
        }
        return count
    }

    private suspend fun importErrorReports(array: JSONArray): Int {
        var count = 0
        for (i in 0 until array.length()) {
            try {
                val obj = array.getJSONObject(i)
                val report = ErrorReportDTO(
                    id = 0,
                    errorType = obj.getString("errorType"),
                    message = obj.getString("message"),
                    stackTrace = obj.getString("stackTrace"),
                    context = obj.optString("context", null).takeIf { it.isNotEmpty() },
                    timestamp = obj.getLong("timestamp"),
                    isSent = obj.optBoolean("isSent", false)
                )
                errorReportRepo.insert(report)
                count++
            } catch (e: Exception) {
                Log.w(TAG, "Failed to import error report at index $i", e)
            }
        }
        return count
    }

    private suspend fun importGestureLearning(array: JSONArray): Int {
        var count = 0
        for (i in 0 until array.length()) {
            try {
                val obj = array.getJSONObject(i)
                val practiceCount = obj.optLong("practiceCount", 0)
                val successRate = obj.optDouble("successRate", 0.0)
                val successCount = (practiceCount * successRate).toLong()
                val failureCount = practiceCount - successCount

                gestureLearningRepo.insert(
                    gestureType = obj.optString("gestureType", "unknown"),
                    sampleData = obj.optString("sampleData", "{}"),
                    successCount = successCount,
                    failureCount = failureCount,
                    avgConfidence = successRate
                )
                count++
            } catch (e: Exception) {
                Log.w(TAG, "Failed to import gesture learning at index $i", e)
            }
        }
        return count
    }

    private fun calculateChecksum(data: String): String {
        val digest = MessageDigest.getInstance("SHA-256")
        val hash = digest.digest(data.toByteArray())
        return hash.joinToString("") { "%02x".format(it) }
    }
}

data class ImportOptions(
    val replaceExisting: Boolean = false,
    val importPreferences: Boolean = true,
    val importCommandHistory: Boolean = true,
    val importCustomCommands: Boolean = true,
    val importUserSequences: Boolean = true,
    val importTouchGestures: Boolean = true,
    val importDeviceProfiles: Boolean = true,
    val importStatistics: Boolean = false,
    val verifyChecksum: Boolean = true
)
