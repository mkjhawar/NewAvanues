-- ScrapedHierarchy.sq
-- Parent-child relationships for UI element hierarchies

CREATE TABLE scraped_hierarchy (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    parentElementHash TEXT NOT NULL,
    childElementHash TEXT NOT NULL,
    depth INTEGER NOT NULL DEFAULT 0,
    createdAt INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (parentElementHash) REFERENCES scraped_element(elementHash) ON DELETE CASCADE,
    FOREIGN KEY (childElementHash) REFERENCES scraped_element(elementHash) ON DELETE CASCADE,
    UNIQUE(parentElementHash, childElementHash)
);

CREATE INDEX idx_sh_parent ON scraped_hierarchy(parentElementHash);
CREATE INDEX idx_sh_child ON scraped_hierarchy(childElementHash);
CREATE INDEX idx_sh_depth ON scraped_hierarchy(depth);

insert:
INSERT OR REPLACE INTO scraped_hierarchy (parentElementHash, childElementHash, depth, createdAt)
VALUES (?, ?, ?, ?);

getByParent:
SELECT * FROM scraped_hierarchy WHERE parentElementHash = ?;

getByChild:
SELECT * FROM scraped_hierarchy WHERE childElementHash = ?;

getChildren:
SELECT sh.*, se.*
FROM scraped_hierarchy sh
JOIN scraped_element se ON sh.childElementHash = se.elementHash
WHERE sh.parentElementHash = ?;

getParent:
SELECT sh.*, se.*
FROM scraped_hierarchy sh
JOIN scraped_element se ON sh.parentElementHash = se.elementHash
WHERE sh.childElementHash = ?;

getByDepth:
SELECT * FROM scraped_hierarchy WHERE depth = ?;

deleteByParent:
DELETE FROM scraped_hierarchy WHERE parentElementHash = ?;

deleteByChild:
DELETE FROM scraped_hierarchy WHERE childElementHash = ?;

deleteRelationship:
DELETE FROM scraped_hierarchy WHERE parentElementHash = ? AND childElementHash = ?;

deleteAll:
DELETE FROM scraped_hierarchy;

count:
SELECT COUNT(*) FROM scraped_hierarchy;

countByParent:
SELECT parentElementHash, COUNT(*) AS count
FROM scraped_hierarchy
GROUP BY parentElementHash;

-- Batch insert is handled by Kotlin extension calling insert() multiple times
-- Get last inserted row ID (for batch operations)
lastInsertRowId:
SELECT last_insert_rowid();
