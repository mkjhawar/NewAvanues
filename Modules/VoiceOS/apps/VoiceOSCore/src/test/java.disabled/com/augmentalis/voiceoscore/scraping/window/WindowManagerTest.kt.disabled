package com.augmentalis.voiceoscore.scraping.window

import android.accessibilityservice.AccessibilityService
import android.graphics.Rect
import android.view.accessibility.AccessibilityNodeInfo
import android.view.accessibility.AccessibilityWindowInfo
import com.augmentalis.voiceoscore.scraping.detection.LauncherDetector
import com.augmentalis.voiceoscore.scraping.window.WindowManager.WindowType
import io.mockk.*
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

/**
 * Unit tests for WindowManager.
 *
 * Tests multi-window detection, classification, filtering, and edge cases.
 */
class WindowManagerTest {

    private lateinit var mockAccessibilityService: AccessibilityService
    private lateinit var mockLauncherDetector: LauncherDetector
    private lateinit var windowManager: WindowManager

    @Before
    fun setup() {
        mockAccessibilityService = mockk(relaxed = true)
        mockLauncherDetector = mockk(relaxed = true)

        // Default: no launchers detected
        every { mockLauncherDetector.isLauncher(any()) } returns false
        every { mockLauncherDetector.detectLauncherPackages() } returns emptySet()

        windowManager = WindowManager(mockAccessibilityService)
    }

    @After
    fun tearDown() {
        unmockkAll()
    }

    // ========================================
    // Basic Window Detection Tests
    // ========================================

    @Test
    fun `getAppWindows returns empty list when no windows available`() {
        // Arrange
        every { mockAccessibilityService.windows } returns null

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert
        assertTrue(result.isEmpty())
    }

    @Test
    fun `getAppWindows returns empty list when windows list is empty`() {
        // Arrange
        every { mockAccessibilityService.windows } returns emptyList()

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert
        assertTrue(result.isEmpty())
    }

    @Test
    fun `getAppWindows returns window matching target package`() {
        // Arrange
        val targetPackage = "com.microsoft.teams"
        val window = createMockWindow(
            packageName = targetPackage,
            type = AccessibilityWindowInfo.TYPE_APPLICATION,
            layer = 0
        )
        every { mockAccessibilityService.windows } returns listOf(window)

        // Act
        val result = windowManager.getAppWindows(targetPackage, mockLauncherDetector)

        // Assert
        assertEquals(1, result.size)
        assertEquals(targetPackage, result[0].packageName)
        assertEquals(WindowType.MAIN_APP, result[0].type)
    }

    @Test
    fun `getAppWindows filters out windows from different packages`() {
        // Arrange
        val targetPackage = "com.microsoft.teams"
        val window1 = createMockWindow(packageName = targetPackage, layer = 0)
        val window2 = createMockWindow(packageName = "com.other.app", layer = 1)
        val window3 = createMockWindow(packageName = "com.android.systemui", layer = 2)
        every { mockAccessibilityService.windows } returns listOf(window1, window2, window3)

        // Act
        val result = windowManager.getAppWindows(targetPackage, mockLauncherDetector)

        // Assert
        assertEquals(1, result.size)
        assertEquals(targetPackage, result[0].packageName)
    }

    @Test
    fun `getAppWindows returns multiple windows for same package`() {
        // Arrange
        val targetPackage = "com.microsoft.teams"
        val mainWindow = createMockWindow(
            packageName = targetPackage,
            type = AccessibilityWindowInfo.TYPE_APPLICATION,
            layer = 0
        )
        val overlayWindow = createMockWindow(
            packageName = targetPackage,
            type = AccessibilityWindowInfo.TYPE_APPLICATION_OVERLAY,
            layer = 10
        )
        every { mockAccessibilityService.windows } returns listOf(mainWindow, overlayWindow)

        // Act
        val result = windowManager.getAppWindows(targetPackage, mockLauncherDetector)

        // Assert
        assertEquals(2, result.size)
    }

    // ========================================
    // Window Sorting Tests
    // ========================================

    @Test
    fun `getAppWindows sorts windows by layer (bottom to top)`() {
        // Arrange
        val targetPackage = "com.test.app"
        val window1 = createMockWindow(packageName = targetPackage, layer = 10, title = "Overlay")
        val window2 = createMockWindow(packageName = targetPackage, layer = 0, title = "Main")
        val window3 = createMockWindow(packageName = targetPackage, layer = 5, title = "Dialog")
        every { mockAccessibilityService.windows } returns listOf(window1, window2, window3)

        // Act
        val result = windowManager.getAppWindows(targetPackage, mockLauncherDetector)

        // Assert
        assertEquals(3, result.size)
        assertEquals("Main", result[0].title)      // Layer 0 (bottom)
        assertEquals("Dialog", result[1].title)    // Layer 5 (middle)
        assertEquals("Overlay", result[2].title)   // Layer 10 (top)
    }

    // ========================================
    // Launcher Filtering Tests
    // ========================================

    @Test
    fun `getAppWindows filters out launcher windows`() {
        // Arrange
        val launcherPackage = "com.realwear.launcher"
        val appPackage = "com.test.app"

        every { mockLauncherDetector.isLauncher(launcherPackage) } returns true
        every { mockLauncherDetector.isLauncher(appPackage) } returns false

        val launcherWindow = createMockWindow(packageName = launcherPackage, layer = 0)
        val appWindow = createMockWindow(packageName = appPackage, layer = 1)
        every { mockAccessibilityService.windows } returns listOf(launcherWindow, appWindow)

        // Act - try to get launcher windows (should be filtered)
        val result = windowManager.getAppWindows(launcherPackage, mockLauncherDetector)

        // Assert
        assertTrue(result.isEmpty()) // Launcher filtered out
    }

    @Test
    fun `getAppWindows handles launcher appearing during BACK recovery`() {
        // Arrange - simulates Issue #2 (launcher contamination during BACK)
        val targetPackage = "com.microsoft.teams"
        val launcherPackage = "com.realwear.launcher"

        every { mockLauncherDetector.isLauncher(launcherPackage) } returns true
        every { mockLauncherDetector.isLauncher(targetPackage) } returns false

        // Simulated state: App window + launcher window (from BACK navigation)
        val appWindow = createMockWindow(packageName = targetPackage, layer = 0)
        val launcherWindow = createMockWindow(packageName = launcherPackage, layer = 1)
        every { mockAccessibilityService.windows } returns listOf(appWindow, launcherWindow)

        // Act - get app windows (should NOT include launcher)
        val result = windowManager.getAppWindows(targetPackage, mockLauncherDetector)

        // Assert - launcher excluded even though visible
        assertEquals(1, result.size)
        assertEquals(targetPackage, result[0].packageName)
    }

    // ========================================
    // Window Classification Tests
    // ========================================

    @Test
    fun `classifies TYPE_APPLICATION as MAIN_APP`() {
        // Arrange
        val window = createMockWindow(
            packageName = "com.test.app",
            type = AccessibilityWindowInfo.TYPE_APPLICATION,
            layer = 0
        )
        every { mockAccessibilityService.windows } returns listOf(window)

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert
        assertEquals(WindowType.MAIN_APP, result[0].type)
    }

    @Test
    fun `classifies TYPE_APPLICATION_OVERLAY as OVERLAY`() {
        // Arrange
        val window = createMockWindow(
            packageName = "com.test.app",
            type = AccessibilityWindowInfo.TYPE_APPLICATION_OVERLAY,
            layer = 10
        )
        every { mockAccessibilityService.windows } returns listOf(window)

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert
        assertEquals(WindowType.OVERLAY, result[0].type)
    }

    @Test
    fun `classifies TYPE_INPUT_METHOD as INPUT_METHOD`() {
        // Arrange
        val window = createMockWindow(
            packageName = "com.test.app",
            type = AccessibilityWindowInfo.TYPE_INPUT_METHOD,
            layer = 15
        )
        every { mockAccessibilityService.windows } returns listOf(window)

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector, includeSystemWindows = true)

        // Assert
        assertEquals(1, result.size)
        assertEquals(WindowType.INPUT_METHOD, result[0].type)
    }

    @Test
    fun `classifies high layer TYPE_APPLICATION as OVERLAY`() {
        // Arrange - layer > 5 suggests overlay
        val window = createMockWindow(
            packageName = "com.test.app",
            type = AccessibilityWindowInfo.TYPE_APPLICATION,
            layer = 10
        )
        every { mockAccessibilityService.windows } returns listOf(window)

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert
        assertEquals(WindowType.OVERLAY, result[0].type)
    }

    @Test
    fun `classifies small TYPE_APPLICATION as DIALOG`() {
        // Arrange - small bounds suggest dialog
        val window = createMockWindow(
            packageName = "com.test.app",
            type = AccessibilityWindowInfo.TYPE_APPLICATION,
            layer = 2,
            width = 600,  // < 800 threshold
            height = 400  // < 600 threshold
        )
        every { mockAccessibilityService.windows } returns listOf(window)

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert
        assertEquals(WindowType.DIALOG, result[0].type)
    }

    @Test
    fun `classifies system UI package as SYSTEM`() {
        // Arrange
        val systemPackage = "com.android.systemui"
        mockkObject(LauncherDetector.Companion)
        every { LauncherDetector.SYSTEM_UI_PACKAGES } returns setOf(systemPackage)

        val window = createMockWindow(
            packageName = systemPackage,
            type = AccessibilityWindowInfo.TYPE_APPLICATION,
            layer = 20
        )
        every { mockAccessibilityService.windows } returns listOf(window)

        // Act
        val result = windowManager.getAppWindows(systemPackage, mockLauncherDetector, includeSystemWindows = true)

        // Assert
        assertEquals(1, result.size)
        assertEquals(WindowType.SYSTEM, result[0].type)

        unmockkObject(LauncherDetector.Companion)
    }

    // ========================================
    // System Window Filtering Tests
    // ========================================

    @Test
    fun `getAppWindows filters out INPUT_METHOD by default`() {
        // Arrange
        val targetPackage = "com.test.app"
        val appWindow = createMockWindow(
            packageName = targetPackage,
            type = AccessibilityWindowInfo.TYPE_APPLICATION,
            layer = 0
        )
        val keyboardWindow = createMockWindow(
            packageName = targetPackage,
            type = AccessibilityWindowInfo.TYPE_INPUT_METHOD,
            layer = 15
        )
        every { mockAccessibilityService.windows } returns listOf(appWindow, keyboardWindow)

        // Act
        val result = windowManager.getAppWindows(targetPackage, mockLauncherDetector)

        // Assert
        assertEquals(1, result.size) // Only app window, keyboard filtered
        assertEquals(WindowType.MAIN_APP, result[0].type)
    }

    @Test
    fun `getAppWindows includes INPUT_METHOD when includeSystemWindows=true`() {
        // Arrange
        val targetPackage = "com.test.app"
        val keyboardWindow = createMockWindow(
            packageName = targetPackage,
            type = AccessibilityWindowInfo.TYPE_INPUT_METHOD,
            layer = 15
        )
        every { mockAccessibilityService.windows } returns listOf(keyboardWindow)

        // Act
        val result = windowManager.getAppWindows(targetPackage, mockLauncherDetector, includeSystemWindows = true)

        // Assert
        assertEquals(1, result.size)
        assertEquals(WindowType.INPUT_METHOD, result[0].type)
    }

    // ========================================
    // Edge Cases and Error Handling Tests
    // ========================================

    @Test
    fun `getAppWindows skips windows without root node`() {
        // Arrange
        val windowWithRoot = createMockWindow(packageName = "com.test.app", layer = 0)
        val windowWithoutRoot = mockk<AccessibilityWindowInfo>(relaxed = true).apply {
            every { root } returns null
            every { layer } returns 1
        }
        every { mockAccessibilityService.windows } returns listOf(windowWithRoot, windowWithoutRoot)

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert
        assertEquals(1, result.size) // Only window with root node
    }

    @Test
    fun `getAppWindows skips windows with null package name`() {
        // Arrange
        val validWindow = createMockWindow(packageName = "com.test.app", layer = 0)
        val invalidWindow = mockk<AccessibilityWindowInfo>(relaxed = true).apply {
            val rootNode = mockk<AccessibilityNodeInfo>(relaxed = true)
            every { rootNode.packageName } returns null
            every { root } returns rootNode
            every { layer } returns 1
        }
        every { mockAccessibilityService.windows } returns listOf(validWindow, invalidWindow)

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert
        assertEquals(1, result.size)
    }

    @Test
    fun `getAppWindows handles exception from individual window gracefully`() {
        // Arrange
        val goodWindow = createMockWindow(packageName = "com.test.app", layer = 0)
        val badWindow = mockk<AccessibilityWindowInfo>(relaxed = true).apply {
            every { root } throws RuntimeException("Window error")
        }
        every { mockAccessibilityService.windows } returns listOf(goodWindow, badWindow)

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert - should continue processing despite error
        assertEquals(1, result.size)
    }

    @Test
    fun `getAppWindows handles fatal exception gracefully`() {
        // Arrange
        every { mockAccessibilityService.windows } throws RuntimeException("Service unavailable")

        // Act
        val result = windowManager.getAppWindows("com.test.app", mockLauncherDetector)

        // Assert - graceful degradation
        assertTrue(result.isEmpty())
    }

    // ========================================
    // WindowInfo Tests
    // ========================================

    @Test
    fun `WindowInfo shouldScrape returns true for scrapable types`() {
        // Arrange
        val scrapableTypes = listOf(
            WindowType.MAIN_APP,
            WindowType.OVERLAY,
            WindowType.DIALOG,
            WindowType.UNKNOWN
        )

        // Act & Assert
        for (type in scrapableTypes) {
            val windowInfo = createWindowInfo(type = type)
            assertTrue("$type should be scrapable", windowInfo.shouldScrape())
        }
    }

    @Test
    fun `WindowInfo shouldScrape returns false for non-scrapable types`() {
        // Arrange
        val nonScrapableTypes = listOf(
            WindowType.LAUNCHER,
            WindowType.SYSTEM,
            WindowType.INPUT_METHOD
        )

        // Act & Assert
        for (type in nonScrapableTypes) {
            val windowInfo = createWindowInfo(type = type)
            assertFalse("$type should not be scrapable", windowInfo.shouldScrape())
        }
    }

    @Test
    fun `WindowInfo toLogString includes all relevant info`() {
        // Arrange
        val windowInfo = createWindowInfo(
            type = WindowType.OVERLAY,
            packageName = "com.test.app",
            title = "Test Dialog",
            layer = 10
        )

        // Act
        val logString = windowInfo.toLogString()

        // Assert
        assertTrue(logString.contains("OVERLAY"))
        assertTrue(logString.contains("com.test.app"))
        assertTrue(logString.contains("Test Dialog"))
        assertTrue(logString.contains("layer=10"))
    }

    // ========================================
    // getActiveWindow Tests
    // ========================================

    @Test
    fun `getActiveWindow returns active window when present`() {
        // Arrange
        val targetPackage = "com.test.app"
        val activeWindow = createMockWindow(
            packageName = targetPackage,
            layer = 0,
            isActive = true
        )
        val inactiveWindow = createMockWindow(
            packageName = targetPackage,
            layer = 1,
            isActive = false
        )
        every { mockAccessibilityService.windows } returns listOf(activeWindow, inactiveWindow)

        // Act
        val result = windowManager.getActiveWindow(targetPackage, mockLauncherDetector)

        // Assert
        assertNotNull(result)
        assertTrue(result!!.isActive)
    }

    @Test
    fun `getActiveWindow returns null when no active window`() {
        // Arrange
        val targetPackage = "com.test.app"
        val window = createMockWindow(
            packageName = targetPackage,
            layer = 0,
            isActive = false
        )
        every { mockAccessibilityService.windows } returns listOf(window)

        // Act
        val result = windowManager.getActiveWindow(targetPackage, mockLauncherDetector)

        // Assert
        assertNull(result)
    }

    // ========================================
    // getDiagnostics Tests
    // ========================================

    @Test
    fun `getDiagnostics returns window statistics`() {
        // Arrange
        val windows = listOf(
            createMockWindow(packageName = "com.test.app1", type = AccessibilityWindowInfo.TYPE_APPLICATION, layer = 0),
            createMockWindow(packageName = "com.test.app1", type = AccessibilityWindowInfo.TYPE_APPLICATION_OVERLAY, layer = 1),
            createMockWindow(packageName = "com.test.app2", type = AccessibilityWindowInfo.TYPE_APPLICATION, layer = 2)
        )
        every { mockAccessibilityService.windows } returns windows

        // Act
        val diagnostics = windowManager.getDiagnostics()

        // Assert
        assertEquals(3, diagnostics["totalWindows"])
        val byPackage = diagnostics["windowsByPackage"] as Map<*, *>
        assertEquals(2, byPackage["com.test.app1"])
        assertEquals(1, byPackage["com.test.app2"])
    }

    @Test
    fun `getDiagnostics handles error gracefully`() {
        // Arrange
        every { mockAccessibilityService.windows } throws RuntimeException("Service error")

        // Act
        val diagnostics = windowManager.getDiagnostics()

        // Assert
        assertTrue(diagnostics.containsKey("error"))
    }

    // ========================================
    // Helper Methods
    // ========================================

    private fun createMockWindow(
        packageName: String,
        type: Int = AccessibilityWindowInfo.TYPE_APPLICATION,
        layer: Int = 0,
        width: Int = 1080,
        height: Int = 1920,
        title: String = "Test Window",
        isActive: Boolean = false,
        isFocused: Boolean = false
    ): AccessibilityWindowInfo {
        val window = mockk<AccessibilityWindowInfo>(relaxed = true)
        val rootNode = mockk<AccessibilityNodeInfo>(relaxed = true)

        every { rootNode.packageName } returns packageName
        every { window.root } returns rootNode
        every { window.type } returns type
        every { window.layer } returns layer
        every { window.title } returns title
        every { window.isActive } returns isActive
        every { window.isFocused } returns isFocused
        every { window.getBoundsInScreen(any()) } answers {
            val rect = firstArg<Rect>()
            rect.set(0, 0, width, height)
        }

        return window
    }

    private fun createWindowInfo(
        type: WindowType = WindowType.MAIN_APP,
        packageName: String = "com.test.app",
        title: String = "Test",
        layer: Int = 0
    ): WindowManager.WindowInfo {
        val mockWindow = mockk<AccessibilityWindowInfo>(relaxed = true)
        val mockRootNode = mockk<AccessibilityNodeInfo>(relaxed = true)
        return WindowManager.WindowInfo(
            window = mockWindow,
            type = type,
            packageName = packageName,
            rootNode = mockRootNode,
            title = title,
            layer = layer,
            isActive = false,
            isFocused = false,
            bounds = Rect(0, 0, 1080, 1920)
        )
    }
}
