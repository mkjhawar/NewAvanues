/**
 * RepositoryTransactionTest.kt - Tests for database transaction support
 *
 * Converted from BatchTransactionManagerTest (Room) to SQLDelight repository tests
 *
 * Tests verify:
 * 1. Repository can perform batch inserts within transactions
 * 2. Transactions rollback correctly on errors
 * 3. Multiple operations execute atomically
 * 4. Database manager transaction support works correctly
 *
 * Zero Tolerance: 0 errors, 0 warnings, 100% pass rate
 *
 * Copyright (C) Manoj Jhawar/Aman Jhawar, Intelligent Devices LLC
 */
package com.augmentalis.voiceoscore.database

import com.augmentalis.database.dto.ScrapedAppDTO
import com.augmentalis.database.dto.ScrapedElementDTO
import com.augmentalis.voiceoscore.test.infrastructure.BaseRepositoryTest
import com.augmentalis.voiceoscore.test.infrastructure.CoroutineTestRule
import com.google.common.truth.Truth.assertThat
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Rule
import org.junit.Test
import kotlin.test.assertFailsWith

/**
 * Test suite for database transaction operations.
 *
 * Verifies that:
 * - Batch operations work correctly
 * - Transactions provide atomicity
 * - Rollback works on errors
 * - Multiple repositories can participate in same transaction
 */
@OptIn(ExperimentalCoroutinesApi::class)
class RepositoryTransactionTest : BaseRepositoryTest() {

    // coroutineRule is inherited from BaseRepositoryTest

    /**
     * TEST 1: Verify database manager can be created
     */
    @Test
    fun `test database manager can be created`() {
        assertThat(databaseManager).isNotNull()
    }

    /**
     * TEST 2: Verify manager supports transactions
     */
    @Test
    fun `test manager supports transactions`() = runTest {
        // Execute a simple transaction to verify support
        val result = databaseManager.transaction {
            "transaction works"
        }

        assertThat(result).isEqualTo("transaction works")
    }

    /**
     * TEST 3: Verify batch insert creates multiple records
     */
    @Test
    fun `batch insert creates multiple records`() = runTest {
        // Create test data - multiple apps
        val apps = listOf(
            ScrapedAppDTO(
                packageName = "com.example.app1",
                appName = "Test App 1",
                versionCode = 1L,
                versionName = "1.0",
                firstScrapedAt = now(),
                lastScrapedAt = now()
            ),
            ScrapedAppDTO(
                packageName = "com.example.app2",
                appName = "Test App 2",
                versionCode = 1L,
                versionName = "1.0",
                firstScrapedAt = now(),
                lastScrapedAt = now()
            ),
            ScrapedAppDTO(
                packageName = "com.example.app3",
                appName = "Test App 3",
                versionCode = 1L,
                versionName = "1.0",
                firstScrapedAt = now(),
                lastScrapedAt = now()
            )
        )

        // Insert all apps in a transaction
        databaseManager.transaction {
            apps.forEach { app ->
                databaseManager.scrapedApps.insert(app)
            }
        }

        // Verify all were inserted
        val allApps = databaseManager.scrapedApps.getAll()
        assertThat(allApps).hasSize(3)
        assertThat(allApps.map { it.packageName }).containsExactly(
            "com.example.app1",
            "com.example.app2",
            "com.example.app3"
        )
    }

    /**
     * TEST 4: Verify transaction rollback on error
     */
    @Test
    fun `transaction rollback on error`() = runTest {
        // Insert one app successfully first
        val app1 = ScrapedAppDTO(
            packageName = "com.example.existing",
            appName = "Existing App",
            versionCode = 1L,
            versionName = "1.0",
            firstScrapedAt = now(),
            lastScrapedAt = now()
        )
        databaseManager.scrapedApps.insert(app1)

        // Verify it was inserted
        assertThat(databaseManager.scrapedApps.getAll()).hasSize(1)

        // Try to insert multiple apps in a transaction, but throw error mid-way
        assertFailsWith<IllegalStateException> {
            databaseManager.transaction {
                // Insert app 2
                databaseManager.scrapedApps.insert(
                    ScrapedAppDTO(
                        packageName = "com.example.app2",
                        appName = "Test App 2",
                        versionCode = 1L,
                        versionName = "1.0",
                        firstScrapedAt = now(),
                        lastScrapedAt = now()
                    )
                )

                // Throw error before committing
                throw IllegalStateException("Simulated error")
            }
        }

        // Verify rollback - only original app remains
        val allApps = databaseManager.scrapedApps.getAll()
        assertThat(allApps).hasSize(1)
        assertThat(allApps[0].packageName).isEqualTo("com.example.existing")
    }

    /**
     * TEST 5: Verify multiple repositories in same transaction
     */
    @Test
    fun `multiple repositories in same transaction`() = runTest {
        val timestamp = now()

        // Create app and elements in same transaction
        databaseManager.transaction {
            // Insert app
            databaseManager.scrapedApps.insert(
                ScrapedAppDTO(
                    packageName = "com.example.app",
                    appName = "Test App",
                    versionCode = 1L,
                    versionName = "1.0",
                    firstScrapedAt = timestamp,
                    lastScrapedAt = timestamp
                )
            )

            // Insert elements for that app
            databaseManager.scrapedElements.insert(
                ScrapedElementDTO(
                    elementHash = "hash1",
                    packageName = "com.example.app",
                    screenHash = "screen1",
                    resourceId = "button1",
                    className = "Button",
                    text = "Click me",
                    contentDescription = "Button",
                    isClickable = true,
                    isScrollable = false,
                    isEditable = false,
                    boundsInScreen = "[0,0][100,50]",
                    parentHash = null,
                    firstSeenAt = timestamp,
                    lastSeenAt = timestamp,
                    clickCount = 0L,
                    inferredLabel = null
                )
            )

            databaseManager.scrapedElements.insert(
                ScrapedElementDTO(
                    elementHash = "hash2",
                    packageName = "com.example.app",
                    screenHash = "screen1",
                    resourceId = "button2",
                    className = "Button",
                    text = "Cancel",
                    contentDescription = "Cancel Button",
                    isClickable = true,
                    isScrollable = false,
                    isEditable = false,
                    boundsInScreen = "[100,0][200,50]",
                    parentHash = null,
                    firstSeenAt = timestamp,
                    lastSeenAt = timestamp,
                    clickCount = 0L,
                    inferredLabel = null
                )
            )
        }

        // Verify both app and elements were inserted
        val apps = databaseManager.scrapedApps.getAll()
        assertThat(apps).hasSize(1)
        assertThat(apps[0].packageName).isEqualTo("com.example.app")

        val elements = databaseManager.scrapedElements.getByPackageName("com.example.app")
        assertThat(elements).hasSize(2)
        assertThat(elements.map { it.text }).containsExactly("Click me", "Cancel")
    }

    /**
     * TEST 6: Verify nested transaction operations
     */
    @Test
    fun `nested transaction operations work correctly`() = runTest {
        // SQLDelight transactions are automatically nested
        val result = databaseManager.transaction {
            databaseManager.scrapedApps.insert(
                ScrapedAppDTO(
                    packageName = "com.example.nested",
                    appName = "Nested App",
                    versionCode = 1L,
                    versionName = "1.0",
                    firstScrapedAt = now(),
                    lastScrapedAt = now()
                )
            )

            // Return success indicator
            "nested transaction completed"
        }

        assertThat(result).isEqualTo("nested transaction completed")

        val apps = databaseManager.scrapedApps.getAll()
        assertThat(apps).hasSize(1)
        assertThat(apps[0].packageName).isEqualTo("com.example.nested")
    }

    /**
     * TEST 7: Verify transaction with query and insert
     */
    @Test
    fun `transaction with query and insert`() = runTest {
        // Insert initial app
        databaseManager.scrapedApps.insert(
            ScrapedAppDTO(
                packageName = "com.example.initial",
                appName = "Initial App",
                versionCode = 1L,
                versionName = "1.0",
                firstScrapedAt = now(),
                lastScrapedAt = now()
            )
        )

        // In transaction: query existing, then insert new based on query result
        databaseManager.transaction {
            val existing = databaseManager.scrapedApps.getByPackageName("com.example.initial")
            assertThat(existing).isNotNull()

            // Insert related app
            databaseManager.scrapedApps.insert(
                ScrapedAppDTO(
                    packageName = "com.example.related",
                    appName = "Related to ${existing?.appName}",
                    versionCode = 1L,
                    versionName = "1.0",
                    firstScrapedAt = now(),
                    lastScrapedAt = now()
                )
            )
        }

        // Verify both apps exist
        val allApps = databaseManager.scrapedApps.getAll()
        assertThat(allApps).hasSize(2)
        assertThat(allApps.map { it.packageName }).containsExactly(
            "com.example.initial",
            "com.example.related"
        )
    }
}
