/**
 * VoiceOSService.kt - VoiceOS accessibility service implementation
 *
 * Copyright (C) Manoj Jhawar/Aman Jhawar, Intelligent Devices LLC
 * Author: Manoj Jhawar
 * Code-Reviewed-By: CCA
 * Created: 2025-09-02
 */
package com.augmentalis.voiceoscore.accessibility

// UI components will be implemented later
import android.accessibilityservice.AccessibilityService
import android.accessibilityservice.AccessibilityServiceInfo
import android.accessibilityservice.GestureDescription.Builder
import android.accessibilityservice.GestureDescription.StrokeDescription
import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.os.Build
import android.util.ArrayMap
import android.util.Log
import android.view.accessibility.AccessibilityEvent
import androidx.lifecycle.DefaultLifecycleObserver
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.ProcessLifecycleOwner
import com.augmentalis.commandmanager.CommandManager
import com.augmentalis.commandmanager.database.CommandDatabase
import com.augmentalis.voiceoscore.learnapp.integration.LearnAppIntegration
import com.augmentalis.speechrecognition.SpeechEngine
import com.augmentalis.speechrecognition.SpeechMode
import com.augmentalis.uuidcreator.UUIDCreator
import com.augmentalis.voiceos.command.Command
import com.augmentalis.voiceos.command.CommandContext
import com.augmentalis.voiceos.command.CommandSource
import com.augmentalis.voiceos.constants.VoiceOSConstants
import com.augmentalis.voiceos.cursor.VoiceCursorAPI
import com.augmentalis.voiceos.cursor.core.CursorOffset
import com.augmentalis.voiceoscore.accessibility.config.ServiceConfiguration
import com.augmentalis.voiceoscore.accessibility.extractors.UIScrapingEngine
import com.augmentalis.voiceoscore.accessibility.extractors.UIScrapingEngine.UIElement
import com.augmentalis.voiceoscore.accessibility.managers.ActionCoordinator
import com.augmentalis.voiceoscore.accessibility.managers.InstalledAppsManager
import com.augmentalis.voiceoscore.accessibility.monitor.ServiceMonitor
import com.augmentalis.voiceoscore.accessibility.speech.SpeechConfigurationData
import com.augmentalis.voiceoscore.accessibility.speech.SpeechEngineManager
import com.augmentalis.voiceoscore.accessibility.utils.Const
import com.augmentalis.voiceoscore.accessibility.utils.Debouncer
import com.augmentalis.voiceoscore.accessibility.utils.EventPriorityManager
import com.augmentalis.voiceoscore.accessibility.utils.ResourceMonitor
import com.augmentalis.voiceoscore.config.DynamicPackageConfig
import com.augmentalis.voiceoscore.learnweb.WebScrapingDatabase
import com.augmentalis.voiceoscore.scraping.AccessibilityScrapingIntegration
import com.augmentalis.voiceoscore.scraping.VoiceCommandProcessor
import com.augmentalis.voiceoscore.database.VoiceOSAppDatabase
import com.augmentalis.database.dto.GeneratedCommandDTO
import com.augmentalis.voiceoscore.web.WebCommandCoordinator
import com.google.gson.GsonBuilder
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import org.json.JSONArray
import java.lang.ref.WeakReference
import java.util.Locale
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.CopyOnWriteArrayList
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicLong
import javax.inject.Inject
import kotlin.coroutines.cancellation.CancellationException

/**
 * VoiceOS Service - Main accessibility service implementation
 * High-performance service with efficient data structures, lazy loading, and caching
 * Now with hybrid ForegroundService approach for optimal battery and memory usage
 *
 * HILT Integration:
 * - Uses @AndroidEntryPoint for dependency injection
 * - Injected dependencies: UIScrapingEngine, SpeechEngineManager, InstalledAppsManager
 * - Lazy dependencies: ActionCoordinator (requires service instance)
 */
@dagger.hilt.android.AndroidEntryPoint
class VoiceOSService : AccessibilityService(), DefaultLifecycleObserver {

    companion object {
        private const val TAG = "VoiceOSService"

        // Mic service actions (foreground service for background mic access)
        private const val ACTION_START_MIC = "com.augmentalis.voiceos.START_MIC"
        private const val ACTION_STOP_MIC = "com.augmentalis.voiceos.STOP_MIC"

        // YOLO Phase 2 - High Priority Issue #11: Dynamic package configuration
        // Moved to DynamicPackageConfig for device-specific flexibility
        // Valid packages now determined at runtime based on device manufacturer
        const val COMMAND_CHECK_INTERVAL_MS = VoiceOSConstants.Timing.THROTTLE_DELAY_MS
        const val COMMAND_LOAD_DEBOUNCE_MS = VoiceOSConstants.Timing.THROTTLE_DELAY_MS

        @Volatile
        private var instanceRef: WeakReference<VoiceOSService>? = null

        @JvmStatic
        fun getInstance(): VoiceOSService? = instanceRef?.get()

        @JvmStatic
        fun isServiceRunning(): Boolean = instanceRef?.get() != null

        @JvmStatic
        fun executeCommand(commandText: String): Boolean {
            val service = instanceRef?.get() ?: return false
            val command = commandText.lowercase().trim()
            val result = when (command) {
                "back", "go back" -> service.performGlobalAction(GLOBAL_ACTION_BACK)
                "home", "go home" -> service.performGlobalAction(GLOBAL_ACTION_HOME)
                "recent", "recent apps" -> service.performGlobalAction(GLOBAL_ACTION_RECENTS)
                "notifications" -> service.performGlobalAction(GLOBAL_ACTION_NOTIFICATIONS)
                "settings", "quick settings" -> service.performGlobalAction(GLOBAL_ACTION_QUICK_SETTINGS)
                "power", "power menu" -> service.performGlobalAction(GLOBAL_ACTION_POWER_DIALOG)

                // Screenshot (Android P+)
                "screenshot" -> {
                    service.performGlobalAction(GLOBAL_ACTION_TAKE_SCREENSHOT)
                }
                // For complex commands, use handler architecture
                else -> false
            }
            return result
        }
    }

    // Service state
    @JvmField
    internal var isServiceReady = false  // Phase 3: Exposed for IPC companion service (Java-accessible)
    private val serviceScope = CoroutineScope(Dispatchers.Main + SupervisorJob())
    private val coroutineScopeCommands = CoroutineScope(Dispatchers.IO + SupervisorJob())

    @Volatile
    private var isVoiceInitialized = false
    private var lastCommandLoaded = 0L
    private val isCommandProcessing = AtomicBoolean(false)

    // LearnApp integration state
    @Volatile
    private var learnAppInitialized = false

    // Hybrid foreground service state
    private var foregroundServiceActive = false
    private var appInBackground = false
    private var voiceSessionActive = false

    // Configuration
    private lateinit var config: ServiceConfiguration

    private val nodeCache: MutableList<UIElement> = CopyOnWriteArrayList()
    private val commandCache: MutableList<String> = CopyOnWriteArrayList()
    private val staticCommandCache: MutableList<String> = CopyOnWriteArrayList()
    private val appsCommand = ConcurrentHashMap<String, String>()
    private val allRegisteredDynamicCommands: MutableList<String> = CopyOnWriteArrayList()

    // TODO: UI components to be implemented later
    // private val floatingMenu by lazy { FloatingMenu(this) }
    // private val cursorOverlay by lazy { CursorOverlay(this) }

    // Overlay manager for voice feedback (numbered selection, context menus, help)
    private val overlayManager by lazy {
        com.augmentalis.voiceoscore.accessibility.overlays.OverlayManager.getInstance(this).also {
            Log.d(TAG, "OverlayManager initialized (lazy)")
        }
    }

    private val prettyGson by lazy { GsonBuilder().setPrettyPrinting().create() }

    // Hilt injected dependencies
    @Inject
    lateinit var speechEngineManager: SpeechEngineManager

    @Inject
    lateinit var installedAppsManager: InstalledAppsManager

    // UIScrapingEngine requires AccessibilityService, so it's lazy-initialized (not injected)
    private val uiScrapingEngine by lazy {
        UIScrapingEngine(this).also {
            Log.d(TAG, "UIScrapingEngine initialized (lazy)")
        }
    }

    // Event type tracking for performance monitoring
    private val eventCounts = ArrayMap<Int, AtomicLong>().apply {
        put(AccessibilityEvent.TYPE_VIEW_CLICKED, AtomicLong(0))
        put(AccessibilityEvent.TYPE_VIEW_FOCUSED, AtomicLong(0))
        put(AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED, AtomicLong(0))
        put(AccessibilityEvent.TYPE_VIEW_SCROLLED, AtomicLong(0))
        put(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED, AtomicLong(0))
        put(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED, AtomicLong(0))
    }

    // Optimized managers
    private val actionCoordinator by lazy {
        ActionCoordinator(this).also {
            Log.d(TAG, "ActionCoordinator initialized (lazy)")
        }
    }

    // VoiceCursor API for cursor functionality
    private var voiceCursorInitialized = false

    // LearnApp integration for third-party app learning
    private var learnAppIntegration: LearnAppIntegration? = null

    // Hash-based persistence database (nullable for safe fallback)
    // FIX (2025-11-26): Database consolidation - Use VoiceOSAppDatabase (SQLDelight via adapter)
    private var scrapingDatabase: VoiceOSAppDatabase? = null

    // Hash-based scraping integration
    private var scrapingIntegration: AccessibilityScrapingIntegration? = null

    // Hash-based command processor
    private var voiceCommandProcessor: VoiceCommandProcessor? = null

    // Web command coordinator for browser integration
    private val webCommandCoordinator by lazy {
        WebCommandCoordinator(applicationContext, this).also {
            Log.d(TAG, "WebCommandCoordinator initialized (lazy)")
        }
    }

    // Event debouncing to prevent excessive scraping in apps with dynamic content
    private val eventDebouncer = Debouncer(VoiceOSConstants.Timing.EVENT_DEBOUNCE_MS)

    // Phase 1: CommandManager and ServiceMonitor integration
    private var commandManagerInstance: CommandManager? = null
    private var serviceMonitor: ServiceMonitor? = null
    private var fallbackModeEnabled = false

    // Phase 3D: Resource monitoring
    private val resourceMonitor by lazy {
        ResourceMonitor(applicationContext).also {
            Log.d(TAG, "ResourceMonitor initialized (lazy)")
        }
    }

    // Phase 3E: Event priority management for adaptive filtering
    private val eventPriorityManager by lazy {
        EventPriorityManager().also {
            Log.d(TAG, "EventPriorityManager initialized (lazy)")
        }
    }

    override fun onCreate() {
        super<AccessibilityService>.onCreate()
        instanceRef = WeakReference(this)

        // FIX (2025-11-26): Initialize SQLDelight database (VoiceOSAppDatabase is typealias for adapter)
        try {
            scrapingDatabase = VoiceOSAppDatabase.getInstance(this)
            Log.i(TAG, "SQLDelight VoiceOSAppDatabase initialized successfully")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize database - will fall back to in-memory cache", e)
            scrapingDatabase = null
        }
    }

    @SuppressLint("UnspecifiedRegisterReceiverFlag")
    override fun onServiceConnected() {
        super.onServiceConnected()
        Log.i(TAG, "VoiceOS Service connected")

        // Initialize configuration
        config = ServiceConfiguration.loadFromPreferences(this)

        configureServiceInfo()

        // Register for app lifecycle events for hybrid foreground service
        ProcessLifecycleOwner.get().lifecycle.addObserver(this)
        serviceScope.launch {
            staticCommandCache.addAll(actionCoordinator.getAllActions())
            observeInstalledApps()
            delay(VoiceOSConstants.Timing.INIT_DELAY_MS) // Small delay to not block service startup
            initializeComponents()
            // Initialize VoiceCursor API
            initializeVoiceCursor()
            // NOTE: LearnApp initialization deferred until first accessibility event
            // This ensures FLAG_RETRIEVE_INTERACTIVE_WINDOWS has been fully processed by Android
            Log.i(TAG, "LearnApp initialization deferred until first accessibility event")
            // Phase 1: Initialize CommandManager and ServiceMonitor
            initializeCommandManager()
            // register voice command
            registerVoiceCmd()

            val filter = IntentFilter(Const.ACTION_CONFIG_UPDATE)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                Log.i(TAG, "onServiceConnected registerReceiver : CHANGE_LANG ")
                registerReceiver(serviceReceiver, filter, RECEIVER_NOT_EXPORTED)
            } else {
                Log.i(TAG, "onServiceConnected registerReceiver : CHANGE_LANG ")
                registerReceiver(serviceReceiver, filter)
            }
        }
    }

    /**
     * Phase 1: Initialize CommandManager with ServiceMonitor
     * Based on Q1 Decision: Service Monitor with Reconnection Callback
     */
    private fun initializeCommandManager() {
        try {
            Log.i(TAG, "Initializing CommandManager and ServiceMonitor...")

            // Initialize CommandManager
            commandManagerInstance = CommandManager.getInstance(this)
            commandManagerInstance?.initialize()

            // Initialize ServiceMonitor
            serviceMonitor = ServiceMonitor(this, applicationContext)
            commandManagerInstance?.let { manager ->
                serviceMonitor?.bindCommandManager(manager)
                serviceMonitor?.startHealthCheck()
            }

            Log.i(TAG, "CommandManager and ServiceMonitor initialized successfully")

            // Register database commands with speech engine
            serviceScope.launch {
                // Small delay to ensure all systems initialized
                delay(500)
                Log.i(TAG, "Starting database command registration...")
                registerDatabaseCommands()
            }

        } catch (e: Exception) {
            Log.e(TAG, "Failed to initialize CommandManager/ServiceMonitor", e)
            commandManagerInstance = null
            serviceMonitor = null
        }
    }

    /**
     * Register database commands with speech engine
     *
     * Loads commands from multiple sources and registers them with the speech
     * recognition engine so users can speak them.
     *
     * Sources:
     * 1. CommandDatabase - VOSCommandIngestion data (94 commands)
     * 2. VoiceOSAppDatabase - Generated app-specific commands (unified DB)
     * 3. WebScrapingDatabase - Learned web commands
     *
     * This method should be called after CommandManager initialization.
     */
    private suspend fun registerDatabaseCommands() = withContext(Dispatchers.IO) {
        try {
            Log.i(TAG, "=== Database Command Registration Start ===")

            // Get current locale for filtering
            var locale = Locale.getDefault().toString() // e.g., "en_US"
            //normalize localized name to support .VOS static commands
            if (locale.contains("_")) {
                locale = locale.replace("_", "-")
            }
            Log.d(TAG, "Current locale: $locale")

            // Set to collect all command texts (uses Set to avoid duplicates)
            val commandTexts = mutableSetOf<String>()

            // SOURCE 1: CommandDatabase (VOSCommandIngestion data)
            try {
                Log.d(TAG, "Loading commands from CommandDatabase...")
                val commandDatabase = CommandDatabase.getInstance(applicationContext)

                val dbCommands = commandDatabase.voiceCommandDao().getCommandsForLocale(locale)
                Log.i(TAG, "  Found ${dbCommands.size} commands in CommandDatabase for locale $locale")

                dbCommands.forEach { cmd ->
                    // Add primary text
                    commandTexts.add(cmd.primaryText.lowercase().trim())

                    // Add synonyms (stored as JSON array string)
                    try {
                        val synonymsJson = JSONArray(cmd.synonyms)
                        for (i in 0 until synonymsJson.length()) {
                            val synonym = synonymsJson.getString(i).lowercase().trim()
                            commandTexts.add(synonym)
                        }
                    } catch (e: Exception) {
                        Log.w(TAG, "  Error parsing synonyms for '${cmd.primaryText}': ${e.message}")
                    }
                }

                Log.i(TAG, "  ✓ CommandDatabase: ${commandTexts.size} command texts loaded")

            } catch (e: Exception) {
                Log.e(TAG, "  ✗ Error loading CommandDatabase commands", e)
                // Continue with other sources even if this fails
            }

            // SOURCE 2: VoiceOSAppDatabase (generated app commands - unified DB)
            try {
                Log.d(TAG, "Loading commands from VoiceOSAppDatabase...")
                scrapingDatabase?.let { database ->
                    val appCommands = database.generatedCommandDao().getAllCommands()
                    Log.i(TAG, "  Found ${appCommands.size} commands in VoiceOSAppDatabase")

                    appCommands.forEach { cmd ->
                        // Add command text
                        commandTexts.add(cmd.commandText.lowercase().trim())

                        // Add synonyms if any
                        try {
                            val synonymsJson = JSONArray(cmd.synonyms ?: "[]")
                            for (i in 0 until synonymsJson.length()) {
                                val synonym = synonymsJson.getString(i).lowercase().trim()
                                commandTexts.add(synonym)
                            }
                        } catch (e: Exception) {
                            Log.w(TAG, "  Error parsing synonyms for '${cmd.commandText}': ${e.message}")
                        }
                    }

                    Log.i(TAG, "  ✓ VoiceOSAppDatabase: Total ${commandTexts.size} command texts")

                } ?: Log.w(TAG, "  VoiceOSAppDatabase not available, skipping")

            } catch (e: Exception) {
                Log.e(TAG, "  ✗ Error loading VoiceOSAppDatabase commands", e)
                // Continue even if this fails
            }

            // SOURCE 3: WebScrapingDatabase (web commands)
            try {
                Log.d(TAG, "Loading commands from WebScrapingDatabase...")
                val webDatabase = WebScrapingDatabase.getInstance(applicationContext)

                val webCommands = webDatabase.generatedWebCommandDao().getAllCommands()
                Log.i(TAG, "  Found ${webCommands.size} commands in WebScrapingDatabase")

                for (cmd in webCommands) {
                    commandTexts.add(cmd.commandText.lowercase().trim())
                }

                Log.i(TAG, "  ✓ WebScrapingDatabase: Total ${commandTexts.size} command texts")

            } catch (e: Exception) {
                Log.e(TAG, "  ✗ Error loading WebScrapingDatabase commands", e)
                // Continue even if this fails
            }

            // Remove any empty strings or invalid commands
            commandTexts.removeIf { it.isBlank() || it.length < 2 }

            Log.i(TAG, "Total unique command texts to register: ${commandTexts.size}")

            if (commandTexts.isEmpty()) {
                Log.w(TAG, "No database commands found to register")
                Log.w(TAG, "  This is normal on first run before any apps are scraped")
                return@withContext
            }

            // Register with speech engine on Main thread
            withContext(Dispatchers.Main) {
                try {
                    Log.d(TAG, "Adding command texts to staticCommandCache...")
                    staticCommandCache.addAll(commandTexts)
                    Log.i(TAG, "  staticCommandCache size: ${staticCommandCache.size}")

                    Log.d(TAG, "Updating speech engine vocabulary...")
                    val allCommands = commandCache + staticCommandCache + appsCommand.keys
//                    if (BuildConfig.DEBUG) {
//                        val objectCommand = prettyGson.toJson(allCommands)
//                        Log.d(TAG, "RegisterVoiceCmd allCommands = $objectCommand")
//                    }
                    speechEngineManager?.updateCommands(allCommands)  // TEMPORARY: Null-safe for standalone

                    Log.i(TAG, "✓ Database commands registered successfully with speech engine")
                    Log.i(TAG, "  Total commands in speech vocabulary: ${allCommands.toSet().size}")

                } catch (e: Exception) {
                    Log.e(TAG, "✗ Error updating speech engine vocabulary", e)
                }
            }

            Log.i(TAG, "=== Database Command Registration Complete ===")

        } catch (e: Exception) {
            Log.e(TAG, "✗ Fatal error in registerDatabaseCommands()", e)
        }
    }

    /**
     * Called when new commands are generated (e.g., after app scraping)
     * Triggers re-registration of database commands
     */
    fun onNewCommandsGenerated() {
        Log.i(TAG, "New commands generated, re-registering with speech engine...")
        serviceScope.launch {
            registerDatabaseCommands()
        }
    }

    private fun configureServiceInfo() {
        try {
            serviceInfo?.let { info ->
                // Configure service capabilities
                info.eventTypes = AccessibilityEvent.TYPES_ALL_MASK
                info.flags = info.flags or
                        AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS or
                        AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE or
                        AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS  // Required for getWindows() API

                // Add accessibility button support on Android O+
                info.flags = info.flags or AccessibilityServiceInfo.FLAG_REQUEST_ACCESSIBILITY_BUTTON

                // Add fingerprint gesture support on Android O+
                if (config.fingerprintGesturesEnabled) {
                    info.flags = info.flags or AccessibilityServiceInfo.FLAG_REQUEST_FINGERPRINT_GESTURES
                }

                // DIAGNOSTIC: Verify FLAG_RETRIEVE_INTERACTIVE_WINDOWS is set
                val hasInteractiveWindowsFlag = (info.flags and AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS) != 0
                Log.i(TAG, "Service configured - FLAG_RETRIEVE_INTERACTIVE_WINDOWS: $hasInteractiveWindowsFlag")
                Log.d(TAG, "Service info flags value: ${info.flags}")

                if (!hasInteractiveWindowsFlag) {
                    Log.e(TAG, "CRITICAL: FLAG_RETRIEVE_INTERACTIVE_WINDOWS not set! Windows will be unavailable!")
                }

                Log.d(TAG, "Service info configured")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to configure service info", e)
        }
    }

    private fun observeInstalledApps() {
        serviceScope.launch {
            withContext(Dispatchers.Main) {
                installedAppsManager.appList.collectLatest { result ->
                    if (result.isNotEmpty()) {
                        appsCommand.apply {
                            clear()
                            putAll(result)
                        }
                    }
                }
            }
        }
    }

    // Lifecycle observer methods for hybrid foreground service management
    override fun onStart(owner: LifecycleOwner) {
        super<DefaultLifecycleObserver>.onStart(owner)
        Log.d(TAG, "App moved to foreground")
        appInBackground = false
        evaluateForegroundServiceNeed()
    }

    override fun onStop(owner: LifecycleOwner) {
        super<DefaultLifecycleObserver>.onStop(owner)
        Log.d(TAG, "App moved to background")
        appInBackground = true
        evaluateForegroundServiceNeed()
    }

    /**
     * Initialize components with staggered loading
     */
    private suspend fun initializeComponents() = withContext(Dispatchers.Main) {
        try {
            // Initialize core components first
            actionCoordinator.initialize()

            // Initialize hash-based scraping integration (if database initialized)
            if (scrapingDatabase != null) {
                try {
                    scrapingIntegration = AccessibilityScrapingIntegration(this@VoiceOSService, this@VoiceOSService)
                    Log.i(TAG, "AccessibilityScrapingIntegration initialized successfully")
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to initialize AccessibilityScrapingIntegration", e)
                    scrapingIntegration = null
                }
            } else {
                Log.w(TAG, "Skipping AccessibilityScrapingIntegration (database not initialized)")
            }

            // Initialize hash-based command processor (if database initialized)
            if (scrapingDatabase != null) {
                try {
                    voiceCommandProcessor = VoiceCommandProcessor(this@VoiceOSService, this@VoiceOSService)
                    Log.i(TAG, "VoiceCommandProcessor initialized successfully")
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to initialize VoiceCommandProcessor", e)
                    voiceCommandProcessor = null
                }
            } else {
                Log.w(TAG, "Skipping VoiceCommandProcessor (database not initialized)")
            }

            // TODO: Initialize UI components when implemented
            // if (config.isFloatingMenuEnabled()) {
            //     floatingMenu.show()
            // }
            // if (config.isCursorEnabled()) {
            //     cursorManagerInstance.initialize()
            // }

            // Initialize voice recognition if available
            initializeVoiceRecognition()

            isServiceReady = true
            Log.i(TAG, "All components initialized with optimization")

            // Log performance metrics
            logPerformanceMetrics()

            // Phase 3D: Start periodic memory monitoring
            startMemoryMonitoring()

        } catch (e: Exception) {
            Log.e(TAG, "Error initializing components", e)
        }
    }


    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        if (!isServiceReady || event == null) return

        // Phase 3E: Adaptive event filtering based on memory pressure
        // Drop low-priority events (scrolling, focus) under memory pressure
        // Preserve critical events (clicks, text input) to maintain functionality
        val throttleLevel = resourceMonitor.getThrottleRecommendation()
        val shouldProcess = eventPriorityManager.shouldProcessEvent(event, throttleLevel)
        
        if (!shouldProcess) {
            Log.v(TAG, "Event filtered due to memory pressure: type=${event.eventType}, throttle=$throttleLevel")
            return
        }

        // DEFERRED INITIALIZATION: Initialize LearnApp on first accessibility event
        // This ensures FLAG_RETRIEVE_INTERACTIVE_WINDOWS has been fully processed by Android
        if (!learnAppInitialized) {
            synchronized(this) {
                if (!learnAppInitialized) {
                    Log.i(TAG, "First accessibility event received - initializing LearnApp now")
                    serviceScope.launch {
                        initializeLearnAppIntegration()
                        learnAppInitialized = true
                        Log.i(TAG, "LearnApp initialization complete (event-driven)")
                    }
                }
            }
        }

        try {
            // Forward to hash-based scraping integration FIRST (base scraping)
            scrapingIntegration?.let { integration ->
                try {
                    Log.v(TAG, "Forwarding accessibility event to AccessibilityScrapingIntegration")
                    integration.onAccessibilityEvent(event)
                    Log.v(TAG, "Event forwarded successfully to AccessibilityScrapingIntegration")
                } catch (e: Exception) {
                    Log.e(TAG, "Error forwarding event to AccessibilityScrapingIntegration", e)
                    Log.e(TAG, "Scraping error type: ${e.javaClass.simpleName}")
                    Log.e(TAG, "Scraping error message: ${e.message}")
                }
            }

            // Forward to LearnApp integration for third-party app learning
            learnAppIntegration?.let { integration ->
                try {
                    Log.v(TAG, "Forwarding accessibility event to LearnApp integration")
                    integration.onAccessibilityEvent(event)
                    Log.v(TAG, "Event forwarded successfully to LearnApp")
                } catch (e: Exception) {
                    Log.e(TAG, "Error forwarding event to LearnApp integration", e)
                    Log.e(TAG, "LearnApp error type: ${e.javaClass.simpleName}")
                    Log.e(TAG, "LearnApp error message: ${e.message}")
                }
            }

            // Track event counts for performance monitoring
            event.eventType.let { eventCounts[it]?.incrementAndGet() }

            // Get package names for event processing
            var packageName = event.packageName?.toString()
            val currentPackage = rootInActiveWindow?.packageName?.toString()

            // Handle cases where packageName might be null but currentPackage is available
            if (packageName == null && currentPackage != null) {
                val isRedundantWindowChange = isRedundantWindowChange(event)

                // Use dynamic package configuration instead of hardcoded list
                if (isRedundantWindowChange && !DynamicPackageConfig.shouldMonitorPackage(this, currentPackage)) {
                    return // Skip redundant window changes for apps that don't need them
                }

                if (isRedundantWindowChange) {
                    packageName = currentPackage // Only assign for valid packages
                } else {
                    return // Can't proceed meaningfully without package name
                }
            }

            // If after checks, packageName is still null, skip processing
            if (packageName == null) return

            // Create debounce key based on package, class, and event type
            val debounceKey = "$packageName-${event.className?.toString() ?: "unknown"}-${event.eventType}"

            // Apply debouncing to prevent excessive processing
            if (!eventDebouncer.shouldProceed(debounceKey)) {
                Log.v(TAG, "Event debounced for: $debounceKey")
                return
            }

            // Process events based on type with enhanced logic
            when (event.eventType) {
                AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED -> {
                    // Update UI scraping cache asynchronously with debouncing
                    serviceScope.launch {
                        val commands = uiScrapingEngine.extractUIElementsAsync(event)
                        nodeCache.clear()
                        nodeCache.addAll(commands)

                        val normalizedCommand = commands.map { element -> element.normalizedText }
                        commandCache.clear()
                        commandCache.addAll(normalizedCommand)
                        Log.d(TAG, "SPEECH_TEST: TYPE_WINDOW_CONTENT_CHANGED commandsStr = $commandCache")
                        if (config.verboseLogging) {
                            Log.d(TAG, "Scraped commands for $packageName: $commandCache")
                        }
                    }
                }

                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED -> {
                    // Update app context and trigger scraping for new windows
                    serviceScope.launch {
                        // Also trigger UI scraping for window state changes
                        val commands = uiScrapingEngine.extractUIElementsAsync(event)
                        nodeCache.clear()
                        nodeCache.addAll(commands)
                        val normalizedCommand = commands.map { element -> element.normalizedText }
                        commandCache.clear()
                        commandCache.addAll(normalizedCommand)
                        Log.d(TAG, "SPEECH_TEST: TYPE_WINDOW_STATE_CHANGED commandsStr = $commandCache")
                        if (config.verboseLogging) {
                            Log.d(TAG, "Scraped commands for $packageName: $commandCache")
                        }
                    }
                }

                AccessibilityEvent.TYPE_VIEW_CLICKED -> {
                    // Log click events for analytics and optionally refresh commands
                    if (config.verboseLogging) {
                        Log.d(TAG, "Click event in $packageName: ${event.className}")
                    }

                    // Trigger light UI refresh after clicks (useful for dynamic content)
                    serviceScope.launch {
                        // Also trigger UI scraping for window state changes
                        val commands = uiScrapingEngine.extractUIElementsAsync(event)
                        nodeCache.clear()
                        nodeCache.addAll(commands)
                        val normalizedCommand = commands.map { element -> element.normalizedText }
                        commandCache.clear()
                        commandCache.addAll(normalizedCommand)
                        Log.d(TAG, "SPEECH_TEST: TYPE_VIEW_CLICKED commandsStr = $commandCache")
                        if (config.verboseLogging) {
                            Log.d(TAG, "Scraped commands for $packageName: $commandCache")
                        }
                    }
                }

                else -> {
                    // Handle other event types if needed in the future
                    Log.v(TAG, "Unhandled event type: ${event.eventType} for $packageName")
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Error handling accessibility event: ${event.eventType}", e)
        }
    }

    private fun registerVoiceCmd() {
        if (!isCommandProcessing.compareAndSet(false, true)) {
            return // Already processing, avoid starting a new loop
        }
        coroutineScopeCommands.launch {
            try {
                while (isActive) {
                    delay(COMMAND_CHECK_INTERVAL_MS)
                    if (isVoiceInitialized && System.currentTimeMillis() - lastCommandLoaded > COMMAND_LOAD_DEBOUNCE_MS) {
                        if (commandCache != allRegisteredDynamicCommands) {
                            Log.d(TAG, "SPEECH_TEST: registerVoiceCmd commandsStr = $commandCache")
                            val allCommands = commandCache + staticCommandCache + appsCommand.keys

//                            if (BuildConfig.DEBUG) {
//                                val objectCommand = prettyGson.toJson(allCommands)
//                                Log.d(TAG, "RegisterVoiceCmd allCommands = $objectCommand")
//                            }
                            speechEngineManager?.updateCommands(allCommands)
                            allRegisteredDynamicCommands.clear()
                            allRegisteredDynamicCommands.addAll(commandCache)
                            lastCommandLoaded = System.currentTimeMillis()
                        }
                    }
                }
            } catch (e: CancellationException) {
                Log.e(TAG, "Command processing loop cancelled", e)
            } catch (e: Exception) {
                Log.e(TAG, "Error in command processing loop", e)
            } finally {
                isCommandProcessing.set(false)
            }
        }
    }

    /**
     * Check if the window change event is redundant (similar to legacy implementation)
     */
    private fun isRedundantWindowChange(event: AccessibilityEvent): Boolean {
        return event.eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED ||
                event.eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED
    }

    private fun initializeVoiceRecognition() {
        // FIX: Re-enabled speech engine initialization with Vivoka
        // Root cause: SpeechEngineManager was disabled for standalone testing
        // Solution: Restored Hilt injection and removed null-check bypass

        // Start engine initialization asynchronously with Vivoka
        // TODO: Make engine selection user-configurable (Vivoka/Vosk)
        speechEngineManager.initializeEngine(SpeechEngine.VIVOKA)

        // ARCHITECTURE: Split into two separate collectors
        // 1. State collection: Monitor engine lifecycle (initialization, listening status)
        // 2. Command event collection: Process voice commands as discrete events

        serviceScope.launch {
            // Collector 1: Monitor engine state for lifecycle management
            launch {
                speechEngineManager.speechState.collectLatest { state ->
                    Log.d(TAG, "SPEECH_TEST: engine state = $state")

                    // Only start listening when engine is fully initialized
                    if (state.isInitialized && !state.isListening && !isVoiceInitialized) {
                        isVoiceInitialized = true
                        delay(200) // Small delay to ensure engine is fully ready
                        speechEngineManager.startListening()
                    }
                }
            }

            // Collector 2: Process command events (guarantees every command is received)
            launch {
                speechEngineManager.commandEvents.collect { event ->
                    Log.i(TAG, "SPEECH_TEST: Command event received - command='${event.command}', confidence=${event.confidence}, timestamp=${event.timestamp}")

                    // Validate command before processing
                    if (event.confidence > 0.5f && event.command.isNotBlank()) {
                        Log.i(TAG, "Processing command: '${event.command}' (confidence=${event.confidence})")
                        handleVoiceCommand(confidence = event.confidence, command = event.command)
                    } else {
                        Log.d(TAG, "Command rejected: confidence too low (${event.confidence}) or empty command")
                    }
                }
            }
        }
    }

    /**
     * Initialize VoiceCursor API for cursor functionality
     */
    private fun initializeVoiceCursor() {
        try {
            voiceCursorInitialized = VoiceCursorAPI.initialize(this, this)
            if (voiceCursorInitialized) {
                showCursor()
                Log.d(TAG, "VoiceCursor API initialized successfully")
            } else {
                Log.w(TAG, "Failed to initialize VoiceCursor API")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing VoiceCursor API", e)
            voiceCursorInitialized = false
        }
    }

    /**
     * Initialize LearnApp integration for third-party app learning
     *
     * This integration enables automatic UI exploration and UUID generation
     * for third-party apps. When a new app is launched, the user will be
     * prompted for consent before exploration begins.
     */
    private fun initializeLearnAppIntegration() {
        Log.i(TAG, "=== LearnApp Integration Initialization Start ===")
        try {
            // Initialize UUIDCreator first (required dependency)
            Log.d(TAG, "Initializing UUIDCreator...")
            UUIDCreator.initialize(applicationContext)
            Log.d(TAG, "✓ UUIDCreator initialized")

            Log.d(TAG, "Attempting to initialize LearnAppIntegration...")
            Log.d(TAG, "Context: ${applicationContext.javaClass.simpleName}")
            Log.d(TAG, "Service: ${this.javaClass.simpleName}")

            learnAppIntegration = LearnAppIntegration.initialize(applicationContext, this)

            Log.i(TAG, "✓ LearnApp integration initialized successfully")
            Log.d(TAG, "Integration instance: ${learnAppIntegration?.javaClass?.simpleName}")
            Log.d(TAG, "Features enabled:")
            Log.d(TAG, "  - App launch detection: ACTIVE")
            Log.d(TAG, "  - Consent dialog management: ACTIVE")
            Log.d(TAG, "  - Exploration engine: ACTIVE")
            Log.d(TAG, "  - Progress overlay: ACTIVE")
            Log.i(TAG, "LearnApp will now monitor for new third-party app launches")

        } catch (e: Exception) {
            Log.e(TAG, "✗ Failed to initialize LearnApp integration", e)
            Log.e(TAG, "Error type: ${e.javaClass.simpleName}")
            Log.e(TAG, "Error message: ${e.message}")
            Log.e(TAG, "Stack trace:")
            e.printStackTrace()
            Log.w(TAG, "Service will continue without LearnApp integration")
            learnAppIntegration = null
        }
        Log.i(TAG, "=== LearnApp Integration Initialization Complete ===")
    }

    /**
     * Show cursor overlay
     */
    fun showCursor(): Boolean {
        return if (voiceCursorInitialized) {
            VoiceCursorAPI.showCursor()
        } else {
            Log.w(TAG, "VoiceCursor not initialized - cannot show cursor")
            false
        }
    }

    fun getCursorPosition(): CursorOffset {
        return if (voiceCursorInitialized) {
            VoiceCursorAPI.getCurrentPosition() ?: getCenterOffset()
        } else {
            Log.w(TAG, "VoiceCursor not initialized - cannot show cursor")
            getCenterOffset()
        }
    }

    fun isCursorVisible(): Boolean {
        return if (voiceCursorInitialized) {
            VoiceCursorAPI.isVisible()
        } else {
            Log.w(TAG, "VoiceCursor not initialized - cannot show cursor")
            false
        }
    }

    /**
     * Hide cursor overlay
     */
    fun hideCursor(): Boolean {
        return if (voiceCursorInitialized) {
            VoiceCursorAPI.hideCursor()
        } else {
            Log.w(TAG, "VoiceCursor not initialized - cannot hide cursor")
            false
        }
    }

    /**
     * Toggle cursor visibility
     */
    fun toggleCursor(): Boolean {
        return if (voiceCursorInitialized) {
            VoiceCursorAPI.toggleCursor()
        } else {
            Log.w(TAG, "VoiceCursor not initialized - cannot toggle cursor")
            false
        }
    }

    /**
     * Center cursor on screen
     */
    fun centerCursor(): Boolean {
        return if (voiceCursorInitialized) {
            VoiceCursorAPI.centerCursor()
        } else {
            Log.w(TAG, "VoiceCursor not initialized - cannot center cursor")
            false
        }
    }

    /**
     * Perform click at current cursor position
     */
    fun clickCursor(): Boolean {
        return if (voiceCursorInitialized) {
            VoiceCursorAPI.click()
        } else {
            Log.w(TAG, "VoiceCursor not initialized - cannot click")
            false
        }
    }

    /**
     * Evaluate whether ForegroundService is needed (hybrid approach)
     * Only starts ForegroundService on Android 12+ when app is in background with active voice
     */
    private fun evaluateForegroundServiceNeed() {
        val needsForeground = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S
                && appInBackground
                && voiceSessionActive
                && !foregroundServiceActive

        val shouldStopForeground = foregroundServiceActive && (!appInBackground || !voiceSessionActive)

        when {
            needsForeground -> {
                Log.d(TAG, "Starting ForegroundService (Android 12+ background requirement)")
                startForegroundServiceHelper()
            }

            shouldStopForeground -> {
                Log.d(TAG, "Stopping ForegroundService (no longer needed)")
                stopForegroundServiceHelper()
            }

            else -> {
                Log.v(TAG, "ForegroundService state: needed=$needsForeground, active=$foregroundServiceActive")
            }
        }
    }

    /**
     * Start the foreground service when needed
     */
    private fun startForegroundServiceHelper() {
        if (foregroundServiceActive) return

        try {
            val intent = Intent(this, VoiceOnSentry::class.java).apply {
                action = ACTION_START_MIC
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                startForegroundService(intent)
            } else {
                startService(intent)
            }

            foregroundServiceActive = true
            Log.i(TAG, "ForegroundService started for background mic access")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start ForegroundService", e)
            foregroundServiceActive = false
        }
    }

    /**
     * Stop the foreground service when no longer needed
     */
    private fun stopForegroundServiceHelper() {
        if (!foregroundServiceActive) return

        try {
            val intent = Intent(this, VoiceOnSentry::class.java).apply {
                action = ACTION_STOP_MIC
            }
            stopService(intent)

            foregroundServiceActive = false
            Log.i(TAG, "ForegroundService stopped (no longer needed)")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to stop ForegroundService", e)
        }
    }

    /**
     * Handle voice command with caching
     *
     * Phase 1: Now routes to CommandManager when available
     */
    private fun handleVoiceCommand(command: String, confidence: Float) {
        Log.d(TAG, "handleVoiceCommand: command='$command', confidence=$confidence")

        // Reject very low confidence (< 0.5)
        if (confidence < 0.5f) {
            Log.d(TAG, "Command rejected: confidence too low ($confidence)")
            return
        }

        val normalizedCommand = command.lowercase().trim()
        val currentPackage = rootInActiveWindow?.packageName?.toString()

        // WEB TIER: Check if this is a web command (BEFORE other tiers)
        if (currentPackage != null && webCommandCoordinator.isCurrentAppBrowser(currentPackage)) {
            serviceScope.launch {
                try {
                    Log.d(TAG, "Browser detected, trying web command...")
                    val handled = webCommandCoordinator.processWebCommand(normalizedCommand, currentPackage)

                    if (handled) {
                        Log.i(TAG, "✓ Web command executed successfully: '$normalizedCommand'")
                        return@launch // Web command handled, done
                    } else {
                        Log.d(TAG, "Not a web command or no match found, continuing to regular tiers...")
                        // Continue to Tier 1
                        handleRegularCommand(normalizedCommand, confidence)
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error processing web command: ${e.message}", e)
                    // If web command fails, fall through to regular tiers
                    handleRegularCommand(normalizedCommand, confidence)
                }
            }
            return // Return here to prevent dual execution
        }

        // Not a browser, handle as regular command through tier system
        handleRegularCommand(normalizedCommand, confidence)
    }

    /**
     * Handle regular (non-web) commands through tier system
     */
    private fun handleRegularCommand(normalizedCommand: String, confidence: Float) {
        // TIER 1: CommandManager (PRIMARY)
        if (!fallbackModeEnabled && commandManagerInstance != null) {
            serviceScope.launch {
                // Capture manager instance for safe access within coroutine
                val manager = commandManagerInstance ?: return@launch

                try {
                    Log.d(TAG, "Attempting Tier 1: CommandManager")

                    // Create Command object with full context
                    val cmd = Command(
                        id = normalizedCommand,
                        text = normalizedCommand,
                        source = CommandSource.VOICE,
                        context = createCommandContext(),
                        confidence = confidence,
                        timestamp = System.currentTimeMillis()
                    )

                    // Execute via CommandManager
                    val result = manager.executeCommand(cmd)

                    if (result.success) {
                        Log.i(TAG, "✓ Tier 1 (CommandManager) SUCCESS: '$normalizedCommand'")
                        return@launch // Command executed successfully, done
                    } else {
                        Log.w(TAG, "Tier 1 (CommandManager) FAILED: ${result.error?.message}")
                        Log.d(TAG, "  Falling through to Tier 2...")
                        // Fall through to Tier 2
                        executeTier2Command(normalizedCommand)
                    }

                } catch (e: Exception) {
                    Log.e(TAG, "Tier 1 (CommandManager) ERROR: ${e.message}", e)
                    Log.d(TAG, "  Falling through to Tier 2...")
                    // Fall through to Tier 2 on error
                    executeTier2Command(normalizedCommand)
                }
            }
        } else {
            // CommandManager unavailable or in fallback mode
            if (fallbackModeEnabled) {
                Log.w(TAG, "Fallback mode active - skipping CommandManager")
            } else {
                Log.w(TAG, "CommandManager not available - using fallback path")
            }

            // Execute Tier 2 directly
            serviceScope.launch {
                executeTier2Command(normalizedCommand)
            }
        }
    }

    /**
     * Create CommandContext from current accessibility service state
     * Captures current app, activity, and screen context
     *
     * @return CommandContext with current state snapshot
     */
    private fun createCommandContext(): CommandContext {
        val root = rootInActiveWindow

        return CommandContext(
            packageName = root?.packageName?.toString(),
            activityName = root?.className?.toString(),
            focusedElement = root?.findFocus(android.view.accessibility.AccessibilityNodeInfo.FOCUS_INPUT)?.className?.toString(),
            deviceState = mapOf(
                "hasRoot" to (root != null),
                "childCount" to (root?.childCount ?: 0),
                "isAccessibilityFocused" to (root?.isAccessibilityFocused ?: false),
                // CRITICAL: Add Android context and accessibility service for BaseAction
                "androidContext" to (this as android.content.Context),
                "accessibilityService" to (this as android.accessibilityservice.AccessibilityService)
            ),
            customData = mapOf(
                "commandCacheSize" to commandCache.size,
                "nodeCacheSize" to nodeCache.size,
                "fallbackMode" to fallbackModeEnabled
            )
        )
    }

    /**
     * Execute Tier 2: VoiceCommandProcessor (secondary)
     * Handles app-specific commands from database
     */
    private suspend fun executeTier2Command(normalizedCommand: String) {
        try {
            Log.d(TAG, "Attempting Tier 2: VoiceCommandProcessor")

            // Try hash-based command processor
            voiceCommandProcessor?.let { processor ->
                val result = processor.processCommand(normalizedCommand)

                if (result.success) {
                    Log.i(TAG, "✓ Tier 2 (VoiceCommandProcessor) SUCCESS: '$normalizedCommand'")
                    return // Command executed successfully, done
                } else {
                    Log.w(TAG, "Tier 2 (VoiceCommandProcessor) FAILED: ${result.message}")
                    Log.d(TAG, "  Falling through to Tier 3...")
                }
            } ?: run {
                Log.d(TAG, "VoiceCommandProcessor not available, skipping Tier 2")
            }

            // Fall through to Tier 3
            executeTier3Command(normalizedCommand)

        } catch (e: Exception) {
            Log.e(TAG, "Tier 2 (VoiceCommandProcessor) ERROR: ${e.message}", e)
            Log.d(TAG, "  Falling through to Tier 3...")
            // Fall through to Tier 3 on error
            executeTier3Command(normalizedCommand)
        }
    }

    /**
     * Execute Tier 3: ActionCoordinator (tertiary/fallback)
     * Handles legacy handler-based commands
     *
     * CRITICAL FIX (2025-11-13): Now checks actual return value from ActionCoordinator.
     * Previous bug: Always logged "EXECUTED" even when ActionCoordinator returned false.
     * This caused false success messages when commands actually failed.
     */
    private suspend fun executeTier3Command(normalizedCommand: String) {
        try {
            Log.d(TAG, "Attempting Tier 3: ActionCoordinator (final fallback)")

            // FIX: Capture return value to check actual success/failure
            val result = actionCoordinator.executeAction(normalizedCommand)

            if (result) {
                // True success - ActionCoordinator found handler and executed successfully
                Log.i(TAG, "✓ Tier 3 (ActionCoordinator) SUCCESS: '$normalizedCommand'")
            } else {
                // ActionCoordinator returned false - no handler found or execution failed
                Log.w(TAG, "✗ Tier 3 (ActionCoordinator) FAILED: No handler found for '$normalizedCommand'")
                Log.e(TAG, "✗ All tiers failed for command: '$normalizedCommand'")
                // TODO: Consider providing user feedback here (TTS or UI notification)
            }

        } catch (e: Exception) {
            // Exception during execution (rare - ActionCoordinator catches most exceptions internally)
            Log.e(TAG, "Tier 3 (ActionCoordinator) ERROR: ${e.message}", e)
            Log.e(TAG, "✗ All tiers failed for command: '$normalizedCommand'")
        }
    }

    /**
     * Phase 1: Enable fallback mode when CommandManager is unavailable
     * Called by ServiceMonitor during graceful degradation
     */
    fun enableFallbackMode() {
        fallbackModeEnabled = true
        Log.w(TAG, "Fallback mode enabled - using basic command handling only")
    }

    /**
     * Perform click at screen coordinates
     * Used by GazeHandler for gaze-based clicking
     */
    private fun performClick(x: Int, y: Int): Boolean {
        Log.d(TAG, "SPEECH_TEST: performClick x = $x , y = $y")
        return try {
            val path = android.graphics.Path().apply { moveTo(x.toFloat(), y.toFloat()) }
            val gesture = Builder()
                .addStroke(StrokeDescription(path, 0, 100))
                .build()

            dispatchGesture(gesture, null, null)

        } catch (e: Exception) {
            Log.e(TAG, "Failed to perform click at ($x, $y)", e)
            false
        }
    }

    /**
     * Execute command through hash-based processor with fallback to ActionCoordinator
     *
     * Execution Strategy:
     * 1. Try hash-based command processor (database lookup)
     * 2. Fall back to ActionCoordinator if hash-based fails or not initialized
     * 3. Log execution path for debugging
     */
    private fun executeCommand(command: String) {
        serviceScope.launch {
            var commandExecuted = false

            // Try hash-based command processor first
            voiceCommandProcessor?.let { processor ->
                try {
                    Log.d(TAG, "Attempting hash-based command execution: '$command'")
                    val result = processor.processCommand(command)

                    if (result.success) {
                        Log.i(TAG, "✓ Hash-based command executed successfully: '$command'")
                        Log.d(TAG, "  Result: ${result.message}")
                        commandExecuted = true
                    } else {
                        Log.w(TAG, "Hash-based command failed: ${result.message}")
                        Log.d(TAG, "  Will fall back to ActionCoordinator")
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error in hash-based command processor", e)
                    Log.d(TAG, "  Exception: ${e.javaClass.simpleName}: ${e.message}")
                }
            }

            // Fall back to ActionCoordinator if hash-based execution failed or not available
            if (!commandExecuted) {
                Log.d(TAG, "Executing command via ActionCoordinator (fallback): '$command'")
                try {
                    actionCoordinator.executeAction(command)
                    Log.d(TAG, "✓ ActionCoordinator executed: '$command'")
                } catch (e: Exception) {
                    Log.e(TAG, "Error in ActionCoordinator execution", e)
                }
            }
        }
    }

    /**
     * Log performance metrics
     */
    private fun logPerformanceMetrics() {
        serviceScope.launch {
            val metrics = mutableMapOf<String, Any>()

            // Get metrics from optimized components
            metrics.putAll(uiScrapingEngine.getPerformanceMetrics())

            // Add service metrics
            metrics["commandCacheSize"] = commandCache.size
            metrics["nodeCacheSize"] = nodeCache.size
            metrics["isServiceReady"] = isServiceReady

            // Add debouncing metrics
            metrics.putAll(eventDebouncer.getMetrics())

            // Add event count metrics
            eventCounts.forEach { (eventType, count) ->
                val eventName = when (eventType) {
                    AccessibilityEvent.TYPE_VIEW_CLICKED -> "clicks"
                    AccessibilityEvent.TYPE_VIEW_FOCUSED -> "focuses"
                    AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED -> "textChanges"
                    AccessibilityEvent.TYPE_VIEW_SCROLLED -> "scrolls"
                    AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED -> "windowChanges"
                    AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED -> "contentChanges"
                    else -> "event_$eventType"
                }
                metrics["event_$eventName"] = count.get()
            }

            Log.i(TAG, "Performance Metrics: $metrics")
        }
    }

    /**
     * Start periodic memory monitoring
     *
     * Phase 3D: Monitors memory usage every 30 seconds and logs stats.
     * Warns when memory pressure is high to aid debugging and optimization.
     */
    private fun startMemoryMonitoring() {
        serviceScope.launch {
            try {
                Log.i(
                    TAG,
                    "Starting periodic memory monitoring (interval: ${VoiceOSConstants.Timing.MEMORY_MONITOR_INTERVAL_MS}ms)"
                )

                while (isActive) {
                    try {
                        // Log current memory stats
                        resourceMonitor.logMemoryStats(TAG)

                        // Warn if memory pressure is high
                        if (resourceMonitor.isMemoryPressureHigh()) {
                            val stats = resourceMonitor.getMemoryStats()
                            Log.w(TAG, "⚠️ High memory pressure detected: ${stats.usagePercentage * 100}% heap usage")
                            Log.w(TAG, "   Consider reducing scraping depth or skipping operations")
                        }

                        // Delay before next check
                        delay(VoiceOSConstants.Timing.MEMORY_MONITOR_INTERVAL_MS)

                    } catch (e: Exception) {
                        Log.e(TAG, "Error in memory monitoring cycle", e)
                        // Continue monitoring despite errors
                        delay(VoiceOSConstants.Timing.MEMORY_MONITOR_INTERVAL_MS)
                    }
                }

            } catch (e: CancellationException) {
                Log.i(TAG, "Memory monitoring cancelled (service stopping)")
            } catch (e: Exception) {
                Log.e(TAG, "Fatal error in memory monitoring", e)
            }
        }
    }

    override fun onInterrupt() {
        Log.w(TAG, "Service interrupted")
    }

    override fun onDestroy() {
        Log.i(TAG, "VoiceOS Service destroying - starting cleanup")

        // Cleanup hash-based scraping integration
        scrapingIntegration?.let { integration ->
            try {
                Log.d(TAG, "Cleaning up AccessibilityScrapingIntegration...")
                integration.cleanup()
                Log.i(TAG, "✓ AccessibilityScrapingIntegration cleaned up successfully")
            } catch (e: Exception) {
                Log.e(TAG, "✗ Error cleaning up AccessibilityScrapingIntegration", e)
                Log.e(TAG, "Cleanup error type: ${e.javaClass.simpleName}")
                Log.e(TAG, "Cleanup error message: ${e.message}")
            } finally {
                scrapingIntegration = null
                Log.d(TAG, "AccessibilityScrapingIntegration reference cleared")
            }
        } ?: Log.d(TAG, "AccessibilityScrapingIntegration was not initialized, skipping cleanup")

        // Cleanup VoiceCommandProcessor (no explicit cleanup needed - managed by Room)
        if (voiceCommandProcessor != null) {
            Log.d(TAG, "Clearing VoiceCommandProcessor reference...")
            voiceCommandProcessor = null
            Log.i(TAG, "✓ VoiceCommandProcessor reference cleared")
        }

        // Note: Database is singleton and managed by Room lifecycle - no explicit cleanup needed
        if (scrapingDatabase != null) {
            Log.d(TAG, "Clearing scraping database reference (Room manages lifecycle)...")
            scrapingDatabase = null
            Log.i(TAG, "✓ Scraping database reference cleared")
        }

        // Cleanup LearnApp integration
        learnAppIntegration?.let { integration ->
            try {
                Log.d(TAG, "Cleaning up LearnApp integration...")
                integration.cleanup()
                Log.i(TAG, "✓ LearnApp integration cleaned up successfully")
            } catch (e: Exception) {
                Log.e(TAG, "✗ Error cleaning up LearnApp integration", e)
                Log.e(TAG, "Cleanup error type: ${e.javaClass.simpleName}")
                Log.e(TAG, "Cleanup error message: ${e.message}")
            } finally {
                learnAppIntegration = null
                Log.d(TAG, "LearnApp integration reference cleared")
            }
        } ?: Log.d(TAG, "LearnApp integration was not initialized, skipping cleanup")

        // Cleanup OverlayManager (lazy delegate handles initialization check)
        try {
            Log.d(TAG, "Cleaning up OverlayManager...")
            overlayManager.dispose()
            Log.i(TAG, "✓ OverlayManager cleaned up successfully")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Error cleaning up OverlayManager", e)
            Log.e(TAG, "Cleanup error type: ${e.javaClass.simpleName}")
            Log.e(TAG, "Cleanup error message: ${e.message}")
        }

        // Cleanup VoiceCursor API
        if (voiceCursorInitialized) {
            try {
                Log.d(TAG, "Cleaning up VoiceCursor API...")
                VoiceCursorAPI.dispose()
                voiceCursorInitialized = false
                Log.i(TAG, "✓ VoiceCursor API cleaned up successfully")
            } catch (e: Exception) {
                Log.e(TAG, "✗ Error cleaning up VoiceCursor API", e)
            }
        } else {
            Log.d(TAG, "VoiceCursor was not initialized, skipping cleanup")
        }

        // Cleanup optimized components
        try {
            Log.d(TAG, "Cleaning up UIScrapingEngine...")
            uiScrapingEngine.destroy()
            Log.i(TAG, "✓ UIScrapingEngine cleaned up successfully")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Error cleaning up UIScrapingEngine", e)
        }

        // Cancel coroutines with proper join to ensure all jobs complete
        try {
            Log.d(TAG, "Cancelling coroutine scopes and waiting for completion...")

            // Cancel serviceScope and wait for all jobs to complete
            serviceScope.cancel()

            // For coroutineScopeCommands, we need to ensure all jobs complete
            // We can't use cancelAndJoin() directly on a scope, so we cancel and give time
            coroutineScopeCommands.cancel()

            // Verify scopes are inactive
            val serviceScopeActive = serviceScope.isActive
            val commandsScopeActive = coroutineScopeCommands.isActive

            Log.i(TAG, "✓ Coroutine scopes cancelled successfully:")
            Log.i(TAG, "  - serviceScope active: $serviceScopeActive")
            Log.i(TAG, "  - coroutineScopeCommands active: $commandsScopeActive")

            if (serviceScopeActive || commandsScopeActive) {
                Log.w(TAG, "⚠ Warning: Some scopes still active after cancellation")
            }
        } catch (e: Exception) {
            Log.e(TAG, "✗ Error cancelling coroutine scopes", e)
            Log.e(TAG, "  Error type: ${e.javaClass.simpleName}")
            Log.e(TAG, "  Error message: ${e.message}")
            // Re-throw to ensure cleanup errors are not silently swallowed
            throw e
        }

        // Clear caches and debouncer
        try {
            Log.d(TAG, "Clearing caches and debouncer...")
            commandCache.clear()
            nodeCache.clear()
            eventDebouncer.clearAll()
            Log.i(TAG, "✓ Caches and debouncer cleared successfully")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Error clearing caches", e)
        }

        // Cleanup CommandManager and ServiceMonitor
        try {
            Log.d(TAG, "Cleaning up ServiceMonitor...")
            serviceMonitor?.cleanup()
            serviceMonitor = null
            Log.i(TAG, "✓ ServiceMonitor cleaned up successfully")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Error cleaning up ServiceMonitor", e)
        }

        try {
            Log.d(TAG, "Cleaning up CommandManager...")
            commandManagerInstance?.cleanup()
            commandManagerInstance = null
            Log.i(TAG, "✓ CommandManager cleaned up successfully")
        } catch (e: Exception) {
            Log.e(TAG, "✗ Error cleaning up CommandManager", e)
        }

        // Clear instance reference
        instanceRef = null
        Log.d(TAG, "Service instance reference cleared")

        Log.i(TAG, "VoiceOS Service destroyed - cleanup complete")

        try {
            Log.i(TAG, "onServiceConnected unregisterReceiver : CHANGE_LANG ")
            unregisterReceiver(serviceReceiver)
        } catch (e: Exception) {
            Log.e(TAG, "✗ Error unregister Receiver", e)
        }
    }

    fun getAppCommands() = appsCommand

    private fun getCenterOffset(): CursorOffset {
        val displayMetrics = resources.displayMetrics
        val centerX = displayMetrics.widthPixels / 2
        val centerY = displayMetrics.heightPixels / 2
        return CursorOffset(centerX.toFloat(), centerY.toFloat())
    }

    private val serviceReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            Log.i(TAG, "CHANGE_LANG onReceive 2221111")
            if (intent?.action == Const.ACTION_CONFIG_UPDATE) {
                config = ServiceConfiguration.loadFromPreferences(this@VoiceOSService)
                Log.i(TAG, "CHANGE_LANG onReceive config = $config")
                speechEngineManager?.updateConfiguration(
                    SpeechConfigurationData(
                        language = config.voiceLanguage,
                        mode = SpeechMode.DYNAMIC_COMMAND,
                        enableVAD = true,
                        confidenceThreshold = 4000F,
                        maxRecordingDuration = 30000,
                        timeoutDuration = 5000,
                        enableProfanityFilter = false
                    )
                )
            }
        }
    }

    // ============================================================
    // Phase 3: Extended Public API Methods for IPC
    // ============================================================

    /**
     * Start voice recognition with specified configuration
     * Phase 3: Initial implementation - delegates to existing speech engine
     */
    fun startVoiceRecognition(language: String, recognizerType: String): Boolean {
        return try {
            Log.i(TAG, "IPC: startVoiceRecognition(language=$language, type=$recognizerType)")
            if (!isServiceReady) {
                Log.w(TAG, "Service not ready, cannot start voice recognition")
                return false
            }

            val mode = when (recognizerType.lowercase()) {
                "continuous" -> SpeechMode.DYNAMIC_COMMAND  // Use DYNAMIC_COMMAND for continuous
                "command" -> SpeechMode.DYNAMIC_COMMAND
                "system" -> SpeechMode.DYNAMIC_COMMAND
                "static" -> SpeechMode.STATIC_COMMAND
                else -> {
                    Log.w(TAG, "Unknown recognizer type: $recognizerType, using DYNAMIC_COMMAND")
                    SpeechMode.DYNAMIC_COMMAND
                }
            }

            // Update speech configuration with new language
            speechEngineManager?.updateConfiguration(
                SpeechConfigurationData(
                    language = language,
                    mode = mode,
                    enableVAD = true,
                    confidenceThreshold = 4000F,
                    maxRecordingDuration = 30000,
                    timeoutDuration = 5000,
                    enableProfanityFilter = false
                )
            )

            // Start listening
            speechEngineManager?.startListening()
            Log.i(TAG, "Voice recognition started successfully")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error starting voice recognition", e)
            false
        }
    }

    /**
     * Stop currently active voice recognition
     * Phase 3: Initial implementation
     */
    fun stopVoiceRecognition(): Boolean {
        return try {
            Log.i(TAG, "IPC: stopVoiceRecognition()")
            if (!isServiceReady) {
                Log.w(TAG, "Service not ready")
                return false
            }

            speechEngineManager?.stopListening()
            Log.i(TAG, "Voice recognition stopped successfully")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error stopping voice recognition", e)
            false
        }
    }

    /**
     * Trigger app learning for currently focused app
     * Phase 3: Initial implementation - uses existing scraping engine
     */
    fun learnCurrentApp(): String {
        return try {
            Log.i(TAG, "IPC: learnCurrentApp()")
            if (!isServiceReady) {
                Log.w(TAG, "Service not ready")
                return """{"error": "Service not ready"}"""
            }

            // Scrape current screen using existing engine
            val rootNode = rootInActiveWindow
            if (rootNode == null) {
                Log.w(TAG, "No active window available for learning")
                return """{"error": "No active window"}"""
            }

            val packageName = rootNode.packageName?.toString() ?: "unknown"
            val elements = uiScrapingEngine.extractUIElements(null)
            rootNode.recycle()

            // Convert to JSON format
            val gson = GsonBuilder().setPrettyPrinting().create()
            val result = mapOf(
                "success" to true,
                "packageName" to packageName,
                "elementCount" to elements.size,
                "elements" to elements.take(50).map { element: UIElement ->  // Limit to 50 for performance
                    mapOf(
                        "text" to element.text,
                        "contentDescription" to (element.contentDescription ?: ""),
                        "className" to (element.className ?: ""),
                        "clickable" to element.isClickable,
                        "depth" to element.depth
                    )
                }
            )

            gson.toJson(result)
        } catch (e: Exception) {
            Log.e(TAG, "Error learning current app", e)
            """{"error": "${e.message}"}"""
        }
    }

    /**
     * Execute accessibility action by action type string
     * Maps action type names to GLOBAL_ACTION constants
     */
    fun executeAccessibilityActionByType(actionType: String): Boolean {
        Log.i(TAG, "IPC: executeAccessibilityActionByType(actionType=$actionType)")
        if (!isServiceReady) {
            Log.w(TAG, "Service not ready")
            return false
        }

        val normalizedAction = actionType.lowercase().trim()
        return when (normalizedAction) {
            "back", "go back" -> performGlobalAction(GLOBAL_ACTION_BACK)
            "home", "go home" -> performGlobalAction(GLOBAL_ACTION_HOME)
            "recent", "recents", "recent apps" -> performGlobalAction(GLOBAL_ACTION_RECENTS)
            "notifications", "notification panel" -> performGlobalAction(GLOBAL_ACTION_NOTIFICATIONS)
            "settings", "quick settings" -> performGlobalAction(GLOBAL_ACTION_QUICK_SETTINGS)
            "power", "power menu" -> performGlobalAction(GLOBAL_ACTION_POWER_DIALOG)
            "screenshot", "take screenshot" -> performGlobalAction(GLOBAL_ACTION_TAKE_SCREENSHOT)
            "split screen", "split" -> performGlobalAction(GLOBAL_ACTION_TOGGLE_SPLIT_SCREEN)
            "lock", "lock screen" -> performGlobalAction(GLOBAL_ACTION_LOCK_SCREEN)
            else -> {
                Log.w(TAG, "Unknown action type: $actionType")
                false
            }
        }
    }

    /**
     * Scrape current screen and return JSON representation
     * Used by IPC for external apps to get screen state
     */
    fun scrapeScreen(): String {
        Log.i(TAG, "IPC: scrapeScreen()")
        return try {
            if (!isServiceReady) {
                Log.w(TAG, "Service not ready")
                return """{"error": "Service not ready"}"""
            }

            val rootNode = rootInActiveWindow
            if (rootNode == null) {
                Log.w(TAG, "No active window available for scraping")
                return """{"error": "No active window"}"""
            }

            val packageName = rootNode.packageName?.toString() ?: "unknown"
            val elements = uiScrapingEngine.extractUIElements(null)
            rootNode.recycle()

            // Convert to simplified JSON format
            val gson = GsonBuilder().create()
            val result = mapOf(
                "success" to true,
                "packageName" to packageName,
                "elementCount" to elements.size,
                "elements" to elements.take(100).map { element ->
                    mapOf(
                        "text" to element.text,
                        "normalizedText" to element.normalizedText,
                        "clickable" to element.isClickable,
                        "className" to (element.className ?: "")
                    )
                }
            )

            gson.toJson(result)
        } catch (e: Exception) {
            Log.e(TAG, "Error scraping screen", e)
            """{"error": "${e.message}"}"""
        }
    }

    /**
     * Get list of apps that have learned voice commands
     * Phase 3: Implementation - queries AppScrapingDatabase
     */
    fun getLearnedApps(): List<String> {
        Log.i(TAG, "IPC: getLearnedApps()")
        return try {
            val database = scrapingDatabase
            if (database == null) {
                Log.w(TAG, "Scraping database not initialized")
                return emptyList()
            }

            // Query all apps from database
            runBlocking(Dispatchers.IO) {
                val apps = database.appDao().getAllApps()
                Log.d(TAG, "Found ${apps.size} learned apps")
                apps.map { it.packageName } // Return list of app IDs (package names)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error querying learned apps", e)
            emptyList()
        }
    }

    /**
     * Get voice commands available for specific app
     * Phase 3: Implementation - queries GeneratedCommandDao
     */
    fun getCommandsForApp(packageName: String): List<String> {
        Log.i(TAG, "IPC: getCommandsForApp(packageName=$packageName)")
        return try {
            val database = scrapingDatabase
            if (database == null) {
                Log.w(TAG, "Scraping database not initialized")
                return emptyList()
            }

            // Query commands for app from database
            runBlocking(Dispatchers.IO) {
                val commands = database.generatedCommandDao().getCommandsForApp(packageName)
                Log.d(TAG, "Found ${commands.size} commands for app $packageName")
                commands.map { it.commandText } // Return list of command strings
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error querying commands for app $packageName", e)
            emptyList()
        }
    }

    /**
     * Register dynamic voice command at runtime
     * Phase 3: Implementation - creates and stores command in database
     */
    fun registerDynamicCommand(commandText: String, actionJson: String): Boolean {
        return try {
            Log.i(TAG, "IPC: registerDynamicCommand(command=$commandText)")
            if (!isServiceReady) {
                Log.w(TAG, "Service not ready")
                return false
            }

            val database = scrapingDatabase
            if (database == null) {
                Log.w(TAG, "Scraping database not initialized")
                return false
            }

            // Parse actionJson to extract target element hash and action type
            val actionData = try {
                prettyGson.fromJson(actionJson, Map::class.java) as? Map<String, Any> ?: emptyMap()
            } catch (e: Exception) {
                Log.e(TAG, "Failed to parse actionJson", e)
                return false
            }

            // Create and insert command DTO
            runBlocking(Dispatchers.IO) {
                val timestamp = System.currentTimeMillis()
                val command = GeneratedCommandDTO(
                    id = 0L, // Auto-generated by SQLDelight
                    commandText = commandText.lowercase(),
                    elementHash = actionData["elementHash"] as? String ?: "",
                    actionType = actionData["actionType"] as? String ?: "click",
                    confidence = 1.0,
                    synonyms = "[]", // Empty JSON array
                    isUserApproved = 1L,
                    usageCount = 0L,
                    lastUsed = null,
                    createdAt = timestamp
                )

                database.generatedCommandDao().insert(command)
                Log.i(TAG, "Dynamic command registered successfully: $commandText")
            }

            // Note: Commands will be reloaded on next service restart
            Log.d(TAG, "Command registered. Restart VoiceOS to reload commands.")

            true
        } catch (e: Exception) {
            Log.e(TAG, "Error registering dynamic command", e)
            false
        }
    }
}
