/**
 * CleanupManagerTest.kt - Tests for CleanupManager business logic
 *
 * Copyright (C) Manoj Jhawar/Aman Jhawar, Intelligent Devices LLC
 * Author: VOS4 Development Team
 * Code-Reviewed-By: CCA
 * Created: 2025-12-14
 *
 * Tests CleanupManager safety features:
 * - Preview mode (dry-run)
 * - Execute mode (actual deletion)
 * - Grace period enforcement
 * - User-approved preservation
 * - Safety limit (90% max deletion)
 */

package com.augmentalis.voiceoscore.cleanup

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.augmentalis.database.DatabaseDriverFactory
import com.augmentalis.database.VoiceOSDatabaseManager
import com.augmentalis.database.dto.GeneratedCommandDTO
import com.augmentalis.database.repositories.impl.SQLDelightGeneratedCommandRepository
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * Tests for CleanupManager.
 *
 * Validates safety features and cleanup logic.
 */
@RunWith(AndroidJUnit4::class)
class CleanupManagerTest {

    private lateinit var context: Context
    private lateinit var databaseManager: VoiceOSDatabaseManager
    private lateinit var commandRepo: SQLDelightGeneratedCommandRepository
    private lateinit var cleanupManager: CleanupManager

    @Before
    fun setup() {
        context = ApplicationProvider.getApplicationContext()
        val driverFactory = DatabaseDriverFactory(context)
        databaseManager = VoiceOSDatabaseManager.getInstance(driverFactory)

        commandRepo = SQLDelightGeneratedCommandRepository(databaseManager.database)
        cleanupManager = CleanupManager(commandRepo)

        // Clear existing data
        runBlocking {
            databaseManager.database.transaction {
                databaseManager.database.generatedCommandQueries.deleteAll()
            }
        }
    }

    @After
    fun tearDown() {
        runBlocking {
            databaseManager.database.transaction {
                databaseManager.database.generatedCommandQueries.deleteAll()
            }
        }
    }

    /**
     * Test 1: Preview mode doesn't delete anything
     */
    @Test
    fun testPreviewModeDoesNotDelete() = runBlocking {
        val packageName = "com.example.previewtest"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create old deprecated command
        val command = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_old",
            commandText = "click old button",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 0L,
            usageCount = 0L,
            lastUsed = null,
            createdAt = now - gracePeriodMs - 1000,
            appId = packageName,
            appVersion = "1.0.0",
            versionCode = 100L,
            lastVerified = now - gracePeriodMs - 1000,
            isDeprecated = 1L
        )
        commandRepo.insert(command)

        // Run preview
        val result = cleanupManager.previewCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true
        )

        // Verify preview shows 1 command would be deleted
        assertTrue(result.deletedCount > 0, "Preview should show commands would be deleted")

        // Verify command still exists
        val commands = commandRepo.getByPackage(packageName)
        assertEquals(1, commands.size, "Command should not be deleted in preview mode")
    }

    /**
     * Test 2: Execute mode actually deletes
     */
    @Test
    fun testExecuteModeDeletesCommands() = runBlocking {
        val packageName = "com.example.executetest"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create old deprecated command
        val command = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_old",
            commandText = "click old button",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 0L,
            usageCount = 0L,
            lastUsed = null,
            createdAt = now - gracePeriodMs - 1000,
            appId = packageName,
            appVersion = "1.0.0",
            versionCode = 100L,
            lastVerified = now - gracePeriodMs - 1000,
            isDeprecated = 1L
        )
        commandRepo.insert(command)

        // Verify command exists
        var commands = commandRepo.getByPackage(packageName)
        assertEquals(1, commands.size)

        // Execute cleanup
        val result = cleanupManager.executeCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true,
            dryRun = false
        )

        // Verify deletion
        assertEquals(1, result.deletedCount, "Should delete 1 command")

        // Verify command deleted
        commands = commandRepo.getByPackage(packageName)
        assertEquals(0, commands.size, "Command should be deleted")
    }

    /**
     * Test 3: Grace period enforcement
     */
    @Test
    fun testGracePeriodEnforcement() = runBlocking {
        val packageName = "com.example.gracetest"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create command just beyond grace period (31 days old)
        val oldCommand = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_old",
            commandText = "click old button",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 0L,
            usageCount = 0L,
            lastUsed = null,
            createdAt = now - gracePeriodMs - 86400000L,  // 31 days
            appId = packageName,
            appVersion = "1.0.0",
            versionCode = 100L,
            lastVerified = now - gracePeriodMs - 86400000L,
            isDeprecated = 1L
        )
        commandRepo.insert(oldCommand)

        // Create command just within grace period (29 days old)
        val recentCommand = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_recent",
            commandText = "click recent button",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 0L,
            usageCount = 0L,
            lastUsed = null,
            createdAt = now - gracePeriodMs + 86400000L,  // 29 days
            appId = packageName,
            appVersion = "1.5.0",
            versionCode = 150L,
            lastVerified = now - gracePeriodMs + 86400000L,
            isDeprecated = 1L
        )
        commandRepo.insert(recentCommand)

        // Execute cleanup with 30-day grace period
        val result = cleanupManager.executeCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true,
            dryRun = false
        )

        // Verify only old command deleted
        assertEquals(1, result.deletedCount, "Should delete 1 old command")

        // Verify recent command preserved
        val remaining = commandRepo.getByPackage(packageName)
        assertEquals(1, remaining.size, "Should have 1 command remaining")
        assertEquals("hash_recent", remaining[0].elementHash)
    }

    /**
     * Test 4: User-approved commands always preserved
     */
    @Test
    fun testUserApprovedAlwaysPreserved() = runBlocking {
        val packageName = "com.example.approvedtest"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create old deprecated user-approved command
        val approvedCommand = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_approved",
            commandText = "click approved button",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 1L,  // User approved
            usageCount = 10L,
            lastUsed = now - 1000,
            createdAt = now - gracePeriodMs - 1000,  // Beyond grace period
            appId = packageName,
            appVersion = "1.0.0",
            versionCode = 100L,
            lastVerified = now - gracePeriodMs - 1000,
            isDeprecated = 1L  // Deprecated
        )
        commandRepo.insert(approvedCommand)

        // Execute cleanup with keepUserApproved=true
        val result = cleanupManager.executeCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true,
            dryRun = false
        )

        // Verify user-approved command preserved
        assertEquals(0, result.deletedCount, "Should not delete user-approved command")

        val remaining = commandRepo.getByPackage(packageName)
        assertEquals(1, remaining.size)
        assertEquals(1L, remaining[0].isUserApproved)
    }

    /**
     * Test 5: keepUserApproved=false deletes all eligible
     */
    @Test
    fun testKeepUserApprovedFalseDeletesAll() = runBlocking {
        val packageName = "com.example.deletealltest"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create old deprecated user-approved command
        val approvedCommand = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_approved",
            commandText = "click approved button",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 1L,  // User approved
            usageCount = 10L,
            lastUsed = now - 1000,
            createdAt = now - gracePeriodMs - 1000,
            appId = packageName,
            appVersion = "1.0.0",
            versionCode = 100L,
            lastVerified = now - gracePeriodMs - 1000,
            isDeprecated = 1L
        )
        commandRepo.insert(approvedCommand)

        // Execute cleanup with keepUserApproved=false
        val result = cleanupManager.executeCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = false,  // Don't preserve user-approved
            dryRun = false
        )

        // Verify user-approved command deleted
        assertEquals(1, result.deletedCount, "Should delete user-approved command")

        val remaining = commandRepo.getByPackage(packageName)
        assertEquals(0, remaining.size)
    }

    /**
     * Test 6: Configurable grace period
     */
    @Test
    fun testConfigurableGracePeriod() = runBlocking {
        val packageName = "com.example.configurabletest"
        val now = System.currentTimeMillis()

        // Create command 15 days old
        val command = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_15days",
            commandText = "click button",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 0L,
            usageCount = 0L,
            lastUsed = null,
            createdAt = now - (15 * 86400000L),
            appId = packageName,
            appVersion = "1.0.0",
            versionCode = 100L,
            lastVerified = now - (15 * 86400000L),
            isDeprecated = 1L
        )
        commandRepo.insert(command)

        // Test 1: 30-day grace period should preserve it
        var result = cleanupManager.previewCleanup(
            gracePeriodDays = 30,
            keepUserApproved = true
        )
        assertEquals(0, result.deletedCount, "30-day grace should preserve 15-day-old command")

        // Test 2: 7-day grace period should delete it
        result = cleanupManager.previewCleanup(
            gracePeriodDays = 7,
            keepUserApproved = true
        )
        assertTrue(result.deletedCount > 0, "7-day grace should delete 15-day-old command")
    }

    /**
     * Test 7: Empty database doesn't error
     */
    @Test
    fun testEmptyDatabaseDoesNotError() = runBlocking {
        // Execute cleanup on empty database
        val result = cleanupManager.executeCleanup(
            gracePeriodDays = 30,
            keepUserApproved = true,
            dryRun = false
        )

        // Should complete successfully with 0 deletions
        assertEquals(0, result.deletedCount)
        assertEquals(0, result.errors.size)
    }

    /**
     * Test 8: Only deprecated commands are affected
     */
    @Test
    fun testOnlyDeprecatedCommandsAffected() = runBlocking {
        val packageName = "com.example.activetest"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create old deprecated command
        val deprecatedCommand = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_deprecated",
            commandText = "click deprecated",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 0L,
            usageCount = 0L,
            lastUsed = null,
            createdAt = now - gracePeriodMs - 1000,
            appId = packageName,
            appVersion = "1.0.0",
            versionCode = 100L,
            lastVerified = now - gracePeriodMs - 1000,
            isDeprecated = 1L  // Deprecated
        )
        commandRepo.insert(deprecatedCommand)

        // Create old active command (should be preserved regardless of age)
        val activeCommand = GeneratedCommandDTO(
            id = 0L,
            elementHash = "hash_active",
            commandText = "click active",
            actionType = "click",
            confidence = 0.85,
            synonyms = null,
            isUserApproved = 0L,
            usageCount = 0L,
            lastUsed = null,
            createdAt = now - gracePeriodMs - 1000,  // Also old
            appId = packageName,
            appVersion = "2.0.0",
            versionCode = 200L,
            lastVerified = now - gracePeriodMs - 1000,
            isDeprecated = 0L  // Active
        )
        commandRepo.insert(activeCommand)

        // Execute cleanup
        val result = cleanupManager.executeCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true,
            dryRun = false
        )

        // Verify only deprecated deleted
        assertEquals(1, result.deletedCount)

        val remaining = commandRepo.getByPackage(packageName)
        assertEquals(1, remaining.size)
        assertEquals("hash_active", remaining[0].elementHash)
        assertEquals(0L, remaining[0].isDeprecated, "Remaining should be active")
    }

    /**
     * Test 9: Safety limit allows 89% deletion (under threshold)
     */
    @Test
    fun testSafetyLimitAllows89PercentDeletion() = runBlocking {
        val packageName = "com.example.safetylimit89"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create 100 commands: 89 deprecated (eligible), 11 active (safe)
        (1..100).forEach { i ->
            val command = GeneratedCommandDTO(
                id = 0L,
                elementHash = "hash_$i",
                commandText = "command $i",
                actionType = "click",
                confidence = 0.85,
                synonyms = null,
                isUserApproved = 0L,
                usageCount = 0L,
                lastUsed = null,
                createdAt = now - gracePeriodMs - 1000,  // All old
                appId = packageName,
                appVersion = "1.0.0",
                versionCode = 100L,
                lastVerified = now - gracePeriodMs - 1000,
                isDeprecated = if (i <= 89) 1L else 0L  // 89 deprecated, 11 active
            )
            commandRepo.insert(command)
        }

        // Execute cleanup - should succeed (89% < 90% threshold)
        val result = cleanupManager.executeCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true,
            dryRun = false
        )

        // Verify: Should delete 89 commands (89% of 100)
        assertEquals(89, result.deletedCount, "Should delete 89% of commands")
        assertTrue(result.errors.isEmpty(), "Should complete without errors")

        // Verify 11 active commands remain
        val remaining = commandRepo.getByPackage(packageName)
        assertEquals(11, remaining.size, "11 active commands should remain")
    }

    /**
     * Test 10: Safety limit refuses 91% deletion (over threshold)
     */
    @Test(expected = IllegalStateException::class)
    fun testSafetyLimitRefuses91PercentDeletion() = runBlocking {
        val packageName = "com.example.safetylimit91"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create 100 commands: 91 deprecated (too many), 9 active
        (1..100).forEach { i ->
            val command = GeneratedCommandDTO(
                id = 0L,
                elementHash = "hash_$i",
                commandText = "command $i",
                actionType = "click",
                confidence = 0.85,
                synonyms = null,
                isUserApproved = 0L,
                usageCount = 0L,
                lastUsed = null,
                createdAt = now - gracePeriodMs - 1000,  // All old
                appId = packageName,
                appVersion = "1.0.0",
                versionCode = 100L,
                lastVerified = now - gracePeriodMs - 1000,
                isDeprecated = if (i <= 91) 1L else 0L  // 91 deprecated, 9 active
            )
            commandRepo.insert(command)
        }

        // Execute cleanup - should throw IllegalStateException (91% > 90%)
        cleanupManager.executeCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true,
            dryRun = false
        )

        // If we get here, test fails (exception should have been thrown)
    }

    /**
     * Test 11: Safety limit boundary - exactly 90% deletion
     */
    @Test
    fun testSafetyLimitBoundaryExactly90Percent() = runBlocking {
        val packageName = "com.example.safetylimit90"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create 100 commands: 90 deprecated (exactly at limit), 10 active
        (1..100).forEach { i ->
            val command = GeneratedCommandDTO(
                id = 0L,
                elementHash = "hash_$i",
                commandText = "command $i",
                actionType = "click",
                confidence = 0.85,
                synonyms = null,
                isUserApproved = 0L,
                usageCount = 0L,
                lastUsed = null,
                createdAt = now - gracePeriodMs - 1000,  // All old
                appId = packageName,
                appVersion = "1.0.0",
                versionCode = 100L,
                lastVerified = now - gracePeriodMs - 1000,
                isDeprecated = if (i <= 90) 1L else 0L  // Exactly 90 deprecated
            )
            commandRepo.insert(command)
        }

        // Execute cleanup - 90% should be rejected (>= 90% threshold)
        var exceptionThrown = false
        try {
            cleanupManager.executeCleanup(
                gracePeriodDays = gracePeriodDays,
                keepUserApproved = true,
                dryRun = false
            )
        } catch (e: IllegalStateException) {
            exceptionThrown = true
            assertTrue(
                "Error message should mention safety limit",
                e.message?.contains("Safety limit exceeded") == true
            )
        }

        assertTrue("90% deletion should trigger safety limit", exceptionThrown)

        // Verify no commands deleted
        val remaining = commandRepo.getByPackage(packageName)
        assertEquals(100, remaining.size, "No commands should be deleted when safety limit triggered")
    }

    /**
     * Test 12: Preview mode calculates deletion percentage correctly
     */
    @Test
    fun testPreviewCalculatesDeletionPercentage() = runBlocking {
        val packageName = "com.example.percentagetest"
        val now = System.currentTimeMillis()
        val gracePeriodDays = 30
        val gracePeriodMs = gracePeriodDays * 86400000L

        // Create 200 commands: 90 deprecated (45%)
        (1..200).forEach { i ->
            val command = GeneratedCommandDTO(
                id = 0L,
                elementHash = "hash_$i",
                commandText = "command $i",
                actionType = "click",
                confidence = 0.85,
                synonyms = null,
                isUserApproved = 0L,
                usageCount = 0L,
                lastUsed = null,
                createdAt = now - gracePeriodMs - 1000,  // All old
                appId = packageName,
                appVersion = "1.0.0",
                versionCode = 100L,
                lastVerified = now - gracePeriodMs - 1000,
                isDeprecated = if (i <= 90) 1L else 0L  // 90 deprecated (45%)
            )
            commandRepo.insert(command)
        }

        // Preview cleanup
        val preview = cleanupManager.previewCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true
        )

        // Verify percentage calculation
        assertEquals(90, preview.deletedCount, "Should identify 90 commands for deletion")

        // Execute should succeed (45% < 90%)
        val result = cleanupManager.executeCleanup(
            gracePeriodDays = gracePeriodDays,
            keepUserApproved = true,
            dryRun = false
        )

        assertEquals(90, result.deletedCount, "Should delete 45% of commands")
        assertTrue(result.errors.isEmpty(), "Should complete without errors")
    }
}
