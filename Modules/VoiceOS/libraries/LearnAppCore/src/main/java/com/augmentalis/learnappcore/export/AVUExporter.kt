/**
 * AVUExporter.kt - Exports exploration data to AVU format
 *
 * Generates .vos files in the compact AVU (Avanues Universal) format.
 * Format specification: VoiceOS-AVU-UNIVERSAL-FORMAT-SPEC-50312-V1.md
 *
 * Author: Manoj Jhawar
 * Created: 2025-12-11
 * Related: VoiceOS-LearnApp-DualEdition-Spec-51211-V1.md Section 4
 *
 * ## AVU Format Structure:
 * ```
 * # Avanues Universal Format v1.0
 * # Type: VOS
 * ---
 * schema: avu-1.0
 * version: 1.0.0
 * locale: en-US
 * project: voiceos
 * metadata:
 *   file: com.app.package.vos
 *   category: learned_app
 *   count: 87
 * ---
 * APP:package:name:timestamp
 * STA:screens:elements:commands:avg_depth:max_depth:coverage
 * SCR:hash:activity:timestamp:element_count
 * ELM:uuid:label:type:actions:bounds:category
 * NAV:from_hash:to_hash:trigger_uuid:trigger_label:timestamp
 * DNC:element_id:label:type:reason
 * DYN:screen_hash:region_id:change_type
 * MNU:menu_id:total_items:visible_items:menu_type
 * CMD:uuid:trigger:action:element_uuid:confidence
 * ---
 * synonyms:
 *   word: [syn1, syn2]
 * ```
 *
 * @since 2.0.0 (LearnApp Dual-Edition)
 */

package com.augmentalis.learnappcore.export

import android.content.Context
import android.util.Log
import com.augmentalis.learnappcore.exploration.ExplorationState
import com.augmentalis.learnappcore.exploration.ExplorationStats
import com.augmentalis.learnappcore.exploration.NavigationRecord
import com.augmentalis.learnappcore.models.ElementInfo
import com.augmentalis.learnappcore.safety.*
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.*

/**
 * Export mode for AVU files.
 */
enum class ExportMode {
    /** User edition: Encrypted, minimal metadata */
    USER,

    /** Developer edition: Unencrypted, full debugging info */
    DEVELOPER
}

/**
 * Result of AVU export operation.
 */
data class ExportResult(
    val success: Boolean,
    val filePath: String?,
    val lineCount: Int,
    val errorMessage: String? = null
)

/**
 * Generated command for AVU export.
 */
data class GeneratedCommand(
    val uuid: String,
    val trigger: String,
    val action: String,
    val elementUuid: String,
    val confidence: Float
) {
    fun toCmdLine(): String {
        return "CMD:$uuid:$trigger:$action:$elementUuid:${"%.2f".format(confidence)}"
    }
}

/**
 * Synonym set for AVU export.
 */
data class SynonymSet(
    val word: String,
    val synonyms: List<String>
) {
    fun toYamlLine(): String {
        val synList = synonyms.joinToString(", ") { it }
        return "  $word: [$synList]"
    }
}

/**
 * AVU Exporter - Generates .vos files from exploration data
 */
class AVUExporter(
    private val context: Context,
    private val mode: ExportMode = ExportMode.USER
) {
    companion object {
        private const val TAG = "AVUExporter"
        private const val SCHEMA_VERSION = "avu-1.0"
        private const val FORMAT_VERSION = "1.0.0"
        private const val LOCALE = "en-US"
        private const val PROJECT = "voiceos"
    }

    /**
     * Export exploration state to AVU file.
     *
     * @param state Exploration state to export
     * @param commands Generated commands
     * @param synonyms Synonym sets
     * @return ExportResult with file path
     */
    fun export(
        state: ExplorationState,
        commands: List<GeneratedCommand> = emptyList(),
        synonyms: List<SynonymSet> = emptyList()
    ): ExportResult {
        val lines = mutableListOf<String>()

        try {
            // Header comments
            lines.add("# Avanues Universal Format v1.0")
            lines.add("# Type: VOS")
            lines.add("# Extension: .vos")
            lines.add("# Generated by: LearnApp v2.0")
            lines.add("# Mode: ${mode.name}")
            lines.add("# Timestamp: ${System.currentTimeMillis()}")

            // Schema section
            lines.add("---")
            lines.add("schema: $SCHEMA_VERSION")
            lines.add("version: $FORMAT_VERSION")
            lines.add("locale: $LOCALE")
            lines.add("project: $PROJECT")
            lines.add("metadata:")
            lines.add("  file: ${state.packageName}.vos")
            lines.add("  category: learned_app")
            lines.add("  count: ${countDataLines(state, commands)}")
            lines.add("  exploration_mode: ${if (mode == ExportMode.DEVELOPER) "developer" else "automated"}")
            lines.add("  duration_s: ${state.getStats().durationMs / 1000}")
            lines.add("  timestamp: ${System.currentTimeMillis()}")

            // Data section
            lines.add("---")

            // APP line
            lines.add("APP:${state.packageName}:${state.appName}:${System.currentTimeMillis()}")

            // STA line (statistics)
            val stats = state.getStats()
            lines.add(stats.toStaLine())

            // SCR lines (screens)
            for (fingerprint in state.getScreenFingerprints()) {
                lines.add(fingerprint.toScrLine())

                // ELM lines for this screen
                val screenElements = state.getElementsForScreen(fingerprint.screenHash)
                for (element in screenElements) {
                    lines.add(element.toElmLine())
                }
            }

            // NAV lines (navigation)
            for (nav in state.getNavigationHistory()) {
                lines.add(nav.toNavLine())
            }

            // DNC lines (do not click)
            for ((element, reason) in state.getDangerousElements()) {
                lines.add(DoNotClickList.toDncLine(element, reason))
            }

            // DYN lines (dynamic regions)
            for (region in state.getDynamicRegions()) {
                lines.add(region.toDynLine())
            }

            // MNU lines (menus)
            for (menu in state.getMenus()) {
                lines.add(menu.toMnuLine())
            }

            // CMD lines (generated commands)
            for (cmd in commands) {
                lines.add(cmd.toCmdLine())
            }

            // Synonyms section (if any)
            if (synonyms.isNotEmpty()) {
                lines.add("---")
                lines.add("synonyms:")
                for (syn in synonyms) {
                    lines.add(syn.toYamlLine())
                }
            }

            // Write to file
            val filePath = writeToFile(state.packageName, lines)

            Log.i(TAG, "Exported ${lines.size} lines to $filePath")

            return ExportResult(
                success = true,
                filePath = filePath,
                lineCount = lines.size
            )

        } catch (e: Exception) {
            Log.e(TAG, "Export failed", e)
            return ExportResult(
                success = false,
                filePath = null,
                lineCount = 0,
                errorMessage = e.message
            )
        }
    }

    /**
     * Export to string (for clipboard or preview).
     */
    fun exportToString(
        state: ExplorationState,
        commands: List<GeneratedCommand> = emptyList(),
        synonyms: List<SynonymSet> = emptyList()
    ): String {
        val result = export(state, commands, synonyms)
        if (!result.success || result.filePath == null) {
            return "# Export failed: ${result.errorMessage}"
        }

        return File(result.filePath).readText()
    }

    /**
     * Count data lines (excluding headers and comments).
     */
    private fun countDataLines(state: ExplorationState, commands: List<GeneratedCommand>): Int {
        var count = 1 // APP line
        count += 1 // STA line
        count += state.getScreenFingerprints().size // SCR lines
        count += state.getElements().size // ELM lines
        count += state.getNavigationHistory().size // NAV lines
        count += state.getDangerousElements().size // DNC lines
        count += state.getDynamicRegions().size // DYN lines
        count += state.getMenus().size // MNU lines
        count += commands.size // CMD lines
        return count
    }

    /**
     * Write lines to file.
     */
    private fun writeToFile(packageName: String, lines: List<String>): String {
        val exportDir = when (mode) {
            ExportMode.USER -> File(context.getExternalFilesDir(null), "exports")
            ExportMode.DEVELOPER -> File(context.getExternalFilesDir(null), "exports/dev")
        }

        if (!exportDir.exists()) {
            exportDir.mkdirs()
        }

        val timestamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())
        val fileName = "${packageName}_$timestamp.vos"
        val file = File(exportDir, fileName)

        FileOutputStream(file).use { fos ->
            for (line in lines) {
                fos.write("$line\n".toByteArray())
            }
        }

        return file.absolutePath
    }

    /**
     * Parse AVU file back to exploration data.
     */
    fun parseAvuFile(filePath: String): ParsedAvuData? {
        return try {
            val file = File(filePath)
            if (!file.exists()) return null

            val lines = file.readLines()
            parseAvuLines(lines)
        } catch (e: Exception) {
            Log.e(TAG, "Failed to parse AVU file", e)
            null
        }
    }

    /**
     * Parse AVU lines.
     */
    private fun parseAvuLines(lines: List<String>): ParsedAvuData {
        val data = ParsedAvuData()
        var section = "header"

        for (line in lines) {
            val trimmed = line.trim()

            // Skip empty lines and comments
            if (trimmed.isEmpty() || trimmed.startsWith("#")) continue

            // Section delimiter
            if (trimmed == "---") {
                section = when (section) {
                    "header" -> "schema"
                    "schema" -> "data"
                    "data" -> "synonyms"
                    else -> section
                }
                continue
            }

            // Parse based on section
            when (section) {
                "schema" -> parseSchemaLine(trimmed, data)
                "data" -> parseDataLine(trimmed, data)
                "synonyms" -> parseSynonymLine(trimmed, data)
            }
        }

        return data
    }

    private fun parseSchemaLine(line: String, data: ParsedAvuData) {
        // Parse YAML-like schema lines
        val parts = line.split(":", limit = 2)
        if (parts.size == 2) {
            val key = parts[0].trim()
            val value = parts[1].trim()
            data.metadata[key] = value
        }
    }

    private fun parseDataLine(line: String, data: ParsedAvuData) {
        val code = line.substringBefore(":")

        when (code) {
            "APP" -> data.appLine = line
            "STA" -> data.statsLine = line
            "SCR" -> data.screenLines.add(line)
            "ELM" -> data.elementLines.add(line)
            "NAV" -> data.navigationLines.add(line)
            "DNC" -> data.dncLines.add(line)
            "DYN" -> data.dynLines.add(line)
            "MNU" -> data.mnuLines.add(line)
            "CMD" -> data.cmdLines.add(line)
            "CNT" -> data.contactLines.add(line)
            "SYN" -> data.synLines.add(line)
        }
    }

    private fun parseSynonymLine(line: String, data: ParsedAvuData) {
        // Parse YAML synonym format: word: [syn1, syn2]
        if (line.contains(":") && line.contains("[")) {
            val word = line.substringBefore(":").trim()
            val synsStr = line.substringAfter("[").substringBefore("]")
            val synonyms = synsStr.split(",").map { it.trim() }
            data.synonyms[word] = synonyms
        }
    }
}

/**
 * Parsed AVU data structure.
 */
data class ParsedAvuData(
    val metadata: MutableMap<String, String> = mutableMapOf(),
    var appLine: String = "",
    var statsLine: String = "",
    val screenLines: MutableList<String> = mutableListOf(),
    val elementLines: MutableList<String> = mutableListOf(),
    val navigationLines: MutableList<String> = mutableListOf(),
    val dncLines: MutableList<String> = mutableListOf(),
    val dynLines: MutableList<String> = mutableListOf(),
    val mnuLines: MutableList<String> = mutableListOf(),
    val cmdLines: MutableList<String> = mutableListOf(),
    val contactLines: MutableList<String> = mutableListOf(),
    val synLines: MutableList<String> = mutableListOf(),
    val synonyms: MutableMap<String, List<String>> = mutableMapOf()
) {
    fun getPackageName(): String {
        if (appLine.isEmpty()) return ""
        val parts = appLine.split(":")
        return if (parts.size > 1) parts[1] else ""
    }

    fun getAppName(): String {
        if (appLine.isEmpty()) return ""
        val parts = appLine.split(":")
        return if (parts.size > 2) parts[2] else ""
    }

    fun getStats(): ExplorationStats? {
        return ExplorationStats.fromAvuLine(statsLine)
    }

    fun getScreenCount(): Int = screenLines.size
    fun getElementCount(): Int = elementLines.size
    fun getCommandCount(): Int = cmdLines.size
}
