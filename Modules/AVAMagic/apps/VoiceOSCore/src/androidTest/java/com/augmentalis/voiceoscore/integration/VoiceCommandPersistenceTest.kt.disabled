/**
 * VoiceCommandPersistenceTest.kt - Tests for cross-session command persistence
 *
 * Copyright (C) Manoj Jhawar/Aman Jhawar, Intelligent Devices LLC
 * Author: VOS4 Development Team
 * Code-Reviewed-By: CCA
 * Created: 2025-10-10
 */
package com.augmentalis.voiceoscore.integration

import android.content.Context
import androidx.room.Room
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.augmentalis.voiceoscore.scraping.AppHashCalculator
import com.augmentalis.voiceoscore.scraping.CommandResult
import com.augmentalis.voiceoscore.scraping.VoiceCommandProcessor
import com.augmentalis.voiceoscore.scraping.database.AppScrapingDatabase
import com.augmentalis.voiceoscore.scraping.entities.GeneratedCommandEntity
import com.augmentalis.voiceoscore.scraping.entities.ScrapedAppEntity
import com.augmentalis.voiceoscore.scraping.entities.ScrapedElementEntity
import com.augmentalis.voiceoscore.mocks.MockVoiceAccessibilityService
import kotlinx.coroutines.runBlocking
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith

/**
 * Cross-session persistence tests
 *
 * Phase 4.3: Verify that voice commands persist across app restarts and that
 * hash-based element lookup works correctly in all scenarios.
 *
 * Test Coverage:
 * 1. Commands survive database close/reopen cycles
 * 2. Command execution works after "restart"
 * 3. Orphaned commands handled gracefully
 * 4. Hash stability guarantees (identical elements → same hash)
 * 5. Hash uniqueness guarantees (different contexts → different hashes)
 *
 * Note: This test uses deprecated AppHashCalculator for testing persistence behavior.
 * The deprecation is suppressed as we're testing the persistence layer, not the
 * hashing algorithm. Production code should use AccessibilityFingerprint.
 */
@Suppress("DEPRECATION")
@RunWith(AndroidJUnit4::class)
class VoiceCommandPersistenceTest {

    companion object {
        private const val TAG = "VoiceCommandPersistenceTest"
        private const val TEST_DB_NAME = "test_persistence_db"
        private const val TEST_APP_PACKAGE = "com.test.app"
        private const val TEST_APP_VERSION = 1
    }

    private lateinit var context: Context
    private lateinit var database: AppScrapingDatabase
    private lateinit var mockService: MockVoiceAccessibilityService
    private lateinit var testAppId: String

    @Before
    fun setUp() = runBlocking {
        context = ApplicationProvider.getApplicationContext()
        mockService = MockVoiceAccessibilityService()

        // Create in-memory database for testing
        database = Room.inMemoryDatabaseBuilder(
            context,
            AppScrapingDatabase::class.java
        )
            .allowMainThreadQueries() // For testing only
            .build()

        // Create test app
        testAppId = AppHashCalculator.calculateAppHash(TEST_APP_PACKAGE, TEST_APP_VERSION)
        val timestamp = System.currentTimeMillis()
        val testApp = ScrapedAppEntity(
            appId = testAppId,
            packageName = TEST_APP_PACKAGE,
            appName = "Test App",
            versionName = "1.0",
            versionCode = TEST_APP_VERSION,
            appHash = testAppId,
            firstScraped = timestamp,
            lastScraped = timestamp
        )
        database.scrapedAppDao().insert(testApp)
    }

    @After
    fun tearDown() {
        database.close()
    }

    /**
     * Test 1: Commands persist across database reinitializations
     *
     * Scenario:
     * - Session 1: Scrape app, create commands
     * - Restart: Close and reopen database
     * - Session 2: Insert same element again (same hash, new ID)
     * - Verify: Command still references correct element via hash
     */
    @Test
    fun testCommandsPersistAcrossDatabaseReinitializations() = runBlocking {
        // ===== SESSION 1: Scrape app and create commands =====
        val element1 = createTestElement(
            elementHash = "test_hash_submit_button",
            className = "android.widget.Button",
            text = "Submit",
            viewId = "com.test.app:id/submit_btn"
        )
        database.scrapedElementDao().insert(element1)

        val command1 = GeneratedCommandEntity(
            elementHash = "test_hash_submit_button",
            commandText = "click submit",
            actionType = "click",
            confidence = 0.95f,
            synonyms = "[\"tap submit\", \"press submit\"]"
        )
        database.generatedCommandDao().insertBatch(listOf(command1))

        // Verify command was inserted
        val commandsBeforeRestart = database.generatedCommandDao().getCommandsForApp(testAppId)
        assertEquals("Should have 1 command before restart", 1, commandsBeforeRestart.size)
        assertEquals("test_hash_submit_button", commandsBeforeRestart[0].elementHash)

        // ===== SIMULATE APP RESTART: Close and reopen database =====
        val oldDatabasePath = database.openHelper.writableDatabase.path
        database.close()

        // Reopen same database (simulates app restart)
        database = Room.databaseBuilder(
            context,
            AppScrapingDatabase::class.java,
            oldDatabasePath
        )
            .allowMainThreadQueries()
            .build()

        // ===== SESSION 2: Re-scrape same element (same hash, NEW ID) =====
        val element2 = createTestElement(
            elementHash = "test_hash_submit_button",  // SAME HASH as before
            className = "android.widget.Button",
            text = "Submit",
            viewId = "com.test.app:id/submit_btn"
        )
        database.scrapedElementDao().insert(element2)

        // ===== VERIFY: Command persisted and still references correct element =====
        val commandsAfterRestart = database.generatedCommandDao().getCommandsForApp(testAppId)
        assertEquals("Should still have 1 command after restart", 1, commandsAfterRestart.size)
        assertEquals("Command should still reference same hash",
            "test_hash_submit_button", commandsAfterRestart[0].elementHash)

        // Verify: Can find element by hash
        val foundElement = database.scrapedElementDao().getElementByHash("test_hash_submit_button")
        assertNotNull("Should find element by hash", foundElement)
        assertEquals("Submit", foundElement?.text)
        assertEquals("android.widget.Button", foundElement?.className)

        // Verify: Element ID is different (new session created new row)
        assertNotEquals("Element should have new ID after restart", element1.id, foundElement?.id)

        // But hash is the same (persistence works!)
        assertEquals("Hash should be the same", element1.elementHash, foundElement?.elementHash)
    }

    /**
     * Test 2: Command execution works after app restart simulation
     *
     * Scenario:
     * - Session 1: Create element and command
     * - Restart: Close/reopen database
     * - Session 2: Re-insert same element (simulates re-scraping)
     * - Execute command
     * - Verify: Command executes successfully
     */
    @Test
    fun testCommandExecutionWorksAfterRestartSimulation() = runBlocking {
        // ===== SESSION 1: Create element and command =====
        setupElementAndCommand(
            hash = "hash_settings_button",
            text = "Settings",
            commandText = "open settings"
        )

        // ===== RESTART SIMULATION =====
        val oldDatabasePath = database.openHelper.writableDatabase.path
        database.close()
        database = Room.databaseBuilder(
            context,
            AppScrapingDatabase::class.java,
            oldDatabasePath
        )
            .allowMainThreadQueries()
            .build()

        // ===== SESSION 2: Re-insert same element (simulates re-scraping) =====
        setupElementAndCommand(
            hash = "hash_settings_button",  // Same hash
            text = "Settings",
            commandText = "open settings"
        )

        // ===== EXECUTE COMMAND =====
        val processor = VoiceCommandProcessor(context, mockService)
        val result = processor.processCommand("open settings")

        // ===== VERIFY: Command executed successfully =====
        assertTrue("Command should execute successfully after restart", result.success)
        assertEquals("Should have executed correct action", "click", result.actionType)
        assertNotNull("Should have element hash in result", result.elementHash)
        assertEquals("hash_settings_button", result.elementHash)
    }

    /**
     * Test 3: Orphaned commands handled gracefully
     *
     * Scenario:
     * - Create command with hash that doesn't exist in scraped_elements
     * - Try to execute
     * - Verify: Returns ElementNotFound, not crash
     */
    @Test
    fun testOrphanedCommandsReturnElementNotFound() = runBlocking {
        // ===== CREATE ORPHANED COMMAND (element doesn't exist) =====
        val orphanedCommand = GeneratedCommandEntity(
            elementHash = "nonexistent_hash_xyz",
            commandText = "phantom command",
            actionType = "click",
            confidence = 0.9f,
            synonyms = "[]"
        )

        // Note: We're inserting without the corresponding element
        // This simulates an orphaned command (element was deleted or never existed)
        database.generatedCommandDao().insertBatch(listOf(orphanedCommand))

        // Verify command was inserted
        val commands = database.generatedCommandDao().getCommandsForApp(testAppId)
        assertEquals("Should have inserted orphaned command", 1, commands.size)

        // ===== TRY TO EXECUTE ORPHANED COMMAND =====
        val processor = VoiceCommandProcessor(context, mockService)
        val result = processor.processCommand("phantom command")

        // ===== VERIFY: Returns ElementNotFound, not crash =====
        assertFalse("Command should fail gracefully", result.success)
        assertTrue(
            "Message should indicate element not found",
            result.message.contains("Element not found") || result.message.contains("not found")
        )
        assertNotNull("Should include element hash in result", result.elementHash)
        assertEquals("nonexistent_hash_xyz", result.elementHash)
    }

    /**
     * Test 4: Hash stability across identical elements
     *
     * Scenario:
     * - Create two identical elements (same properties)
     * - Calculate hash for both
     * - Verify: Both get the same hash
     */
    @Test
    fun testHashStabilityAcrossIdenticalElements() {
        // ===== CREATE TWO IDENTICAL ELEMENTS =====
        val hash1 = AppHashCalculator.calculateElementHash(
            className = "android.widget.Button",
            viewId = "com.test.app:id/submit_btn",
            text = "Submit",
            contentDescription = "Submit button"
        )

        val hash2 = AppHashCalculator.calculateElementHash(
            className = "android.widget.Button",
            viewId = "com.test.app:id/submit_btn",
            text = "Submit",
            contentDescription = "Submit button"
        )

        // ===== VERIFY: Same properties → Same hash =====
        assertEquals("Identical elements should produce same hash", hash1, hash2)

        // ===== VERIFY: Hash is valid MD5 format =====
        assertTrue("Hash should be valid MD5 format", AppHashCalculator.isValidHash(hash1))
        assertEquals("Hash should be 32 characters", 32, hash1.length)
    }

    /**
     * Test 5: Different hierarchy paths create different hashes
     *
     * Scenario:
     * - Create two "OK" buttons in different dialogs (different view IDs)
     * - Calculate hash for both
     * - Verify: Different contexts → Different hashes
     */
    @Test
    fun testDifferentHierarchyPathsCreateDifferentHashes() {
        // ===== CREATE TWO "OK" BUTTONS IN DIFFERENT DIALOGS =====

        // Dialog 1: Alert dialog OK button
        val okButton1Hash = AppHashCalculator.calculateElementHash(
            className = "android.widget.Button",
            viewId = "android:id/button1",  // Standard alert dialog button
            text = "OK",
            contentDescription = null
        )

        // Dialog 2: Custom dialog OK button
        val okButton2Hash = AppHashCalculator.calculateElementHash(
            className = "android.widget.Button",
            viewId = "com.test.app:id/custom_ok",  // Custom dialog button
            text = "OK",
            contentDescription = null
        )

        // ===== VERIFY: Same text, different contexts → Different hashes =====
        assertNotEquals(
            "Same text in different dialogs should have different hashes",
            okButton1Hash,
            okButton2Hash
        )

        // ===== VERIFY: Both are valid hashes =====
        assertTrue("First hash should be valid", AppHashCalculator.isValidHash(okButton1Hash))
        assertTrue("Second hash should be valid", AppHashCalculator.isValidHash(okButton2Hash))
    }

    /**
     * Test 6: Null properties handled correctly in hashing
     *
     * Scenario:
     * - Create elements with null properties
     * - Verify: Hashes are stable and unique
     */
    @Test
    fun testNullPropertiesHandledInHashing() {
        // Element with no text or content description (common for containers)
        val containerHash = AppHashCalculator.calculateElementHash(
            className = "android.widget.LinearLayout",
            viewId = "com.test.app:id/container",
            text = null,
            contentDescription = null
        )

        // Same element again
        val containerHash2 = AppHashCalculator.calculateElementHash(
            className = "android.widget.LinearLayout",
            viewId = "com.test.app:id/container",
            text = null,
            contentDescription = null
        )

        // ===== VERIFY: Null properties don't break hashing =====
        assertEquals("Same null properties should produce same hash", containerHash, containerHash2)
        assertTrue("Hash with nulls should be valid", AppHashCalculator.isValidHash(containerHash))

        // ===== VERIFY: Different nulls produce different hashes =====
        val differentContainer = AppHashCalculator.calculateElementHash(
            className = "android.widget.LinearLayout",
            viewId = "com.test.app:id/different_container",  // Different view ID
            text = null,
            contentDescription = null
        )

        assertNotEquals(
            "Different view IDs should produce different hashes even with nulls",
            containerHash,
            differentContainer
        )
    }

    /**
     * Test 7: Command usage statistics persist across restarts
     *
     * Scenario:
     * - Create command and execute it (increments usage count)
     * - Restart database
     * - Verify: Usage statistics preserved
     */
    @Test
    fun testCommandUsageStatisticsPersist() = runBlocking {
        // ===== CREATE COMMAND AND TRACK USAGE =====
        setupElementAndCommand(
            hash = "hash_back_button",
            text = "Back",
            commandText = "go back"
        )

        // Execute command multiple times
        repeat(3) {
            database.generatedCommandDao().incrementUsage(1) // Assuming ID = 1
        }

        // Verify usage count
        val commandsBefore = database.generatedCommandDao().getCommandsForApp(testAppId)
        assertEquals("Should have usage count of 3", 3, commandsBefore[0].usageCount)

        // ===== RESTART DATABASE =====
        val oldDatabasePath = database.openHelper.writableDatabase.path
        database.close()
        database = Room.databaseBuilder(
            context,
            AppScrapingDatabase::class.java,
            oldDatabasePath
        )
            .allowMainThreadQueries()
            .build()

        // ===== VERIFY: Usage statistics preserved =====
        val commandsAfter = database.generatedCommandDao().getCommandsForApp(testAppId)
        assertEquals("Usage count should persist after restart", 3, commandsAfter[0].usageCount)
    }

    // ===== HELPER FUNCTIONS =====

    /**
     * Create a test element with specified properties
     */
    private fun createTestElement(
        elementHash: String,
        className: String,
        text: String?,
        viewId: String? = null,
        contentDescription: String? = null
    ): ScrapedElementEntity {
        return ScrapedElementEntity(
            id = 0, // Auto-generate
            elementHash = elementHash,
            appId = testAppId,
            className = className,
            viewIdResourceName = viewId,
            text = text,
            contentDescription = contentDescription,
            bounds = "{\"left\":0,\"top\":0,\"right\":100,\"bottom\":50}",
            isClickable = true,
            isLongClickable = false,
            isEditable = false,
            isScrollable = false,
            isCheckable = false,
            isFocusable = true,
            isEnabled = true,
            depth = 2,
            indexInParent = 0,
            scrapedAt = System.currentTimeMillis()
        )
    }

    /**
     * Setup element and command in one call (common test pattern)
     */
    private suspend fun setupElementAndCommand(
        hash: String,
        text: String,
        commandText: String,
        actionType: String = "click"
    ) {
        // Create element
        val element = createTestElement(
            elementHash = hash,
            className = "android.widget.Button",
            text = text
        )
        database.scrapedElementDao().insert(element)

        // Create command
        val command = GeneratedCommandEntity(
            elementHash = hash,
            commandText = commandText,
            actionType = actionType,
            confidence = 0.9f,
            synonyms = "[]"
        )
        database.generatedCommandDao().insertBatch(listOf(command))
    }
}
