package com.augmentalis.magiccode.plugins

import com.augmentalis.magiccode.plugins.core.AssetCategory
import com.augmentalis.magiccode.plugins.utils.TestConstants
import kotlinx.coroutines.test.runTest
import kotlin.test.*

/**
 * Unit tests for AssetCache.
 *
 * Tests:
 * - LRU eviction
 * - Hit rate calculation
 * - Cache invalidation
 * - Concurrent access (via coroutines)
 * - Statistics tracking
 */
class AssetCacheTest {
    private lateinit var cache: AssetCache

    @BeforeTest
    fun setup() {
        cache = AssetCache(maxCapacity = TestConstants.TEST_CACHE_CAPACITY)
    }

    // Test 1: LRU Eviction
    @Test
    fun testLRUEviction() = runTest {
        // Fill cache to capacity
        for (i in 0 until TestConstants.TEST_CACHE_CAPACITY) {
            val uri = "plugin://test.plugin/themes/theme-$i.yaml"
            val handle = createTestAssetHandle(uri)
            cache.put(uri, handle)
        }

        assertEquals(TestConstants.TEST_CACHE_CAPACITY, cache.size())

        // Access first entry to make it recently used
        val firstUri = "plugin://test.plugin/themes/theme-0.yaml"
        cache.get(firstUri)

        // Add one more entry - should evict least recently used (theme-1, not theme-0)
        val newUri = "plugin://test.plugin/themes/theme-new.yaml"
        cache.put(newUri, createTestAssetHandle(newUri))

        assertEquals(TestConstants.TEST_CACHE_CAPACITY, cache.size())

        // First entry should still be cached (was accessed recently)
        assertNotNull(cache.get(firstUri))

        // Second entry should be evicted
        val secondUri = "plugin://test.plugin/themes/theme-1.yaml"
        assertNull(cache.get(secondUri))

        // New entry should be cached
        assertNotNull(cache.get(newUri))
    }

    // Test 2: Hit Rate Calculation
    @Test
    fun testHitRateCalculation() = runTest {
        // Initially hit rate should be 0
        val initialStats = cache.getDetailedStats()
        assertEquals(0.0, initialStats["hitRatePercent"])

        // Add entries
        val uri1 = "plugin://test.plugin/themes/theme1.yaml"
        val uri2 = "plugin://test.plugin/themes/theme2.yaml"
        cache.put(uri1, createTestAssetHandle(uri1))
        cache.put(uri2, createTestAssetHandle(uri2))

        // 2 hits
        cache.get(uri1)
        cache.get(uri2)

        // 1 miss
        cache.get("plugin://test.plugin/themes/nonexistent.yaml")

        // Hit rate should be 2/3 = 66.67%
        val stats = cache.getDetailedStats()
        val hitRate = stats["hitRatePercent"] as Double
        assertTrue(hitRate > 66.0 && hitRate < 67.0)

        assertEquals(2L, stats["totalHits"])
        assertEquals(1L, stats["totalMisses"])
    }

    // Test 3: Cache Invalidation
    @Test
    fun testCacheInvalidation() = runTest {
        // Add entries for multiple plugins
        val plugin1Uri1 = "plugin://com.test.plugin1/themes/theme1.yaml"
        val plugin1Uri2 = "plugin://com.test.plugin1/images/icon.png"
        val plugin2Uri = "plugin://com.test.plugin2/themes/theme2.yaml"

        cache.put(plugin1Uri1, createTestAssetHandle(plugin1Uri1))
        cache.put(plugin1Uri2, createTestAssetHandle(plugin1Uri2))
        cache.put(plugin2Uri, createTestAssetHandle(plugin2Uri))

        assertEquals(3, cache.size())

        // Invalidate plugin1
        val invalidated = cache.invalidatePlugin("com.test.plugin1")
        assertEquals(2, invalidated)

        // Plugin1 entries should be removed
        assertNull(cache.get(plugin1Uri1))
        assertNull(cache.get(plugin1Uri2))

        // Plugin2 entry should remain
        assertNotNull(cache.get(plugin2Uri))
        assertEquals(1, cache.size())
    }

    // Test 4: Concurrent Access
    @Test
    fun testConcurrentAccess() = runTest {
        // Multiple coroutines accessing cache simultaneously
        val uris = (0..50).map { "plugin://test.plugin/themes/theme-$it.yaml" }

        // Concurrent writes
        uris.forEach { uri ->
            cache.put(uri, createTestAssetHandle(uri))
        }

        // Cache should not exceed capacity
        assertTrue(cache.size() <= cache.capacity())

        // Concurrent reads
        val results = uris.take(TestConstants.TEST_CACHE_CAPACITY).map { uri ->
            cache.get(uri)
        }

        // Some entries should be cached (those not evicted)
        assertTrue(results.any { it != null })
    }

    // Test 5: Statistics Tracking
    @Test
    fun testStatisticsTracking() = runTest {
        val uri = "plugin://test.plugin/themes/theme.yaml"
        val handle = createTestAssetHandle(uri)

        // Put entry
        cache.put(uri, handle)

        // Get stats
        val stats = cache.getStats()

        assertEquals(1, stats["size"])
        assertEquals(TestConstants.TEST_CACHE_CAPACITY, stats["capacity"])
        assertTrue(stats.containsKey("hitRatePercent"))
        assertTrue(stats.containsKey("oldestEntryAge"))

        val detailedStats = cache.getDetailedStats()
        assertEquals(0L, detailedStats["totalHits"])
        assertEquals(0L, detailedStats["totalMisses"])

        // Access entry
        cache.get(uri)

        val updatedStats = cache.getDetailedStats()
        assertEquals(1L, updatedStats["totalHits"])
        assertEquals(0L, updatedStats["totalMisses"])
    }

    // Test 6: Cache Clear
    @Test
    fun testCacheClear() = runTest {
        // Add entries
        for (i in 0..5) {
            val uri = "plugin://test.plugin/themes/theme-$i.yaml"
            cache.put(uri, createTestAssetHandle(uri))
        }

        assertTrue(cache.size() > 0)

        // Clear cache
        cache.clear()

        assertEquals(0, cache.size())

        // All entries should be gone
        for (i in 0..5) {
            val uri = "plugin://test.plugin/themes/theme-$i.yaml"
            assertNull(cache.get(uri))
        }
    }

    // Test 7: Remove Entry
    @Test
    fun testRemoveEntry() = runTest {
        val uri = "plugin://test.plugin/themes/theme.yaml"
        cache.put(uri, createTestAssetHandle(uri))

        assertNotNull(cache.get(uri))

        val removed = cache.remove(uri)
        assertTrue(removed)

        assertNull(cache.get(uri))

        // Removing non-existent entry should return false
        val notRemoved = cache.remove("plugin://nonexistent/themes/theme.yaml")
        assertFalse(notRemoved)
    }

    // Test 8: Get Cached URIs
    @Test
    fun testGetCachedUris() = runTest {
        val uri1 = "plugin://test.plugin/themes/theme1.yaml"
        val uri2 = "plugin://test.plugin/themes/theme2.yaml"

        cache.put(uri1, createTestAssetHandle(uri1))
        cache.put(uri2, createTestAssetHandle(uri2))

        val cachedUris = cache.getCachedUris()
        assertEquals(2, cachedUris.size)
        assertTrue(cachedUris.contains(uri1))
        assertTrue(cachedUris.contains(uri2))
    }

    // Test 9: Reset Statistics
    @Test
    fun testResetStatistics() = runTest {
        val uri = "plugin://test.plugin/themes/theme.yaml"
        cache.put(uri, createTestAssetHandle(uri))

        // Generate hits and misses
        cache.get(uri) // hit
        cache.get("plugin://nonexistent/themes/theme.yaml") // miss

        var stats = cache.getDetailedStats()
        assertEquals(1L, stats["totalHits"])
        assertEquals(1L, stats["totalMisses"])

        // Reset statistics
        cache.resetStatistics()

        stats = cache.getDetailedStats()
        assertEquals(0L, stats["totalHits"])
        assertEquals(0L, stats["totalMisses"])

        // Entries should still be cached
        assertNotNull(cache.get(uri))
    }

    // Test 10: Oldest Entry Age
    @Test
    fun testOldestEntryAge() = runTest {
        // Empty cache should have 0 age
        var stats = cache.getStats()
        assertEquals(0L, stats["oldestEntryAge"])

        // Add entry
        val uri = "plugin://test.plugin/themes/theme.yaml"
        cache.put(uri, createTestAssetHandle(uri))

        // Oldest entry age should be > 0
        stats = cache.getStats()
        val age = stats["oldestEntryAge"] as Long
        assertTrue(age >= 0)
    }

    /**
     * Helper to create test asset handle.
     */
    private fun createTestAssetHandle(uri: String): AssetHandle {
        val parts = uri.removePrefix("plugin://").split("/")
        val pluginId = parts[0]
        val category = AssetCategory.valueOf(parts[1].uppercase())
        val filename = parts[2]

        val reference = AssetReference(
            pluginId = pluginId,
            category = category,
            filename = filename,
            resolvedPath = "/test/path/$filename"
        )

        val metadata = AssetMetadata(
            mimeType = "application/x-yaml",
            sizeBytes = 1024,
            checksum = TestConstants.TEST_CHECKSUM_SHA256,
            isFallback = false
        )

        return AssetHandle(
            reference = reference,
            absolutePath = "/test/path/$filename",
            metadata = metadata
        )
    }
}
