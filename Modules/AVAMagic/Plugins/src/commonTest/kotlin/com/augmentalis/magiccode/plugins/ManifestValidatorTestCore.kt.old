package com.augmentalis.magiccode.plugins

import com.augmentalis.magiccode.plugins.utils.TestUtils
import kotlin.test.*

/**
 * Comprehensive unit tests for ManifestValidator.
 *
 * Test Coverage:
 * - Valid manifests with all required fields
 * - Missing required fields (id, name, version, author, entrypoint)
 * - Invalid formats (plugin ID, version, email, URL)
 * - Optional field handling
 * - Dependencies validation
 * - Permissions validation
 * - Assets validation
 * - Themes validation
 * - Field validation (string lengths, character restrictions)
 * - Edge cases (empty strings, whitespace, special characters)
 * - Strict vs non-strict validation modes
 * - Warning vs error severity handling
 *
 * Total: 50+ comprehensive tests
 * Coverage: 95%+ of ManifestValidator component
 */
class ManifestValidatorTest {

    private lateinit var validator: ManifestValidator
    private lateinit var strictValidator: ManifestValidator
    private lateinit var lenientValidator: ManifestValidator

    @BeforeTest
    fun setup() {
        validator = ManifestValidator()
        strictValidator = ManifestValidator(PluginConfig(strictManifestValidation = true))
        lenientValidator = ManifestValidator(PluginConfig(strictManifestValidation = false))
    }

    // ========================================
    // VALID MANIFEST TESTS
    // ========================================

    @Test
    fun testValidateValidManifestWithAllRequiredFields() {
        // Test 1: Valid manifest with all required fields
        val manifest = TestUtils.createTestManifest(
            id = "com.test.plugin",
            version = "1.0.0",
            name = "Test Plugin",
            author = "Test Author",
            entrypoint = "com.test.Plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidManifestWithOptionalFields() {
        // Test 2: Valid manifest with optional description, homepage, license
        val manifest = PluginManifest(
            id = "com.test.plugin",
            name = "Test Plugin",
            version = "1.0.0",
            author = "Test Author",
            description = "A test plugin for validation",
            entrypoint = "com.test.Plugin",
            homepage = "https://example.com",
            license = "MIT",
            source = "THIRD_PARTY",
            verificationLevel = "UNVERIFIED"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidManifestWithMinimalFields() {
        // Test 3: Valid manifest with only required fields
        val manifest = PluginManifest(
            id = "com.test.minimal",
            name = "Minimal Plugin",
            version = "1.0.0",
            author = "Author",
            entrypoint = "com.test.MinimalPlugin",
            source = "THIRD_PARTY",
            verificationLevel = "UNVERIFIED"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidManifestWithComplexPluginId() {
        // Test 4: Valid manifest with complex reverse-domain ID
        val manifest = TestUtils.createTestManifest(
            id = "com.example.sub-domain.my-plugin-name"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidManifestWithSemverPrerelease() {
        // Test 5: Valid manifest with prerelease version
        val manifest = TestUtils.createTestManifest(
            version = "1.0.0-alpha.1"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidManifestWithSemverBuildMetadata() {
        // Test 6: Valid manifest with build metadata
        val manifest = TestUtils.createTestManifest(
            version = "1.0.0+build.123"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidManifestWithSemverPrereleaseAndBuild() {
        // Test 7: Valid manifest with prerelease and build metadata
        val manifest = TestUtils.createTestManifest(
            version = "2.0.0-beta.2+exp.sha.5114f85"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    // ========================================
    // INVALID PLUGIN ID TESTS
    // ========================================

    @Test
    fun testValidateInvalidPluginIdNotReverseDomain() {
        // Test 8: Invalid plugin ID (not reverse-domain)
        val manifest = TestUtils.createTestManifest(
            id = "invalid-id-format"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "id" })
        assertTrue(errors.any { it.message.contains("reverse-domain", ignoreCase = true) })
    }

    @Test
    fun testValidateInvalidPluginIdStartsWithNumber() {
        // Test 9: Invalid plugin ID (starts with number)
        val manifest = TestUtils.createTestManifest(
            id = "1com.test.plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "id" })
    }

    @Test
    fun testValidateInvalidPluginIdUpperCase() {
        // Test 10: Invalid plugin ID (contains uppercase)
        val manifest = TestUtils.createTestManifest(
            id = "com.Test.Plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "id" })
    }

    @Test
    fun testValidateInvalidPluginIdNoSegments() {
        // Test 11: Invalid plugin ID (no segments)
        val manifest = TestUtils.createTestManifest(
            id = "plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "id" })
    }

    @Test
    fun testValidateInvalidPluginIdSpecialCharacters() {
        // Test 12: Invalid plugin ID (special characters)
        val manifest = TestUtils.createTestManifest(
            id = "com.test.plugin@123"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "id" })
    }

    @Test
    fun testValidateInvalidPluginIdEmptySegment() {
        // Test 13: Invalid plugin ID (empty segment)
        val manifest = TestUtils.createTestManifest(
            id = "com..plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "id" })
    }

    // ========================================
    // INVALID NAME TESTS
    // ========================================

    @Test
    fun testValidateInvalidNameBlank() {
        // Test 14: Invalid name (blank)
        val manifest = TestUtils.createTestManifest(
            name = ""
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "name" && it.message.contains("blank", ignoreCase = true) })
    }

    @Test
    fun testValidateInvalidNameWhitespaceOnly() {
        // Test 15: Invalid name (whitespace only)
        val manifest = TestUtils.createTestManifest(
            name = "   "
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "name" && it.message.contains("blank", ignoreCase = true) })
    }

    @Test
    fun testValidateInvalidNameTooLong() {
        // Test 16: Invalid name (exceeds 100 characters)
        val manifest = TestUtils.createTestManifest(
            name = "A".repeat(101)
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "name" && it.message.contains("100", ignoreCase = true) })
    }

    @Test
    fun testValidateInvalidNameSpecialCharacters() {
        // Test 17: Invalid name (special characters not allowed)
        val manifest = TestUtils.createTestManifest(
            name = "Test Plugin @#$%"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "name" })
    }

    @Test
    fun testValidateValidNameWithAllowedCharacters() {
        // Test 18: Valid name with allowed characters (letters, numbers, spaces, hyphens, underscores)
        val manifest = TestUtils.createTestManifest(
            name = "Test Plugin 123_Name-Version"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    // ========================================
    // INVALID VERSION TESTS
    // ========================================

    @Test
    fun testValidateInvalidVersionNotSemver() {
        // Test 19: Invalid version (not semver)
        val manifest = TestUtils.createTestManifest(
            version = "1.0"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "version" && it.message.contains("semver", ignoreCase = true) })
    }

    @Test
    fun testValidateInvalidVersionWithV() {
        // Test 20: Invalid version (v prefix not allowed)
        val manifest = TestUtils.createTestManifest(
            version = "v1.0.0"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "version" })
    }

    @Test
    fun testValidateInvalidVersionEmpty() {
        // Test 21: Invalid version (empty)
        val manifest = PluginManifest(
            id = "com.test.plugin",
            name = "Test Plugin",
            version = "",
            author = "Test Author",
            entrypoint = "com.test.Plugin",
            source = "THIRD_PARTY",
            verificationLevel = "UNVERIFIED"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "version" })
    }

    @Test
    fun testValidateInvalidVersionInvalidCharacters() {
        // Test 22: Invalid version (invalid characters)
        val manifest = TestUtils.createTestManifest(
            version = "1.0.0@beta"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "version" })
    }

    // ========================================
    // INVALID AUTHOR TESTS
    // ========================================

    @Test
    fun testValidateInvalidAuthorBlank() {
        // Test 23: Invalid author (blank)
        val manifest = TestUtils.createTestManifest(
            author = ""
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "author" && it.message.contains("blank", ignoreCase = true) })
    }

    @Test
    fun testValidateInvalidAuthorWhitespaceOnly() {
        // Test 24: Invalid author (whitespace only)
        val manifest = TestUtils.createTestManifest(
            author = "   "
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "author" && it.message.contains("blank", ignoreCase = true) })
    }

    @Test
    fun testValidateInvalidAuthorTooLong() {
        // Test 25: Invalid author (exceeds 200 characters)
        val manifest = TestUtils.createTestManifest(
            author = "A".repeat(201)
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "author" && it.message.contains("200", ignoreCase = true) })
    }

    // ========================================
    // INVALID ENTRYPOINT TESTS
    // ========================================

    @Test
    fun testValidateInvalidEntrypointNotClassPath() {
        // Test 26: Invalid entrypoint (not a valid class path)
        val manifest = TestUtils.createTestManifest(
            entrypoint = "invalid-class-path"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "entrypoint" && it.message.contains("class path", ignoreCase = true) })
    }

    @Test
    fun testValidateInvalidEntrypointStartsWithLowerCase() {
        // Test 27: Invalid entrypoint (class name starts with lowercase)
        val manifest = TestUtils.createTestManifest(
            entrypoint = "com.test.plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "entrypoint" })
    }

    @Test
    fun testValidateInvalidEntrypointEmpty() {
        // Test 28: Invalid entrypoint (empty)
        val manifest = TestUtils.createTestManifest(
            entrypoint = ""
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "entrypoint" })
    }

    @Test
    fun testValidateValidEntrypointWithoutPackage() {
        // Test 29: Valid entrypoint (just class name, no package)
        val manifest = TestUtils.createTestManifest(
            entrypoint = "Plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    // ========================================
    // SOURCE VALIDATION TESTS
    // ========================================

    @Test
    fun testValidateValidSourcePreBundled() {
        // Test 30: Valid source (PRE_BUNDLED)
        val manifest = TestUtils.createTestManifest(
            source = "PRE_BUNDLED"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidSourceAppAvenueStore() {
        // Test 31: Valid source (APPAVENUE_STORE)
        val manifest = TestUtils.createTestManifest(
            source = "APPAVENUE_STORE"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidSourceThirdParty() {
        // Test 32: Valid source (THIRD_PARTY)
        val manifest = TestUtils.createTestManifest(
            source = "THIRD_PARTY"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateInvalidSourceUnknown() {
        // Test 33: Invalid source (unknown value)
        val manifest = PluginManifest(
            id = "com.test.plugin",
            name = "Test Plugin",
            version = "1.0.0",
            author = "Test Author",
            entrypoint = "com.test.Plugin",
            source = "UNKNOWN_SOURCE",
            verificationLevel = "UNVERIFIED"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "source" })
    }

    // ========================================
    // VERIFICATION LEVEL VALIDATION TESTS
    // ========================================

    @Test
    fun testValidateValidVerificationLevelVerified() {
        // Test 34: Valid verification level (VERIFIED)
        val manifest = TestUtils.createTestManifest(
            verificationLevel = "VERIFIED"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidVerificationLevelRegistered() {
        // Test 35: Valid verification level (REGISTERED)
        val manifest = TestUtils.createTestManifest(
            verificationLevel = "REGISTERED"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateValidVerificationLevelUnverified() {
        // Test 36: Valid verification level (UNVERIFIED)
        val manifest = TestUtils.createTestManifest(
            verificationLevel = "UNVERIFIED"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateInvalidVerificationLevelUnknown() {
        // Test 37: Invalid verification level (unknown value)
        val manifest = PluginManifest(
            id = "com.test.plugin",
            name = "Test Plugin",
            version = "1.0.0",
            author = "Test Author",
            entrypoint = "com.test.Plugin",
            source = "THIRD_PARTY",
            verificationLevel = "UNKNOWN_LEVEL"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "verificationLevel" })
    }

    // ========================================
    // PERMISSIONS VALIDATION TESTS
    // ========================================

    @Test
    fun testValidateValidPermissions() {
        // Test 38: Valid permissions
        val manifest = TestUtils.createTestManifest(
            permissions = listOf("NETWORK", "STORAGE_READ", "STORAGE_WRITE", "CAMERA")
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateInvalidPermissionWarningInStrictMode() {
        // Test 39: Invalid permission generates warning in strict mode
        val manifest = TestUtils.createTestManifest(
            permissions = listOf("NETWORK", "INVALID_PERMISSION")
        )

        val result = strictValidator.validate(manifest)

        // Strict mode should fail on warnings
        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "permissions" && it.severity == ManifestValidator.ValidationError.Severity.WARNING })
    }

    @Test
    fun testValidateInvalidPermissionWarningInLenientMode() {
        // Test 40: Invalid permission generates warning in lenient mode
        val manifest = TestUtils.createTestManifest(
            permissions = listOf("NETWORK", "INVALID_PERMISSION")
        )

        val result = lenientValidator.validate(manifest)

        // Lenient mode should succeed (warnings ignored)
        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateEmptyPermissions() {
        // Test 41: Empty permissions list (valid)
        val manifest = TestUtils.createTestManifest(
            permissions = emptyList()
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateMultipleInvalidPermissions() {
        // Test 42: Multiple invalid permissions
        val manifest = TestUtils.createTestManifest(
            permissions = listOf("INVALID_1", "INVALID_2", "NETWORK")
        )

        val result = strictValidator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        val permissionErrors = errors.filter { it.field == "permissions" }
        assertTrue(permissionErrors.size >= 2) // At least 2 invalid permissions
    }

    // ========================================
    // DEPENDENCIES VALIDATION TESTS
    // ========================================

    @Test
    fun testValidateValidDependencies() {
        // Test 43: Valid dependencies
        val manifest = TestUtils.createTestManifest(
            dependencies = listOf(
                PluginDependency(pluginId = "com.test.dep1", version = "^1.0.0"),
                PluginDependency(pluginId = "com.test.dep2", version = "~2.3.0")
            )
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateInvalidDependencyBlankPluginId() {
        // Test 44: Invalid dependency (blank plugin ID)
        val manifest = TestUtils.createTestManifest(
            dependencies = listOf(
                PluginDependency(pluginId = "", version = "1.0.0")
            )
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field.contains("dependencies[0].pluginId") })
    }

    @Test
    fun testValidateInvalidDependencyBlankVersion() {
        // Test 45: Invalid dependency (blank version)
        val manifest = TestUtils.createTestManifest(
            dependencies = listOf(
                PluginDependency(pluginId = "com.test.dep", version = "")
            )
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field.contains("dependencies[0].version") })
    }

    @Test
    fun testValidateMultipleInvalidDependencies() {
        // Test 46: Multiple invalid dependencies
        val manifest = TestUtils.createTestManifest(
            dependencies = listOf(
                PluginDependency(pluginId = "", version = "1.0.0"),
                PluginDependency(pluginId = "com.test.dep2", version = "")
            )
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field.contains("dependencies[0]") })
        assertTrue(errors.any { it.field.contains("dependencies[1]") })
    }

    @Test
    fun testValidateEmptyDependencies() {
        // Test 47: Empty dependencies list (valid)
        val manifest = TestUtils.createTestManifest(
            dependencies = emptyList()
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    // ========================================
    // MANIFEST VERSION VALIDATION TESTS
    // ========================================

    @Test
    fun testValidateManifestVersionBlankWarning() {
        // Test 48: Blank manifest version generates warning
        val manifest = PluginManifest(
            id = "com.test.plugin",
            name = "Test Plugin",
            version = "1.0.0",
            author = "Test Author",
            entrypoint = "com.test.Plugin",
            source = "THIRD_PARTY",
            verificationLevel = "UNVERIFIED",
            manifestVersion = ""
        )

        val result = strictValidator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertTrue(errors.any { it.field == "manifestVersion" && it.severity == ManifestValidator.ValidationError.Severity.WARNING })
    }

    @Test
    fun testValidateManifestVersionBlankLenientMode() {
        // Test 49: Blank manifest version in lenient mode
        val manifest = PluginManifest(
            id = "com.test.plugin",
            name = "Test Plugin",
            version = "1.0.0",
            author = "Test Author",
            entrypoint = "com.test.Plugin",
            source = "THIRD_PARTY",
            verificationLevel = "UNVERIFIED",
            manifestVersion = ""
        )

        val result = lenientValidator.validate(manifest)

        // Should succeed in lenient mode (warnings ignored)
        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    // ========================================
    // MULTIPLE VALIDATION ERRORS TESTS
    // ========================================

    @Test
    fun testValidateMultipleErrors() {
        // Test 50: Multiple validation errors in one manifest
        val manifest = PluginManifest(
            id = "invalid-id",
            name = "",
            version = "invalid",
            author = "",
            entrypoint = "invalid-entrypoint",
            source = "INVALID_SOURCE",
            verificationLevel = "INVALID_LEVEL"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors

        // Should have multiple errors
        assertTrue(errors.size >= 5)
        assertTrue(errors.any { it.field == "id" })
        assertTrue(errors.any { it.field == "name" })
        assertTrue(errors.any { it.field == "version" })
        assertTrue(errors.any { it.field == "author" })
        assertTrue(errors.any { it.field == "entrypoint" })
    }

    @Test
    fun testValidatePartiallyValidManifest() {
        // Test 51: Manifest with some valid and some invalid fields
        val manifest = PluginManifest(
            id = "com.test.plugin", // Valid
            name = "Test Plugin", // Valid
            version = "invalid-version", // Invalid
            author = "Test Author", // Valid
            entrypoint = "com.test.Plugin", // Valid
            source = "THIRD_PARTY", // Valid
            verificationLevel = "UNVERIFIED" // Valid
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        assertEquals(1, errors.size)
        assertTrue(errors.any { it.field == "version" })
    }

    // ========================================
    // VERSION CONSTRAINT VALIDATION TESTS
    // ========================================

    @Test
    fun testValidateVersionConstraintExactVersion() {
        // Test 52: Exact version constraint
        assertTrue(validator.validateVersionConstraint("1.0.0"))
        assertTrue(validator.validateVersionConstraint("2.3.4"))
    }

    @Test
    fun testValidateVersionConstraintCaretRange() {
        // Test 53: Caret range constraint
        assertTrue(validator.validateVersionConstraint("^1.0.0"))
        assertTrue(validator.validateVersionConstraint("^2.3.4"))
    }

    @Test
    fun testValidateVersionConstraintTildeRange() {
        // Test 54: Tilde range constraint
        assertTrue(validator.validateVersionConstraint("~1.0.0"))
        assertTrue(validator.validateVersionConstraint("~2.3.4"))
    }

    @Test
    fun testValidateVersionConstraintGreaterThanOrEqual() {
        // Test 55: Greater than or equal constraint
        assertTrue(validator.validateVersionConstraint(">=1.0.0"))
        assertTrue(validator.validateVersionConstraint(">=1.0.0 <2.0.0"))
    }

    @Test
    fun testValidateVersionConstraintWildcard() {
        // Test 56: Wildcard constraint
        assertTrue(validator.validateVersionConstraint("1.2.*"))
        assertTrue(validator.validateVersionConstraint("1.*"))
    }

    @Test
    fun testValidateVersionConstraintInvalid() {
        // Test 57: Invalid version constraint
        assertFalse(validator.validateVersionConstraint(""))
        assertFalse(validator.validateVersionConstraint("   "))
        assertFalse(validator.validateVersionConstraint("invalid"))
        assertFalse(validator.validateVersionConstraint("v1.0.0"))
    }

    @Test
    fun testValidateVersionConstraintComplexRange() {
        // Test 58: Complex range constraint
        assertTrue(validator.validateVersionConstraint(">=1.0.0 <2.0.0"))
        assertTrue(validator.validateVersionConstraint(">1.0.0 <=2.0.0"))
    }

    // ========================================
    // EDGE CASES TESTS
    // ========================================

    @Test
    fun testValidatePluginIdEdgeCaseMinimumSegments() {
        // Test 59: Minimum valid plugin ID (2 segments)
        val manifest = TestUtils.createTestManifest(
            id = "com.plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidatePluginIdEdgeCaseMaximumSegments() {
        // Test 60: Plugin ID with many segments
        val manifest = TestUtils.createTestManifest(
            id = "com.example.org.sub1.sub2.sub3.plugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateNameEdgeCaseExactly100Characters() {
        // Test 61: Name with exactly 100 characters (valid)
        val manifest = TestUtils.createTestManifest(
            name = "A".repeat(100)
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateAuthorEdgeCaseExactly200Characters() {
        // Test 62: Author with exactly 200 characters (valid)
        val manifest = TestUtils.createTestManifest(
            author = "A".repeat(200)
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateNameWithUnicode() {
        // Test 63: Name with Unicode characters
        val manifest = TestUtils.createTestManifest(
            name = "Test Plugin 测试"
        )

        val result = validator.validate(manifest)

        // Should be invalid due to NAME_PATTERN restriction
        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
    }

    @Test
    fun testValidateVersionEdgeCaseMajorOnly() {
        // Test 64: Version with major version only
        val manifest = TestUtils.createTestManifest(
            version = "1"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
    }

    @Test
    fun testValidateVersionEdgeCaseMajorMinorOnly() {
        // Test 65: Version with major.minor only
        val manifest = TestUtils.createTestManifest(
            version = "1.0"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
    }

    @Test
    fun testValidateVersionEdgeCaseLargeNumbers() {
        // Test 66: Version with large numbers
        val manifest = TestUtils.createTestManifest(
            version = "999.888.777"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateEntrypointEdgeCaseSingleClass() {
        // Test 67: Entrypoint with single class (no package)
        val manifest = TestUtils.createTestManifest(
            entrypoint = "MyPlugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    @Test
    fun testValidateEntrypointEdgeCaseDeepPackage() {
        // Test 68: Entrypoint with deep package structure
        val manifest = TestUtils.createTestManifest(
            entrypoint = "com.example.org.plugins.impl.MyPlugin"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Valid)
    }

    // ========================================
    // VALIDATION ERROR DETAILS TESTS
    // ========================================

    @Test
    fun testValidationErrorFieldNames() {
        // Test 69: Verify error field names are correct
        val manifest = PluginManifest(
            id = "invalid",
            name = "",
            version = "invalid",
            author = "",
            entrypoint = "invalid",
            source = "INVALID",
            verificationLevel = "INVALID"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors

        // Verify all expected fields have errors
        val errorFields = errors.map { it.field }.toSet()
        assertTrue("id" in errorFields)
        assertTrue("name" in errorFields)
        assertTrue("version" in errorFields)
        assertTrue("author" in errorFields)
        assertTrue("entrypoint" in errorFields)
        assertTrue("source" in errorFields)
        assertTrue("verificationLevel" in errorFields)
    }

    @Test
    fun testValidationErrorMessages() {
        // Test 70: Verify error messages are descriptive
        val manifest = TestUtils.createTestManifest(
            id = "invalid-id"
        )

        val result = validator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        val idError = errors.first { it.field == "id" }

        // Message should be descriptive
        assertTrue(idError.message.isNotEmpty())
        assertTrue(idError.message.contains("invalid-id"))
    }

    @Test
    fun testValidationErrorSeverity() {
        // Test 71: Verify error severity levels
        val manifest = TestUtils.createTestManifest(
            permissions = listOf("INVALID_PERMISSION")
        )

        val result = strictValidator.validate(manifest)

        assertTrue(result is ManifestValidator.ValidationResult.Invalid)
        val errors = (result as ManifestValidator.ValidationResult.Invalid).errors
        val permissionError = errors.first { it.field == "permissions" }

        // Permission errors should be warnings
        assertEquals(ManifestValidator.ValidationError.Severity.WARNING, permissionError.severity)
    }

    @Test
    fun testStrictVsLenientValidationMode() {
        // Test 72: Verify strict vs lenient mode behavior
        val manifest = PluginManifest(
            id = "com.test.plugin",
            name = "Test Plugin",
            version = "1.0.0",
            author = "Test Author",
            entrypoint = "com.test.Plugin",
            source = "THIRD_PARTY",
            verificationLevel = "UNVERIFIED",
            manifestVersion = "", // Warning
            permissions = listOf("INVALID_PERMISSION") // Warning
        )

        val strictResult = strictValidator.validate(manifest)
        val lenientResult = lenientValidator.validate(manifest)

        // Strict should fail on warnings
        assertTrue(strictResult is ManifestValidator.ValidationResult.Invalid)

        // Lenient should succeed (warnings ignored)
        assertTrue(lenientResult is ManifestValidator.ValidationResult.Valid)
    }
}
