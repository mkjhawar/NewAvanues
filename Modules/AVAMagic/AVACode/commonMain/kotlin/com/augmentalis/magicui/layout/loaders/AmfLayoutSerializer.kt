package com.augmentalis.avamagic.layout.loaders

import com.augmentalis.avamagic.layout.ComponentType
import com.augmentalis.avamagic.layout.LayoutComponent
import com.augmentalis.avamagic.layout.LayoutConfig

/**
 * Serializes AvaUI layouts to AMF (AvaMagic Format).
 *
 * Produces compact, line-based output that can be loaded by [AmfLayoutLoader].
 *
 * ## Output Format
 *
 * ```
 * # AvaMagic Layout: MainScreen
 * # Generated by AmfLayoutSerializer
 * ---
 * schema: amf-lyt-1.0
 * ---
 * LYT:MainScreen:1.0.0
 * COL:root:1:center
 *   ROW:header:0:space-between
 *     TXT:title:Welcome:h1
 *     BTN:menu:Menu:openMenu
 *   SPC:spacer1:16
 * ```
 *
 * ## Usage Example
 *
 * ```kotlin
 * val layout = LayoutConfig(
 *     name = "MainScreen",
 *     version = "1.0.0",
 *     components = listOf(...)
 * )
 * val amfContent = AmfLayoutSerializer.serialize(layout)
 * File("layout.amf").writeText(amfContent)
 * ```
 *
 * @since 3.2.0
 * @see AmfLayoutParser for format specification
 * @see AmfLayoutLoader for loading
 */
object AmfLayoutSerializer {

    private const val SCHEMA_VERSION = "amf-lyt-1.0"
    private const val INDENT = "  "

    /**
     * Serialize LayoutConfig to AMF format string.
     *
     * @param layout The layout configuration to serialize
     * @param includeComments Whether to include header comments
     * @return AMF format string
     */
    fun serialize(layout: LayoutConfig, includeComments: Boolean = true): String {
        return buildString {
            // Header
            if (includeComments) {
                appendLine("# AvaMagic Layout: ${layout.name}")
                appendLine("# Generated by AmfLayoutSerializer")
            }
            appendLine("---")
            appendLine("schema: $SCHEMA_VERSION")
            appendLine("---")

            // Layout metadata
            if (layout.description.isNotEmpty()) {
                appendLine("LYT:${layout.name}:${layout.version}:${layout.description}")
            } else {
                appendLine("LYT:${layout.name}:${layout.version}")
            }

            // Components (with nesting)
            for (component in layout.components) {
                serializeComponent(component, 0)
            }
        }
    }

    /**
     * Serialize a component and its children recursively.
     */
    private fun StringBuilder.serializeComponent(component: LayoutComponent, level: Int) {
        val indent = INDENT.repeat(level)
        val line = formatComponentLine(component)
        appendLine("$indent$line")

        // Serialize children with increased indentation
        for (child in component.children) {
            serializeComponent(child, level + 1)
        }
    }

    /**
     * Format a single component as an AMF line.
     */
    private fun formatComponentLine(component: LayoutComponent): String {
        val prefix = component.type.prefix
        val id = component.id
        val props = component.properties

        return when (component.type) {
            ComponentType.COLUMN, ComponentType.ROW, ComponentType.CONTAINER, ComponentType.STACK -> {
                // COL/ROW:id:weight:align
                val weight = props["weight"] ?: "1"
                val align = props["align"] ?: "start"
                "$prefix:$id:$weight:$align"
            }

            ComponentType.TEXT -> {
                // TXT:id:text:style
                val text = props["text"] ?: ""
                val style = props["style"] ?: "body"
                "$prefix:$id:$text:$style"
            }

            ComponentType.BUTTON -> {
                // BTN:id:label:action
                val label = props["label"] ?: ""
                val action = props["action"] ?: ""
                if (action.isNotEmpty()) {
                    "$prefix:$id:$label:$action"
                } else {
                    "$prefix:$id:$label"
                }
            }

            ComponentType.IMAGE -> {
                // IMG:id:src:scale
                val src = props["src"] ?: ""
                val scale = props["scale"] ?: "fit"
                "$prefix:$id:$src:$scale"
            }

            ComponentType.SPACER -> {
                // SPC:id:size
                val size = props["size"] ?: "16"
                "$prefix:$id:$size"
            }

            ComponentType.SCROLL -> {
                // SCR:id:direction:align
                val direction = props["direction"] ?: "vertical"
                val align = props["align"] ?: "start"
                "$prefix:$id:$direction:$align"
            }

            ComponentType.GRID -> {
                // GRD:id:columns:gap
                val columns = props["columns"] ?: "2"
                val gap = props["gap"] ?: "8"
                "$prefix:$id:$columns:$gap"
            }
        }
    }

    /**
     * Serialize to compact single-line format (for embedding).
     *
     * Uses pipe (|) as line separator. Indentation is represented by leading dots.
     *
     * Useful for storing in databases or transmitting over network.
     *
     * @param layout The layout configuration to serialize
     * @return Compact single-line AMF string
     */
    fun serializeCompact(layout: LayoutConfig): String {
        return serialize(layout, includeComments = false)
            .lines()
            .filter { it.isNotBlank() && !it.startsWith("#") }
            .map { line ->
                // Convert leading spaces to dots for compactness
                val leadingSpaces = line.takeWhile { it == ' ' }.length
                val dots = ".".repeat(leadingSpaces / 2)
                dots + line.trimStart()
            }
            .joinToString("|")
    }

    /**
     * Parse compact format back to standard AMF.
     *
     * @param compact The compact format string
     * @return Standard AMF format string
     */
    fun expandCompact(compact: String): String {
        return compact.split("|")
            .joinToString("\n") { line ->
                val dots = line.takeWhile { it == '.' }.length
                val indent = INDENT.repeat(dots)
                indent + line.dropWhile { it == '.' }
            }
    }

    /**
     * Serialize a single component (without header).
     *
     * Useful for partial serialization or debugging.
     *
     * @param component The component to serialize
     * @return AMF format lines for the component tree
     */
    fun serializeComponent(component: LayoutComponent): String {
        return buildString {
            serializeComponent(component, 0)
        }.trimEnd()
    }

    /**
     * Calculate the serialized size in bytes.
     *
     * @param layout The layout to measure
     * @return Size in bytes when serialized
     */
    fun calculateSize(layout: LayoutConfig): Int {
        return serialize(layout, includeComments = false).toByteArray(Charsets.UTF_8).size
    }

    /**
     * Calculate compression ratio compared to JSON.
     *
     * Note: This is an estimate based on typical JSON overhead.
     *
     * @param layout The layout to measure
     * @return Compression ratio (e.g., 0.5 means 50% of JSON size)
     */
    fun estimateCompressionRatio(layout: LayoutConfig): Float {
        val amfSize = calculateSize(layout)
        // Estimate JSON size: AMF is typically ~50% of JSON
        val estimatedJsonSize = amfSize * 2
        return amfSize.toFloat() / estimatedJsonSize
    }
}
