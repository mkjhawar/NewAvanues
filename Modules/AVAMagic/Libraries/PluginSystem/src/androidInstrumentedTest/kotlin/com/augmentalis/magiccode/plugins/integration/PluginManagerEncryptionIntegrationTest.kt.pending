package com.augmentalis.magiccode.plugins.integration

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.augmentalis.magiccode.plugins.core.PluginLog
import com.augmentalis.magiccode.plugins.core.PluginManager
import com.augmentalis.magiccode.plugins.security.PermissionStorage
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import java.io.File

/**
 * Integration tests for encrypted permission storage with PluginManager.
 *
 * Tests verify end-to-end encryption flow:
 * - PluginManager → PermissionStorage integration
 * - Permission grant → encryption → storage → retrieval
 * - Real-world plugin lifecycle scenarios
 * - Error handling and recovery
 *
 * ## Test Strategy
 * - **End-to-end testing**: Full stack from API to storage
 * - **Real components**: No mocking (except external services)
 * - **Realistic scenarios**: Test actual plugin workflows
 * - **Error scenarios**: Test failure modes and recovery
 *
 * @since 1.1.0
 */
@RunWith(AndroidJUnit4::class)
class PluginManagerEncryptionIntegrationTest {

    private lateinit var context: Context
    private lateinit var pluginManager: PluginManager
    private lateinit var permissionStorage: PermissionStorage

    @Before
    fun setUp() {
        context = ApplicationProvider.getApplicationContext()
        cleanupTestFiles()

        // Create real instances (no mocking)
        permissionStorage = PermissionStorage.create(context)
        pluginManager = PluginManager.getInstance(context)
    }

    @After
    fun tearDown() {
        cleanupTestFiles()
    }

    private fun cleanupTestFiles() {
        val sharedPrefsDir = File(context.applicationInfo.dataDir, "shared_prefs")
        sharedPrefsDir.listFiles()?.forEach { file ->
            if (file.name.startsWith("test_") || file.name.startsWith("plugin_permissions")) {
                file.delete()
            }
        }
    }

    /**
     * T020: Test end-to-end permission grant with encryption.
     *
     * **Acceptance Criteria**:
     * - Plugin can request permission via PluginManager
     * - Permission automatically encrypted by PermissionStorage
     * - Plugin can query permission via PluginManager
     * - Permission data not readable via ADB
     *
     * **Success Criteria (SC-001, SC-002, SC-004)**:
     * - Full integration works correctly
     * - Encryption transparent to plugin developers
     * - Hardware keystore used when available
     */
    @Test
    fun testEndToEndPermissionGrantWithEncryption() = runTest {
        // GIVEN: A plugin requesting permissions
        val pluginId = "com.example.integration.plugin"
        val permissions = listOf(
            "android.permission.CAMERA",
            "android.permission.RECORD_AUDIO",
            "android.permission.ACCESS_FINE_LOCATION"
        )

        // WHEN: Permissions are granted via PluginManager
        permissions.forEach { permission ->
            pluginManager.grantPermission(pluginId, permission)
        }

        // THEN: Permissions can be queried via PluginManager
        permissions.forEach { permission ->
            val hasPermission = pluginManager.hasPermission(pluginId, permission)
            assertTrue("Plugin should have $permission", hasPermission)
        }

        // AND: Permissions stored in encrypted format
        val encryptionStatus = permissionStorage.getEncryptionStatus()
        assertTrue("Storage should be encrypted", encryptionStatus.isEncrypted)
        assertEquals("Should use AES256-SIV/AES256-GCM", "AES256-SIV/AES256-GCM", encryptionStatus.encryptionScheme)

        // AND: Data not readable as plain-text on disk
        assertDataIsEncrypted(pluginId, permissions)

        // AND: PluginManager can retrieve all permissions for plugin
        val allPluginPermissions = pluginManager.getPermissions(pluginId)
        assertEquals("Should have ${permissions.size} permissions", permissions.size, allPluginPermissions.size)
        assertTrue("All permissions should be present", allPluginPermissions.containsAll(permissions))

        // AND: Security audit events logged
        // (Manual verification via logcat: adb logcat | grep SECURITY)
        PluginLog.security("IntegrationTest", "Successfully tested end-to-end encryption for $pluginId")
    }

    /**
     * Test permission revocation with encryption.
     *
     * **Acceptance Criteria**:
     * - Revoked permission removed from encrypted storage
     * - Other permissions remain intact
     * - Revocation reflected in queries
     */
    @Test
    fun testPermissionRevocationWithEncryption() = runTest {
        // GIVEN: Plugin with multiple permissions
        val pluginId = "com.example.revoke.plugin"
        val grantedPermissions = listOf(
            "android.permission.CAMERA",
            "android.permission.RECORD_AUDIO",
            "android.permission.ACCESS_FINE_LOCATION"
        )

        grantedPermissions.forEach { permission ->
            pluginManager.grantPermission(pluginId, permission)
        }

        // WHEN: One permission is revoked
        val revokedPermission = "android.permission.CAMERA"
        pluginManager.revokePermission(pluginId, revokedPermission)

        // THEN: Revoked permission no longer accessible
        assertFalse(
            "Revoked permission should not be granted",
            pluginManager.hasPermission(pluginId, revokedPermission)
        )

        // AND: Other permissions still accessible
        val remainingPermissions = grantedPermissions.filter { it != revokedPermission }
        remainingPermissions.forEach { permission ->
            assertTrue(
                "Remaining permission $permission should still be granted",
                pluginManager.hasPermission(pluginId, permission)
            )
        }

        // AND: getAllPermissions reflects revocation
        val allPermissions = pluginManager.getPermissions(pluginId)
        assertEquals("Should have ${remainingPermissions.size} permissions", remainingPermissions.size, allPermissions.size)
        assertFalse("Revoked permission should not appear in list", allPermissions.contains(revokedPermission))
    }

    /**
     * Test clearAllPermissions with encryption.
     *
     * **Acceptance Criteria**:
     * - All permissions removed from encrypted storage
     * - Plugin has no permissions after clear
     * - Encrypted storage file remains (not deleted)
     */
    @Test
    fun testClearAllPermissionsWithEncryption() = runTest {
        // GIVEN: Plugin with multiple permissions
        val pluginId = "com.example.clear.plugin"
        val permissions = listOf(
            "android.permission.CAMERA",
            "android.permission.RECORD_AUDIO",
            "android.permission.ACCESS_FINE_LOCATION",
            "android.permission.READ_CONTACTS"
        )

        permissions.forEach { permission ->
            pluginManager.grantPermission(pluginId, permission)
        }

        // Verify permissions granted
        assertEquals("Should have ${permissions.size} permissions", permissions.size, pluginManager.getPermissions(pluginId).size)

        // WHEN: All permissions cleared
        pluginManager.clearAllPermissions(pluginId)

        // THEN: Plugin has no permissions
        val remainingPermissions = pluginManager.getPermissions(pluginId)
        assertTrue("Plugin should have no permissions", remainingPermissions.isEmpty())

        // AND: Individual permission queries return false
        permissions.forEach { permission ->
            assertFalse(
                "Permission $permission should not be granted",
                pluginManager.hasPermission(pluginId, permission)
            )
        }

        // AND: Encrypted storage file still exists (not deleted)
        val encryptionStatus = permissionStorage.getEncryptionStatus()
        assertTrue("Storage should still be encrypted", encryptionStatus.isEncrypted)
    }

    /**
     * Test multiple plugins with encryption.
     *
     * **Acceptance Criteria**:
     * - Multiple plugins can have permissions independently
     * - One plugin's permissions don't affect another's
     * - All data encrypted in same storage file
     */
    @Test
    fun testMultiplePluginsWithEncryption() = runTest {
        // GIVEN: Multiple plugins with different permissions
        val plugin1 = "com.example.plugin1"
        val plugin1Perms = listOf("android.permission.CAMERA", "android.permission.RECORD_AUDIO")

        val plugin2 = "com.example.plugin2"
        val plugin2Perms = listOf("android.permission.ACCESS_FINE_LOCATION", "android.permission.READ_CONTACTS")

        val plugin3 = "com.example.plugin3"
        val plugin3Perms = listOf("android.permission.WRITE_EXTERNAL_STORAGE")

        // WHEN: Permissions granted to all plugins
        plugin1Perms.forEach { pluginManager.grantPermission(plugin1, it) }
        plugin2Perms.forEach { pluginManager.grantPermission(plugin2, it) }
        plugin3Perms.forEach { pluginManager.grantPermission(plugin3, it) }

        // THEN: Each plugin has correct permissions
        assertEquals("Plugin1 should have ${plugin1Perms.size} permissions", plugin1Perms.size, pluginManager.getPermissions(plugin1).size)
        assertEquals("Plugin2 should have ${plugin2Perms.size} permissions", plugin2Perms.size, pluginManager.getPermissions(plugin2).size)
        assertEquals("Plugin3 should have ${plugin3Perms.size} permissions", plugin3Perms.size, pluginManager.getPermissions(plugin3).size)

        // AND: Plugins don't have each other's permissions
        plugin2Perms.forEach { permission ->
            assertFalse("Plugin1 should not have Plugin2's permission $permission", pluginManager.hasPermission(plugin1, permission))
        }

        plugin1Perms.forEach { permission ->
            assertFalse("Plugin2 should not have Plugin1's permission $permission", pluginManager.hasPermission(plugin2, permission))
        }

        // AND: All data encrypted
        assertDataIsEncrypted(plugin1, plugin1Perms)
        assertDataIsEncrypted(plugin2, plugin2Perms)
        assertDataIsEncrypted(plugin3, plugin3Perms)
    }

    // ========== Helper Methods ==========

    /**
     * Verify that permission data is encrypted on disk (not readable as plain-text).
     */
    private fun assertDataIsEncrypted(pluginId: String, permissions: List<String>) {
        val sharedPrefsDir = File(context.applicationInfo.dataDir, "shared_prefs")
        val encryptedFile = File(sharedPrefsDir, "plugin_permissions_encrypted.xml")

        if (encryptedFile.exists()) {
            val fileContents = encryptedFile.readText()

            // Plugin ID should not appear as plain-text
            assertFalse(
                "Plugin ID should not appear as plain-text in encrypted file",
                fileContents.contains(pluginId)
            )

            // Permissions should not appear as plain-text
            permissions.forEach { permission ->
                assertFalse(
                    "Permission $permission should not appear as plain-text in encrypted file",
                    fileContents.contains(permission)
                )
            }
        }
    }
}
