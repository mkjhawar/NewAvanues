package com.augmentalis.magicui.instantiation

import com.augmentalis.magicui.dsl.VosValue
import com.augmentalis.magicui.registry.PropertyDescriptor

/**
 * Maps DSL properties to Kotlin property values.
 *
 * The PropertyMapper serves as a bridge between the DSL property representation
 * (VosValue sealed class hierarchy) and native Kotlin values. It handles:
 *
 * 1. **Property Extraction**: Converts VosValue types to native Kotlin values
 * 2. **Property Validation**: Ensures required properties are present
 * 3. **Default Values**: Applies default values for missing optional properties
 * 4. **Extensibility**: Handles unknown properties for forward compatibility
 *
 * The mapper is lenient by design - it preserves unknown properties as-is to
 * support evolving component APIs without breaking existing DSL files.
 *
 * Example usage:
 * ```kotlin
 * val mapper = PropertyMapper()
 * val dslProperties = mapOf(
 *     "text" to VosValue.StringValue("Hello"),
 *     "size" to VosValue.FloatValue(16.0f)
 * )
 * val descriptors = mapOf(
 *     "text" to PropertyDescriptor("text", PropertyType.STRING, required = true),
 *     "size" to PropertyDescriptor("size", PropertyType.FLOAT, defaultValue = 14.0f)
 * )
 *
 * val mapped = mapper.mapProperties(dslProperties, descriptors)
 * // Result: {"text": "Hello", "size": 16.0}
 * ```
 *
 * @see VosValue for DSL value types
 * @see PropertyDescriptor for property metadata
 *
 * @since 1.0.0
 * Created: 2025-10-27 12:18:37 PDT
 * Created by Manoj Jhawar, manoj@ideahq.net
 */
class PropertyMapper {

    /**
     * Map DSL properties to target property values.
     *
     * This method performs a complete property mapping pipeline:
     *
     * 1. **Extract DSL Values**: Converts each VosValue to native Kotlin type
     * 2. **Validate Known Properties**: Checks against property descriptors
     * 3. **Preserve Unknown Properties**: Stores unrecognized properties for extensibility
     * 4. **Apply Defaults**: Fills in missing optional properties with defaults
     * 5. **Validate Required**: Ensures all required properties are present
     *
     * The mapping is non-destructive - unknown properties are preserved rather
     * than discarded, allowing components to evolve without breaking old DSL files.
     *
     * @param dslProperties Properties from AST node (VosValue types)
     * @param descriptors Property descriptors from component registry
     * @return Mapped property values (native Kotlin types)
     * @throws PropertyMappingException if required properties are missing
     */
    fun mapProperties(
        dslProperties: Map<String, VosValue>,
        descriptors: Map<String, PropertyDescriptor>
    ): Map<String, Any?> {
        val mapped = mutableMapOf<String, Any?>()

        // Map provided properties
        dslProperties.forEach { (name, value) ->
            val descriptor = descriptors[name]
            if (descriptor != null) {
                // Known property - extract and store
                mapped[name] = extractValue(value)
            } else {
                // Unknown property - store as-is for extensibility
                // This allows components to receive properties not yet in their descriptor
                mapped[name] = extractValue(value)
            }
        }

        // Add default values for missing required properties
        descriptors.forEach { (name, descriptor) ->
            if (!mapped.containsKey(name)) {
                if (descriptor.required) {
                    throw PropertyMappingException(
                        "Required property missing: $name (component: ${descriptor.name})"
                    )
                } else if (descriptor.defaultValue != null) {
                    mapped[name] = descriptor.defaultValue
                }
            }
        }

        return mapped
    }

    /**
     * Extract native Kotlin value from VosValue.
     *
     * Recursively converts VosValue sealed class instances to their native
     * Kotlin equivalents:
     *
     * - StringValue → String
     * - IntValue → Int
     * - FloatValue → Float
     * - BoolValue → Boolean
     * - ArrayValue → List<Any?>
     * - ObjectValue → Map<String, Any?>
     * - NullValue → null
     *
     * Collections (arrays and objects) are processed recursively, allowing
     * for arbitrarily nested data structures.
     *
     * @param vosValue VosValue instance to extract
     * @return Native Kotlin value (String, Int, Float, Boolean, List, Map, or null)
     */
    private fun extractValue(vosValue: VosValue): Any? {
        return when (vosValue) {
            is VosValue.StringValue -> vosValue.value
            is VosValue.IntValue -> vosValue.value
            is VosValue.FloatValue -> vosValue.value
            is VosValue.BoolValue -> vosValue.value
            is VosValue.ArrayValue -> vosValue.items.map { extractValue(it) }
            is VosValue.ObjectValue -> vosValue.properties.mapValues { extractValue(it.value) }
            is VosValue.NullValue -> null
        }
    }
}

/**
 * Exception thrown when property mapping fails.
 *
 * This exception is thrown in scenarios such as:
 * - Required property is missing
 * - Property value cannot be extracted
 * - Property format is invalid
 *
 * The exception message should clearly indicate which property failed and why,
 * to help DSL authors debug their configuration.
 *
 * Example:
 * ```
 * PropertyMappingException("Required property missing: initialColor (component: ColorPicker)")
 * ```
 *
 * @param message Detailed error message
 * @param cause Optional underlying cause
 *
 * @since 1.0.0
 * Created: 2025-10-27 12:18:37 PDT
 * Created by Manoj Jhawar, manoj@ideahq.net
 */
class PropertyMappingException(message: String, cause: Throwable? = null) : Exception(message, cause)
