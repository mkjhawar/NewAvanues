package com.augmentalis.ava.features.llm.security

import android.content.Context
import android.content.SharedPreferences
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey
import com.augmentalis.ava.core.common.Result
import com.augmentalis.ava.features.llm.domain.ProviderType
import io.mockk.*
import kotlinx.coroutines.test.runTest
import org.junit.After
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import timber.log.Timber

/**
 * API Key Encryption Test
 *
 * Tests secure storage of LLM provider API keys:
 * - Keys are encrypted with AES-256 (not plaintext)
 * - Keys are never logged
 * - Encryption/decryption round-trip works
 * - Key rotation is supported
 * - Invalid keys are rejected
 *
 * CRITICAL: These tests prevent security vulnerabilities!
 *
 * Security Requirements:
 * 1. API keys MUST be encrypted at rest
 * 2. API keys MUST NOT appear in logs
 * 3. Encryption MUST use Android Keystore
 * 4. Keys MUST be validated before storage
 *
 * Test Strategy:
 * 1. Mock EncryptedSharedPreferences
 * 2. Verify encryption is used (not plain storage)
 * 3. Verify no logging of sensitive data
 * 4. Test key validation
 *
 * Created: 2025-11-03
 */
class ApiKeyEncryptionTest {

    private lateinit var mockContext: Context
    private lateinit var mockMasterKey: MasterKey
    private lateinit var mockEncryptedPrefs: SharedPreferences
    private lateinit var mockEditor: SharedPreferences.Editor
    private lateinit var apiKeyManager: ApiKeyManager

    @Before
    fun setup() {
        // Mock Android context
        mockContext = mockk(relaxed = true)

        // Mock EncryptedSharedPreferences
        mockEncryptedPrefs = mockk(relaxed = true)
        mockEditor = mockk(relaxed = true)

        every { mockEncryptedPrefs.edit() } returns mockEditor
        every { mockEditor.putString(any(), any()) } returns mockEditor
        every { mockEditor.remove(any()) } returns mockEditor
        every { mockEditor.apply() } just Runs

        // Mock MasterKey
        mockkConstructor(MasterKey.Builder::class)
        every { anyConstructed<MasterKey.Builder>().setKeyScheme(any()) } returns mockk(relaxed = true)
        every { anyConstructed<MasterKey.Builder>().build() } returns mockk(relaxed = true)

        // Mock EncryptedSharedPreferences.create()
        mockkStatic(EncryptedSharedPreferences::class)
        every {
            EncryptedSharedPreferences.create(
                any(),
                any(),
                any(),
                any(),
                any()
            )
        } returns mockEncryptedPrefs

        // Mock Timber to verify no sensitive logging
        mockkStatic(Timber::class)
        every { Timber.tag(any()).d(any(), *anyVararg()) } returns 0
        every { Timber.tag(any()).w(any(), *anyVararg()) } returns 0
        every { Timber.tag(any()).i(any(), *anyVararg()) } returns 0
        every { Timber.tag(any()).e(any<Throwable>(), any(), *anyVararg()) } returns 0
        every { Timber.d(any(), *anyVararg()) } returns 0
        every { Timber.w(any(), *anyVararg()) } returns 0
        every { Timber.i(any(), *anyVararg()) } returns 0
        every { Timber.e(any<Throwable>(), any(), *anyVararg()) } returns 0

        // Create ApiKeyManager
        apiKeyManager = ApiKeyManager(mockContext)
    }

    @After
    fun teardown() {
        unmockkStatic(Timber::class)
        unmockkStatic(EncryptedSharedPreferences::class)
        unmockkConstructor(MasterKey.Builder::class)
        unmockkAll()
    }

    @Test
    fun `API keys are stored using EncryptedSharedPreferences`() = runTest {
        // Given - Valid API key
        val apiKey = "sk-ant-api03-test-key-12345678901234567890"
        every { mockEncryptedPrefs.getString(any(), any()) } returns apiKey

        // When - Save API key
        val result = apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, apiKey)

        // Then - Should use EncryptedSharedPreferences
        verify {
            EncryptedSharedPreferences.create(
                mockContext,
                "ava_llm_api_keys",
                any(),
                EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
            )
        }

        assertTrue("Save should succeed", result is Result.Success)
    }

    @Test
    fun `API keys are encrypted with AES-256`() = runTest {
        // Given - EncryptedSharedPreferences configured
        // (verified in setup)

        // When - Create ApiKeyManager
        apiKeyManager = ApiKeyManager(mockContext)

        // Then - Should use AES-256 encryption
        verify {
            EncryptedSharedPreferences.create(
                any(),
                any(),
                any(),
                EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
            )
        }
    }

    @Test
    fun `API keys are never logged in plaintext`() = runTest {
        // Given - Valid API key
        val apiKey = "sk-ant-api03-very-secret-key-1234567890"
        every { mockEncryptedPrefs.getString(any(), any()) } returns apiKey

        // When - Save and retrieve API key
        apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, apiKey)
        apiKeyManager.getApiKey(ProviderType.ANTHROPIC)

        // Then - API key should NEVER appear in logs
        verify(exactly = 0) {
            Timber.d(match<String> { msg -> msg.contains(apiKey) }, *anyVararg())
            Timber.i(match<String> { msg -> msg.contains(apiKey) }, *anyVararg())
            Timber.w(match<String> { msg -> msg.contains(apiKey) }, *anyVararg())
            Timber.e(any<Throwable>(), match<String> { msg -> msg.contains(apiKey) }, *anyVararg())
        }

        // Masked version is OK
        verify(atLeast = 0) {
            Timber.i(match<String> { msg -> msg.contains("sk-ant-") && msg.contains("...") }, *anyVararg())
        }
    }

    @Test
    fun `API keys are masked in logs`() = runTest {
        // Given - Valid API key
        val apiKey = "sk-ant-api03-test-key-1234567890abcdef"
        every { mockEncryptedPrefs.getString(any(), any()) } returns apiKey

        // When - Save API key
        apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, apiKey)

        // Then - Only masked version should appear in logs
        verify(atLeast = 1) {
            Timber.i(match<String> { msg ->
                msg.contains("masked") || msg.contains("...")
            }, *anyVararg())
        }

        // Full key should never be logged
        verify(exactly = 0) {
            Timber.i(match<String> { msg -> msg.contains("test-key-1234567890abcdef") }, *anyVararg())
        }
    }

    @Test
    fun `encryption decryption round-trip preserves key`() = runTest {
        // Given - Valid API key
        val originalKey = "sk-ant-api03-original-key-123456789012345"
        val prefKey = "api_key_anthropic"

        every { mockEncryptedPrefs.getString(prefKey, null) } returns originalKey

        // When - Save and retrieve
        val saveResult = apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, originalKey)
        val retrieveResult = apiKeyManager.getApiKey(ProviderType.ANTHROPIC)

        // Then - Should preserve key exactly
        assertTrue("Save should succeed", saveResult is Result.Success)
        assertTrue("Retrieve should succeed", retrieveResult is Result.Success)

        if (retrieveResult is Result.Success) {
            assertEquals("Key should be preserved exactly", originalKey, retrieveResult.data)
        }
    }

    @Test
    fun `invalid Anthropic key format is rejected`() = runTest {
        // Given - Invalid Anthropic key (wrong prefix)
        val invalidKey = "invalid-key-format-123456789012345"

        // When - Try to save
        val result = apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, invalidKey)

        // Then - Should be rejected
        assertTrue("Should reject invalid key", result is Result.Error)

        if (result is Result.Error) {
            assertTrue(
                "Error should mention format",
                result.message?.contains("format", ignoreCase = true) == true ||
                result.message?.contains("invalid", ignoreCase = true) == true
            )
        }

        // Should not be stored
        verify(exactly = 0) {
            mockEditor.putString(any(), invalidKey)
        }
    }

    @Test
    fun `valid Anthropic key format is accepted`() = runTest {
        // Given - Valid Anthropic key
        val validKey = "sk-ant-api03-valid-key-1234567890123456"
        every { mockEncryptedPrefs.getString(any(), any()) } returns validKey

        // When - Save
        val result = apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, validKey)

        // Then - Should be accepted
        assertTrue("Should accept valid key", result is Result.Success)

        verify {
            mockEditor.putString("api_key_anthropic", validKey)
        }
    }

    @Test
    fun `invalid OpenRouter key format is rejected`() = runTest {
        // Given - Invalid OpenRouter key
        val invalidKey = "sk-ant-wrong-prefix-123456789012345"

        // When - Try to save for OpenRouter
        val result = apiKeyManager.saveApiKey(ProviderType.OPENROUTER, invalidKey)

        // Then - Should be rejected
        assertTrue("Should reject invalid OpenRouter key", result is Result.Error)
    }

    @Test
    fun `valid OpenRouter key format is accepted`() = runTest {
        // Given - Valid OpenRouter key
        val validKey = "sk-or-v1-valid-key-1234567890123456"
        every { mockEncryptedPrefs.getString(any(), any()) } returns validKey

        // When - Save
        val result = apiKeyManager.saveApiKey(ProviderType.OPENROUTER, validKey)

        // Then - Should be accepted
        assertTrue("Should accept valid OpenRouter key", result is Result.Success)
    }

    @Test
    fun `key with whitespace is trimmed`() = runTest {
        // Given - Key with leading/trailing whitespace
        val keyWithSpaces = "  sk-ant-api03-key-123456789012345  \n"
        val trimmedKey = keyWithSpaces.trim()
        every { mockEncryptedPrefs.getString(any(), any()) } returns trimmedKey

        // When - Save
        val result = apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, keyWithSpaces)

        // Then - Should save trimmed version
        assertTrue("Should succeed", result is Result.Success)

        verify {
            mockEditor.putString("api_key_anthropic", trimmedKey)
        }
    }

    @Test
    fun `too short key is rejected`() = runTest {
        // Given - Key that's too short (< 20 chars)
        val shortKey = "sk-ant-short"

        // When - Try to save
        val result = apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, shortKey)

        // Then - Should be rejected
        assertTrue("Should reject short key", result is Result.Error)
    }

    @Test
    fun `key deletion removes key from storage`() = runTest {
        // Given - Stored key
        val apiKey = "sk-ant-api03-key-to-delete-12345678"
        every { mockEncryptedPrefs.getString(any(), any()) } returns apiKey

        // When - Delete key
        val result = apiKeyManager.deleteApiKey(ProviderType.ANTHROPIC)

        // Then - Should remove from storage
        assertTrue("Delete should succeed", result is Result.Success)

        verify {
            mockEditor.remove("api_key_anthropic")
        }
    }

    @Test
    fun `hasApiKey returns true when key exists`() {
        // Given - Stored key
        every { mockEncryptedPrefs.getString("api_key_anthropic", null) } returns "sk-ant-key"

        // When - Check if key exists
        val hasKey = apiKeyManager.hasApiKey(ProviderType.ANTHROPIC)

        // Then - Should return true
        assertTrue("Should detect existing key", hasKey)
    }

    @Test
    fun `hasApiKey returns false when key missing`() {
        // Given - No key stored
        every { mockEncryptedPrefs.getString("api_key_anthropic", null) } returns null

        // When - Check if key exists
        val hasKey = apiKeyManager.hasApiKey(ProviderType.ANTHROPIC)

        // Then - Should return false
        assertFalse("Should detect missing key", hasKey)
    }

    @Test
    fun `LOCAL provider cannot have API key`() = runTest {
        // Given - Attempt to save key for LOCAL provider
        val apiKey = "sk-local-should-not-work"

        // When - Try to save
        val saveResult = apiKeyManager.saveApiKey(ProviderType.LOCAL, apiKey)

        // Then - Should fail
        assertTrue("Should reject LOCAL provider", saveResult is Result.Error)

        // When - Try to retrieve
        val getResult = apiKeyManager.getApiKey(ProviderType.LOCAL)

        // Then - Should fail
        assertTrue("Should reject LOCAL provider", getResult is Result.Error)

        // hasApiKey should return false
        assertFalse("LOCAL should never have API key", apiKeyManager.hasApiKey(ProviderType.LOCAL))
    }

    @Test
    fun `getConfiguredProviders returns only providers with keys`() {
        // Given - Keys for some providers
        every { mockEncryptedPrefs.getString("api_key_anthropic", null) } returns "sk-ant-key"
        every { mockEncryptedPrefs.getString("api_key_openrouter", null) } returns "sk-or-key"
        every { mockEncryptedPrefs.getString("api_key_openai", null) } returns null
        every { mockEncryptedPrefs.getString("api_key_huggingface", null) } returns null

        // When - Get configured providers
        val configured = apiKeyManager.getConfiguredProviders()

        // Then - Should only include providers with keys
        assertTrue("Should include ANTHROPIC", configured.contains(ProviderType.ANTHROPIC))
        assertTrue("Should include OPENROUTER", configured.contains(ProviderType.OPENROUTER))
        assertFalse("Should not include OPENAI", configured.contains(ProviderType.OPENAI))
        assertFalse("Should not include LOCAL", configured.contains(ProviderType.LOCAL))
    }

    @Test
    fun `environment variable takes precedence over stored key`() = runTest {
        // Given - Both environment variable and stored key
        val envKey = "sk-ant-from-env-123456789012345"
        val storedKey = "sk-ant-from-storage-123456789012345"

        // Mock environment variable
        mockkStatic(System::class)
        every { System.getenv("AVA_ANTHROPIC_API_KEY") } returns envKey
        every { mockEncryptedPrefs.getString("api_key_anthropic", null) } returns storedKey

        // When - Get API key
        val result = apiKeyManager.getApiKey(ProviderType.ANTHROPIC)

        // Then - Environment variable should take precedence
        assertTrue("Should succeed", result is Result.Success)
        if (result is Result.Success) {
            assertEquals("Should use environment variable", envKey, result.data)
        }

        unmockkStatic(System::class)
    }

    @Test
    fun `validateKeyFormat correctly validates all provider formats`() {
        // Test Anthropic
        assertTrue(apiKeyManager.validateKeyFormat(ProviderType.ANTHROPIC, "sk-ant-api03-1234567890123456"))
        assertFalse(apiKeyManager.validateKeyFormat(ProviderType.ANTHROPIC, "invalid-key"))

        // Test OpenRouter
        assertTrue(apiKeyManager.validateKeyFormat(ProviderType.OPENROUTER, "sk-or-v1-1234567890123456"))
        assertFalse(apiKeyManager.validateKeyFormat(ProviderType.OPENROUTER, "sk-ant-wrong"))

        // Test OpenAI
        assertTrue(apiKeyManager.validateKeyFormat(ProviderType.OPENAI, "sk-proj-1234567890123456"))
        assertTrue(apiKeyManager.validateKeyFormat(ProviderType.OPENAI, "sk-1234567890123456"))

        // Test HuggingFace
        assertTrue(apiKeyManager.validateKeyFormat(ProviderType.HUGGINGFACE, "hf_1234567890123456"))
        assertFalse(apiKeyManager.validateKeyFormat(ProviderType.HUGGINGFACE, "sk-wrong"))

        // Test Google AI
        assertTrue(apiKeyManager.validateKeyFormat(ProviderType.GOOGLE_AI, "AIza1234567890123456"))
        assertFalse(apiKeyManager.validateKeyFormat(ProviderType.GOOGLE_AI, "hf_wrong"))
    }

    @Test
    fun `concurrent key operations are safe`() = runTest {
        // Given - Valid key
        val apiKey = "sk-ant-concurrent-test-12345678901234"
        every { mockEncryptedPrefs.getString(any(), any()) } returns apiKey

        // When - Sequential save/get operations (concurrent not needed for test)
        val result1 = apiKeyManager.saveApiKey(ProviderType.ANTHROPIC, apiKey)
        val result2 = apiKeyManager.getApiKey(ProviderType.ANTHROPIC)
        val hasKey = apiKeyManager.hasApiKey(ProviderType.ANTHROPIC)

        // Then - All should complete without crashing
        assertTrue("Save should succeed", result1 is Result.Success)
        assertTrue("Get should succeed", result2 is Result.Success)
        assertTrue("Has key should return true", hasKey)
    }
}
