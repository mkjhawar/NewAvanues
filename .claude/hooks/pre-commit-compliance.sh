#!/bin/bash
# IDEACODE Zero Tolerance Compliance - Pre-Commit Hook
# Blocks commits that violate zero tolerance rules

set -e

# Colors
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m'

VIOLATIONS=()
WARNINGS=()

echo -e "${YELLOW}ğŸ” Checking Zero Tolerance Compliance...${NC}"

# ============================================================================
# RULE 1: NO MAIN COMMITS
# ============================================================================
current_branch=$(git branch --show-current 2>/dev/null || echo "unknown")
if [[ "$current_branch" == "main" ]] || [[ "$current_branch" == "master" ]]; then
    VIOLATIONS+=("âŒ ZERO TOLERANCE: Commits to main/master forbidden. Use feature/, bugfix/, or hotfix/ branches.")
fi

# ============================================================================
# RULE 2: MANDATORY NAMING - Check staged files
# ============================================================================
staged_files=$(git diff --cached --name-only --diff-filter=A)

for file in $staged_files; do
    # Skip hidden files, config files, and directories
    [[ "$file" =~ ^\. ]] && continue
    [[ "$file" =~ \.(json|yaml|yml|toml|sh|ts|kt|swift|gradle)$ ]] && continue
    [[ ! -f "$file" ]] && continue

    # Check markdown files in docs/
    if [[ "$file" =~ \.md$ ]] && [[ "$file" =~ ^(docs|Docs)/ ]]; then
        basename=$(basename "$file")

        # Living docs: LD-App-Module-Desc-V#.md
        if [[ "$basename" =~ ^LD- ]]; then
            if [[ ! "$basename" =~ ^LD-[A-Z][a-zA-Z]+-[A-Z][a-zA-Z]+-[A-Z][a-zA-Z]+-V[0-9]+\.md$ ]]; then
                VIOLATIONS+=("âŒ ZERO TOLERANCE: Invalid living doc name: $file (must be LD-App-Module-Desc-V#.md)")
            fi
        # Regular docs: App-Module-Desc-YDDMMHH-V#.md
        elif [[ ! "$basename" =~ ^\.\./ ]] && [[ ! "$basename" =~ ^(README|CHANGELOG|LICENSE|CONTRIBUTING) ]]; then
            if [[ ! "$basename" =~ ^[A-Z][a-zA-Z]+-[A-Z][a-zA-Z]+-.+-[0-9]{7}-V[0-9]+\.md$ ]]; then
                VIOLATIONS+=("âŒ ZERO TOLERANCE: Invalid doc name: $file (must be App-Module-Desc-YDDMMHH-V#.md, Y=single digit)")
            fi
        fi
    fi
done

# ============================================================================
# RULE 3: NO AI MARKS - Check commit message
# ============================================================================
commit_msg_file=".git/COMMIT_EDITMSG"
if [[ -f "$commit_msg_file" ]]; then
    commit_msg=$(cat "$commit_msg_file" 2>/dev/null || echo "")

    # Check for AI generation marks
    if echo "$commit_msg" | grep -qiE "(generated by|created by claude|AI generated|auto-generated by AI)"; then
        VIOLATIONS+=("âŒ ZERO TOLERANCE: Commit message contains AI generation marks")
    fi

    # Check for emojis (but allow conventional commit prefixes like feat:, fix:)
    if echo "$commit_msg" | grep -qE "[ğŸ˜€-ğŸ™ğŸŒ€-ğŸ—¿ğŸš€-ğŸ›¿]"; then
        VIOLATIONS+=("âŒ ZERO TOLERANCE: Commit message contains emojis")
    fi
fi

# ============================================================================
# RULE 4: NO HARDWIRING - Check for common hardcoded values
# ============================================================================
for file in $staged_files; do
    [[ ! -f "$file" ]] && continue
    [[ "$file" =~ \.(json|md|yaml|yml)$ ]] && continue

    # Check for hardcoded localhost IPs (except in config files)
    if grep -qE "http://(localhost|127\.0\.0\.1):[0-9]+" "$file" 2>/dev/null; then
        if [[ ! "$file" =~ (config|settings|constants|env) ]]; then
            WARNINGS+=("âš ï¸  Possible hardcoded URL in $file (should use config/env)")
        fi
    fi

    # Check for hardcoded API keys
    if grep -qiE "(api[_-]?key|secret[_-]?key|password)\s*=\s*['\"][a-zA-Z0-9]{20,}" "$file" 2>/dev/null; then
        VIOLATIONS+=("âŒ ZERO TOLERANCE: Hardcoded API key/secret in $file (use env vars)")
    fi
done

# ============================================================================
# RULE 5: NO DUPLICATION - Check for copy-pasted code blocks
# ============================================================================
# This is a simplified check - full check would need AST analysis
for file in $staged_files; do
    [[ ! -f "$file" ]] && continue
    [[ ! "$file" =~ \.(ts|kt|swift|js)$ ]] && continue

    # Check for suspicious comment patterns indicating copy-paste
    if grep -qE "^[[:space:]]*//.*TODO.*remove.*duplicate" "$file" 2>/dev/null; then
        WARNINGS+=("âš ï¸  Possible duplicate code marked in $file")
    fi
done

# ============================================================================
# RULE 6: REGISTRY CHECK - Verify PROJECT-REGISTRY.json if modified
# ============================================================================
if echo "$staged_files" | grep -q "PROJECT-REGISTRY.json"; then
    registry_file="PROJECT-REGISTRY.json"

    # Validate JSON syntax
    if ! jq empty "$registry_file" 2>/dev/null; then
        VIOLATIONS+=("âŒ ZERO TOLERANCE: PROJECT-REGISTRY.json has invalid JSON syntax")
    else
        # Check metadata consistency
        total=$(jq -r '.metadata.total_projects' "$registry_file")
        actual=$(jq '.projects | length' "$registry_file")
        if [[ "$total" != "$actual" ]]; then
            VIOLATIONS+=("âŒ ZERO TOLERANCE: PROJECT-REGISTRY.json metadata mismatch (says $total, has $actual)")
        fi
    fi
fi

# ============================================================================
# RULE 7: REPO DETECTION - Check if multi-repo changes without explicit flag
# ============================================================================
# Check if any files outside current repo are staged
current_repo=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
repo_name=$(basename "$current_repo")

for file in $staged_files; do
    file_abs_path=$(cd "$(dirname "$file")" 2>/dev/null && pwd || echo "")
    if [[ -n "$file_abs_path" ]] && [[ ! "$file_abs_path" =~ ^$current_repo ]]; then
        VIOLATIONS+=("âŒ ZERO TOLERANCE: File $file is outside current repo ($repo_name). Multi-repo commits forbidden.")
    fi
done

# ============================================================================
# RESULTS
# ============================================================================

# Print warnings
if [[ ${#WARNINGS[@]} -gt 0 ]]; then
    echo ""
    echo -e "${YELLOW}âš ï¸  WARNINGS (non-blocking):${NC}"
    for warning in "${WARNINGS[@]}"; do
        echo -e "  ${YELLOW}$warning${NC}"
    done
fi

# Print violations
if [[ ${#VIOLATIONS[@]} -gt 0 ]]; then
    echo ""
    echo -e "${RED}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${RED}  COMMIT BLOCKED - ZERO TOLERANCE VIOLATIONS${NC}"
    echo -e "${RED}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    for violation in "${VIOLATIONS[@]}"; do
        echo -e "  ${RED}$violation${NC}"
    done
    echo ""
    echo -e "${YELLOW}Fix violations and try again.${NC}"
    echo -e "${YELLOW}To bypass (DANGEROUS): git commit --no-verify${NC}"
    echo ""
    exit 1
fi

# Success
echo -e "${GREEN}âœ… Zero Tolerance Compliance: PASS${NC}"
exit 0
